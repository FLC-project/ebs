<!DOCTYPE html>
<!--
Copyright (Â©) 2014-2015 Angelo Borsotti. All Rights Reserved.
-->
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<title>Regular Expressions Parse Trees</title>
<style type=text/css>
body {
    font-size: 11pt;
    font-family: "Verdana";
    font-weight: normal;
    font-style: normal;
    color: black;
    background-color: white;
    margin-left: 2em;
    margin-right: 2em;
}
.rho {
    border-collapse: collapse;
    border: 1px solid LightGray;
    font-size:9pt;
}
.rho TD {
    border: 1px solid LightGray;
}

.trcButton {
    background-color: WhiteSmoke;
    border-radius: 3px;
    box-shadow: 2px 2px 2px gray;
    font-size:9pt;
}
.trcButtonOn {
    background-color: Gainsboro;
    border-radius: 3px;
    box-shadow: 2px 2px 2px gray inset;
    font-size:9pt;
}
.trcButton:hover, .trcButtonOn:hover {
    background-color: Lavender;
}

.llabel {
    font-size: 9pt;
}
.llabel1 {
    text-indent: -2em;
}
.llabel2 {
    text-indent: -1em;
}
.longlabel {
    border:1px solid black;
    background-color: LemonChiffon;
    padding: 5px;
    display: none;
    position: absolute;
}

@keyframes blink {
    0% {box-shadow: 0 0 5px green;}
    20% {box-shadow: 0 0 10px green;}
    40% {box-shadow: 0 0 15px green;}
    60% {box-shadow: 0 0 10px green;}
    80% {box-shadow: 0 0 5px green;}
    100% {box-shadow: none;}
}
@-webkit-keyframes blink {
    0% {box-shadow: 0 0 5px green;}
    20% {box-shadow: 0 0 10px green;}
    40% {box-shadow: 0 0 15px green;}
    60% {box-shadow: 0 0 10px green;}
    80% {box-shadow: 0 0 5px green;}
    100% {box-shadow: none;}
}
@keyframes blinksvg {
    0% {stroke-width:1px; stroke:black;}
    10% {stroke-width:2px; stroke:#323232;}
    20% {stroke-width:3px; stroke:#646464;}
    30% {stroke-width:4px; stroke:#969696;}
    40% {stroke-width:5px; stroke:#c8c8c8;}
    50% {stroke-width:6px; stroke:#e1e1e1;}
    60% {stroke-width:5px; stroke:#c8c8c8;}
    70% {stroke-width:4px; stroke:#969696;}
    80% {stroke-width:3px; stroke:#646464;}
    90% {stroke-width:2px; stroke:#323232;}
    100% {stroke-width:1px; stroke:black;}
}
@-webkit-keyframes blinksvg {
    0% {stroke-width:1px; stroke:black;}
    10% {stroke-width:2px; stroke:#323232;}
    20% {stroke-width:3px; stroke:#646464;}
    30% {stroke-width:4px; stroke:#969696;}
    40% {stroke-width:5px; stroke:#c8c8c8;}
    50% {stroke-width:6px; stroke:#e1e1e1;}
    60% {stroke-width:5px; stroke:#c8c8c8;}
    70% {stroke-width:4px; stroke:#969696;}
    80% {stroke-width:3px; stroke:#646464;}
    90% {stroke-width:2px; stroke:#323232;}
    100% {stroke-width:1px; stroke:black;}
}

.lefthandle {
    cursor:w-resize;
    position:absolute;
    width:5px;
}
.bottomhandle {
    cursor:s-resize;
    position:absolute;
    height:5px;
}
.overlay {
    border:1px dashed grey;
    position:absolute;
}

.subn {
    position:relative;
    left:-5pt;
    font-size:80%;
/*
    height:2em;
    display:inline-block;
    width:0px;
*/
    vertical-align: -10pt;
}</style>
<script>
// ---------- Tracing -----------------

var trc = {};           // trace flags

// trace the specified arguments. If there are several, trace them separated by spaces.
function twriteln(args){
    var str = "";
    for (var i = 0; i < arguments.length; i++){
        if (str.length > 0) str += " ";
        str += arguments[i];
    }
    console.log(str);
}

// trace the specified arguments if the trace flag specified by the first is set.
// If there are more than two arguments, trace them separated by spaces.
function trace(f,str){
    if (!(f in trc)) return;
    var arr = [];
    for (var i = 1; i < arguments.length; i++){
        arr[arr.length] = arguments[i];
    }
    twriteln.apply(null,arr);
}

// set the specified trace flags
function settrc(s){
    trc = {};
    if (!s) return;
    for (var i = 0; i < s.length; i++){
        trc[s.charAt(i)] = true;
    }
}

// callback to set the flags. N.B. the field is kept so as to make the browser load it
// with the previous value when the page is reloaded (otherwise there is a need to set
// each time the flags manually on the gui)
function tracecallback(){
    var f = document.getElementById("trcflag");
    settrc(f.value);
}

// callback to keep pressed the trace buttons
function clicktrc(ele){
    var f = ele.getAttribute("data-f");
    if (ele.className == "trcButton"){
        ele.className = "trcButtonOn";
        trc[f] = true;
    } else {
        ele.className = "trcButton";
        delete trc[f];
    }
    var str = "";
    for (i in trc){
        str += i;
    }
    document.getElementById("trcflag").value = str;
}

// set the trace flags taking them from the trace buttons
function setTrace(){
    if (!debug) return;
    tracecallback();              // set the trace flags from the trace field
    var form = document.getElementById("tracefls");
    var str = "";
    var children = form.childNodes;
    for (var i = 0; i < children.length; i++){
        if (children[i].className == "trcButton"){
            var f = children[i].getAttribute("data-f");
            if (f in trc){
                children[i].className = "trcButtonOn";
                str += f;
            }
        } else if (children[i].className == "trcButtonOn"){
            var f = children[i].getAttribute("data-f");
            trc[f] = true;
            str += f;
        }
    }
    document.getElementById("trcflag").value = str;
}

// trace the specified object (own: true to trace only the specific properties)
function traceObject(obj,own){
    if (typeof(obj) != "object") return;
    if (obj == null) twriteln("null");
    if (obj.length == 0) twriteln("[]");
    for (var i in obj){
        if (own && !obj.hasOwnProperty(i)) continue;
        twriteln(i + ":",obj[i]);
    }
}

// deliver a string representing the specified object (own: true to trace only the specific properties)
function objToString(obj,own){
    if (typeof(obj) != "object") return obj;
    if (obj == null) return "null";
    if (obj.length == 0) return "[]";
    if (arguments.length == 1) own = true;
    var res = "";
    for (var i in obj){
        if (own && !obj.hasOwnProperty(i)) continue;
        if (res.length > 0) res += " ";
        res += i + ": " + obj[i];
    }
    return res;
}

</script>
<script>
// ---------- Collection classes -----------------

// In javascript 1.8 Sets of objects are useless, and so are maps, unless one has a means
// to make objects unique: they do not take into account the equals() method to tell the
// objects or keys that are equal.
// This is a rather inefficient implementation, good for experimenting.

// sets
function SetClass(){
    this.arr = [];       // very bare implementation using an array

    // remove all the elements
    this.clear = function(){
        this.arr = [];
    }

    // add the specified element (if not present), and return true if it was not present
    this.add = function(ele){
        for (var i = 0; i < this.arr.length; i++){
            if (typeof(this.arr[i]) == typeof(ele)){
                if (typeof(this.arr[i]) == "object"){
                    if (this.arr[i].equals(ele)) return false;
                } else {
                    if (this.arr[i] == ele) return false;
                }
            }
        }
        this.arr[this.arr.length] = ele;
        return true;
    }

    // add all the elements of the specified set
    this.addAll = function(set){
        l: for (var i = 0; i < set.arr.length; i++){
            for (var j = 0; j < this.arr.length; j++){
                if (set.arr[i].equals(this.arr[j])) continue l;
            }
            this.arr[this.arr.length] = set.arr[i];
        }
    }

    // deliver an array containing all the elements
    this.toArray = function(){
        var arr = [];
        for (var i = 0; i < this.arr.length; i++){
            arr[arr.length] = this.arr[i];
        }
        return arr;
    }

    // tell if this set contains the same elements as the specificed one
    this.equals = function(other){
        return arraysIdentical(this.arr,other.arr);
    }

    // deliver the number of elements
    this.size = function(other){
        return this.arr.length;
    }

    // deliver a string representing this set
    this.toString = function(){
        var str = "{";
        for (var i = 0; i < this.arr.length; i++){
            if (i == 0) str += " ";
            str += this.arr[i];
        }
        str += "}";
        return str;
    }

    // remove the element at the specified index
    this.remove = function(idx){
        this.arr.splice(idx,1);
    }

    // tell if this set contains the specified element
    this.contains = function(ele){
        for (var i = 0; i < this.arr.length; i++){
            if (this.arr[i].equals(ele)) return true;
        }
        return false;
    }

    // return an iterator
    this.iterator = function(){
        var set = this;
        return {
            "current": 0,
            "set": set,
            "hasNext": function(){
                return this.current < set.arr.length;
            },
            "next": function(){
                return set.arr[this.current++];
            }
        }
    }
}

// maps
function MapClass(){
    this.arr = [];       // very bare implementation using an arr

    // remove all the entries
    this.clear = function(){
        this.arr = [];
    }

    // deliver the index of the entry of the specified key
    this.getEntryIndex = function(key){
        var found = -1;
        for (var i = 0; i < this.arr.length; i++){
            var entry = this.arr[i];
            var mkey = entry[0];
            if (typeof(mkey) == typeof(key)){
                if (Array.isArray(key)){
                    if (arraysIdentical(mkey,key)){
                        found = i;
                        break;
                    }
                } else if (typeof(mkey) == "object"){
                    if (mkey.equals(key)){
                        found = i;
                        break;
                    }
                } else {
                    if (mkey == key){
                        found = i;
                        break;
                    }
                }
            }
        }
        return found;
    }

    // deliver the value associated to the specified key
    this.get = function(key){
        var res = null;
        var found = this.getEntryIndex(key);
        if (found >= 0){
            res = this.arr[found][1];
        }
        return res;
    }

    // deliver the entry at the specified index
    this.getEntry = function(i){
        return this.arr[i];
    }

    // add the specified entry
    this.set = function(key,val){
        var res = null;
        var found = this.getEntryIndex(key);
        if (found >= 0){
            res = this.arr[found][1];
            this.arr[found][1] = val;
        } else {
            this.arr[this.arr.length] = [key,val];
        }
        return res;
    }

    // deliver the number of entries
    this.size = function(other){
        return this.arr.length;
    }

    // deliver a string representin this map
    this.toString = function(){
        var str = "{";
        for (var i = 0; i < this.arr; i++){
            if (i == 0) str += " ";
            str += this.arr[i][0] + "=" + this.arr[i][1];
        }
        str += "}";
        return str;
    }
}

// string buffers
function StringBuilder(){
    this.str = "";

    // append the specified string
    this.append = function(str){
        this.str += str;
    }

    // deliver a string representing the contents of this buffer
    this.toString = function(){
        return this.str;
    }
}

// arrays

// tell if the two arrays contain identical elements
function arraysIdentical(a,b){
    if ((a == null) != (b == null)) return false;
    if (a == null) return true;
    var i = a.length;
    if (i != b.length) return false;
    while (i--){
        if (a[i] !== b[i]) return false;
    }
    return true;
};

// deliver a string representing the specified array using the toString() for each element
function arrToStr(arr){
    var str = "[" + arr.length + ":";
    for (var i = 0; i < arr.length; i++){
        str += arr[i];
    }
    return str + "]";
}

// assign a value to a matrix cell, creating the row if it does not exist
function mSet(matr,i,j,val){
    if (matr[i] == null) matr[i] = [];
    matr[i][j] = val;
}

// lists
function LinkedList(){
    this.head = null;                // the head of the list
    this.tail = null;                // the tail of the list

    // add the specified value to the end of this list
    this.add = function(val){
        var ele = new ListElemClass();
        ele.val = val;
        if (this.head == null){            // list empty
            this.head = ele;
        } else {
            this.tail.next = ele;
        }
        ele.prev = this.tail;
        this.tail = ele;
    }

    // remove the last value from this list and deliver it
    this.pollLast = function(){
        var res = this.tail;
        this.tail = res.prev;
        res.prev = null;
        if (this.tail == null){
            this.head = null;
        } else {
            this.tail.next = null;
        }
        return res.val;
    }

    // deliver a string representing this element
    this.toString = function(){
        var str = "";
        for (var i = this.head; i != null; i = i.next){
            if (i != this.head) str += ", ";
            str += i.val;
        }
        return str;
    }

    // prepend the specified element to this list
    this.prepend = function(val){
        var ele = new ListElemClass();
        ele.val = val;
        if (this.head == null){               // list empty
            this.tail = ele;
        }
        ele.next = this.head;
        this.head = ele;
    }

    // get the first element
    this.getFirst = function(){
        if (this.head != null) return this.head.val;
        return null;
    }

    // return an iterator
    this.iterator = function(){
        return {
            "current": this.head,
            "hasNext": function(){
                return this.current != null;
            },
            "next": function(){
                var res = this.current.val;
                this.current = this.current.next;
                return res;
            }
        }
    }
}

// an element in a list
function ListElemClass(){
    this.next = null;
    this.prev = null;
    this.val = null;

    // deliver a string representing this element
    this.toString = function(){
        return this.val.toString();
    }
}

// graphs

// a graph
function Graph(){
    this.trc = {};      // trace flags

    // set the specified trace flags
    this.settrc = function(s){
        trc = {};
        if (!s) return;
        for (var i = 0; i < s.length; i++){
            trc[s.charAt(i)] = true;
        }
    }

    this.name = "";                   // name of the graph
    this.nodes = new LinkedList();    // list of nodes
    this.numOfNodes = 0;              // number of nodes
    this.edges = new LinkedList();    // list of edges
    this.numOfEdges = 0;              // number of edges
    this.kind = 0;                    // kind of graph (directed, mixed, ordered, ...)
    this.extras = null;               // extra data

    // clone this object
    this.clone = function(){
        var t = new Graph();
        for (var i in this){
            t[i] = this[i];
        }

        var nodes = [];                     // create nodes
        t.nodes = new LinkedList();
        for (var i = this.nodes.iterator(); i.hasNext();){
            var v = i.next();
            v = v.clone();
            nodes[v.index] = v;
            t.nodes.add(v);
        }
        var edges = [];                     // create edges
        t.edges = new LinkedList();
        for (var i = this.edges.iterator(); i.hasNext();){
            var e = i.next();
            e = e.clone();
            t.edges.add(e);
            e.from = nodes[e.from.index];           // remap to new nodes
            e.to = nodes[e.to.index];
            edges[e.index] = e;
        }
        for (var i = 0; i < nodes.length; i++){     // create edges lists
            var v = nodes[i];
            var list = new LinkedList();
            for (var ed in v.edgelist){
                if (ed != null){
                    ed = edges[ed.index];
                }
                list.add(el);
            }
            v.edgelist = list;
        }
        return t;
    }

    // deliver a reference to the node with the given name, creating
    // one if it does not exist
    this.newNode = function(name){
        for (var i = this.nodes.iterator(); i.hasNext();){
            var v = i.next();
            if (v.name == name){
                return i;                   // found
            }
        }

        var n = new Node();                 // not found, create one
        n.name = name;
        this.nodes.add(n);                  // append to list
        n.index = this.numOfNodes++;        // update nodes count
        return n;
    }

    // deliver a reference to the edge with the given characteristics,
    // creating one (and possibly its nodes)
    this.newEdge = function(from,to,name,directed){
        var e = new Edge();           // create new edge
        e.name = name;
        e.from = from;                // source node
        e.to = to;                    // target node
        e.directed = directed;
        if (e.from == e.to){          // to itself
            e.directed = false;
        }
        e.from.add(e);                // add to list of from node
        e.from.outDegree++;           // update out-degree of source node
        if (e.directed){              // directed
            e.to.inDegree++;          // update in-degree of target node
        } else {                      // undirected
            if (e.from != e.to){      // no self-loop
                e.to.add(e);          // add also the way back
            }
            e.to.outDegree++;
        }
        this.edges.add(e);            // append to list
        e.index = this.numOfEdges++;  // update edges count
        return e;
    }

    // deliver a string representing this graph
    this.toString = function(){
        var s = "";
        s += this.name;
        s += ':';
        var first = true;
        for (var i = this.nodes.iterator(); i.hasNext();){
            var v = i.next();
            if ((v.inDegree + v.outDegree) == 0){
                if (!first) s.append(',');
                first = false;
                s += v.toString();
                continue;
            }
            for (var j = v.edgelist.iterator(); j.hasNext();){
                var e = j.next();
                if (e != null){
                    if (!e.directed){              // undirected
                        if (e.toNode(v).index < v.index){
                            continue;              // show only one
                        }
                    }
                }
                if (!first) s.append(',');
                first = false;
                if (e == null){                    // placeholder
                    s += v.toString();
                    s += '-';
                } else {
                    s += e.toString();
                }
            }
        }
        return s;
    }

    // trace this graph. Undirected edges are reported on both endpoints.
    // Each edge has attached its unique sequence number that allows to
    // tell when it is different from another, and when it is the same.
    this.trace = function(){
        var str = "graph: " + this.name;
        if ((this.kind & Graph.DIRECTED) != 0) str += " directed";
        if ((this.kind & Graph.MIXED) != 0) str += " mixed";
        if ((this.kind & Graph.ORDERED) != 0) str += " ordered";
        if ((this.kind & Graph.WEIGHTED) != 0) str += " weighted";
        if ((this.kind & Graph.MULTIGRAPH) != 0) str += " multigraph";
        if ((this.kind & Graph.ACYCLIC) != 0) str += " acyclic";
        console.log(str);
        for (var i = this.nodes.iterator(); i.hasNext();){
            var v = i.next();
            console.log("node: " + v.toString() + " (" + v.index + ") ->" +
                v.inDegree + " " + v.outDegree + "->");
            for (var j = v.edgelist.iterator(); j.hasNext();){
                var e = j.next();
                if (e == null){
                    console.log("  -");
                } else {
                    console.log("  " + e + "(" + e.index + ")");
                }
            }
        }
        console.log("edges");
        for (var i = this.edges.iterator(); i.hasNext();){
            var e = i.next();
            console.log("  " + e);
        }
    }
}
Object.defineProperty(Graph,"DIRECTED",{value: 1 << 0});
Object.defineProperty(Graph,"MIXED",{value: 1 << 1});
Object.defineProperty(Graph,"ORDERED",{value: 1 << 2});
Object.defineProperty(Graph,"WEIGHTED",{value: 1 << 3});
Object.defineProperty(Graph,"MULTIGRAPH",{value: 1 << 4});
Object.defineProperty(Graph,"ACYCLIC",{value: 1 << 5});

// a node
function Node(){
    this.name = "";                      // name of the node
    this.index = 0;                      // index of the node
    this.edgelist = new LinkedList();    // list of edges (outgoing if directed)
    this.inDegree = 0;                   // number of incoming undirected edges
    this.outDegree = 0;                  // number of outgoing (un)directed edges
    this.extras = null;                  // extra data
    this.inedgelist = new LinkedList();  // list of incoming edges

    // deliver a string representing this node
    this.toString = function(){
        if (this.name == null) return "$" + this.index;
        return this.name;
    }

    // clone this object
    this.clone = function(){
        var n = new Node();
        for (var i in this){
            n[i] = this[i];
        }
        return n;
    }

    // deliver a string representing this node and its leaving edges
    this.symbolic = function(){
        var s = "";
        s += toString();
        for (var j = this.edgelist.iterator(); j.hasNext();){
            var e = j.next();
            s += ' ';
            if (e == null) s += "null";
            else s += e.toString();
        }
        return s;
    }

    // add an edge to the list of this node
    this.add = function(e){
        this.edgelist.add(e);
        e.to.inedgelist.add(e);
    }

    // tell if there is an edge from this node to the specified one
    this.edgeTo = function(to){
        for (var j = this.edgelist.iterator(); j.hasNext();){
            var e = j.next();
            if (e.to == to){
                return e;
            }
        }
        return null;
    }
}

// an edge
function Edge(){
    this.name = "";          // the identity of the edge. Not required to be unique
    this.index = 0;          // the index of the edge
    this.directed = false;   // whether it has a direction. The ones with the same endpoints are not directed
    this.from = null;        // the leaving (from) endpoint. When undirected, an enpoint
    this.to = null;          // the entering (to) endpoint. When undirected, the other enpoint
    this.extras = null;      // extra data

    // deliver a string representing this edge
    this.toString = function(){
        return this.from.name + '-' + this.name +
            '-' + (this.directed ? ">" : "") + this.to.name;
    }

    // clone this object
    this.clone = function(){
        var n = new Edge();
        for (var i in this){
            n[i] = this[i];
        }
        return n;
    }

    // deliver the other enpoint: for directed edges it is the
    // target one, for the undirected edges it is the other endpoint
    this.toNode = function(from){
        if (this.directed) return this.to;      // directed edge
        if (from == this.from) return this.to;  // the other one
        return this.from;                       // the opposite
    }
}

</script>
<script>


// a point
function Point(x,y,n){
    this.x = (typeof(x) == "undefined") ? 0 : x;           // coords
    this.y = (typeof(y) == "undefined") ? 0 : y;
    this.name = (typeof(n) == "undefined") ? null : n;     // name

    // deliver a string representing this object
    this.toString = function(){
        return this.name + "(" + this.x.toFixed(2) + "," + this.y.toFixed(2) + ")";
    }

    // tell if this object is the same as the specified one
    this.equals = function(other){
        return this.x == other.x && this.y == other.y;
    }
}

// point at infinity
var infPoint = new Point(Infinity,Infinity);

// no point
var noPoint = new Point(NaN,NaN);

// a straight line, defined with the parameters of the general equation,
// or with two points
function Line(a,b,c,n){
    this.a = a;     // coefficient of x
    this.b = b;     // coefficient of y
    this.c = c;     // constant
    if (a instanceof Point){     // line defined with two points
        n = c;
        //(y-y1)(x2-x1) - (x-x1)(y2-y1) = 0
        this.a = a.y - b.y;
        this.b = b.x - a.x;
        this.c = a.x*b.y - a.x*a.y - a.y*b.x + a.y*a.x;
    }
    this.name = (typeof(n) == "undefined") ? null : n;   // name

    // deliver a string representing this object
    this.toString = function(){
        return this.name + ": " + this.a + "x + " + this.b + "y + " + this.c + " = 0";
    }

    // tell if this object is the same as the specified one
    this.equals = function(other){
        return this.a == other.a && this.b == other.b && this.c == other.c;
    }

    // deliver the intersection of this line with the specified other line or axis,
    // returning also it in res, if specified
    this.intersect = function(other,res){
        var oa = 0;
        var ob = 0;
        var oc = 0;
        if (other instanceof Axis){
            var sina = Math.sin(other.a);
            var cosa = Math.cos(other.a);
            oa = sina;
            ob = -cosa;
            oc = -other.p.x * sina + other.p.y * cosa;
        } else {
            oa = other.a;
            ob = other.b;
            oc = other.c;
        }
        var det = this.a * ob - this.b * oa;
        if (det == 0){            // parallel
            if (typeof(res) == "undefined"){
                res = infPoint;
            } else {
                res.x = infPoint.x;
                res.y = infPoint.y;
            }
        } else {
            var x = -this.c * ob + this.b * oc;
            var y = -this.a * oc + this.c * oa;
            if (typeof(res) == "undefined"){
                res = new Point(x / det,y / det);
            } else {
                res.x = x / det;
                res.y = y / det;
            }
        }
        return res;
    }
}

// an oriented line, defined with a point (origin) and an angle, or between two points
function Axis(point,angle,n){
    if (angle instanceof Point){  // defined with two points
        var p2 = angle;
        var dx = p2.x - point.x;
        var dy = p2.y - point.y;
        var dist = Math.sqrt(dx*dx + dy*dy);
        if (dy >= 0){
            angle = Math.acos(dx/dist);
        } else {
            angle = -Math.acos(dx/dist);
        }
    }
    this.p = point;                  // origin
    this.a = angle % (2*Math.PI);    // normalize the angle to multiples of pi;
    this.name = (typeof(n) == "undefined") ? null : n;

    // deliver a string representing this object
    this.toString = function(){
        return this.name + ": " + this.p + ", " + this.a + " â ";
    }

    // tell if this object is the same as the specified one
    this.equals = function(other){
        return this.p.equals(other.p) && this.a == other.a;
    }

    // deliver the distance from the axis origin of the specified point of the axis
    this.distance = function(p){    
        if (Math.abs(this.angle) != Math.PI){
            return (p.x-this.p.x) / Math.cos(this.a);
        } else {
            return p.y-this.p.y;
        }
    }

    // deliver the point at the specified distance from the axis origin
    this.pointAt = function(d,res){
        var x = 0;
        var y = 0;
        if (Math.abs(this.angle) != Math.PI){
            x = this.p.x + d * Math.cos(this.a);
            y = this.p.y + d * Math.sin(this.a);
        } else {
            x = this.p.x;
            y = this.p.y + d;
        }
        if (typeof(res) == "undefined"){
            res = new Point(x,y);
        } else {
            res.x = x;
            res.y = y;
        }
        return res;
    }

    // deliver the normal passing from the specified point
    this.normal = function(p,res){
        if (typeof(res) == "undefined"){
            res = new Axis(p,this.a+Math.PI/2);
        } else {
            res.p = p;
            res.a = (this.a+Math.PI/2) % (2*Math.PI);
        }
        return res;
    }

    // deliver the intersection of this axis with the specified other line or axis,
    // returning also it in res, if specified
    this.intersect = function(other){
        var sina = Math.sin(this.a);
        var cosa = Math.cos(this.a);
        var thisa = sina;
        var thisb = -cosa;
        var thisc = -this.p.x * sina + this.p.y * cosa;
        var oa = 0;
        var ob = 0;
        var oc = 0;
        if (other instanceof Axis){
            var sina = Math.sin(other.a);
            var cosa = Math.cos(other.a);
            oa = sina;
            ob = -cosa;
            oc = -other.p.x * sina + other.p.y * cosa;
        } else {
            oa = other.a;
            ob = other.b;
            oc = other.c;
        }
        var det = thisa * ob - thisb * oa;
        if (det == 0){            // parallel
            if (typeof(res) == "undefined"){
                res = infPoint;
            } else {
                res.x = infPoint.x;
                res.y = infPoint.y;
            }
        } else {
            var x = -thisc * ob + thisb * oc;
            var y = -thisa * oc + thisc * oa;
            if (typeof(res) == "undefined"){
                res = new Point(x / det,y / det);
            } else {
                res.x = x / det;
                res.y = y / det;
            }
        }
        return res;
    }
}

// an oriented segment
function Segment(p1,p2,n){
    this.p1 = p1;           // first point
    this.p2 = p2;           // second point
    this.name = (typeof(n) == "undefined") ? null : n;

    // deliver a string representing this object
    this.toString = function(){
        return this.name + ": " + this.p1 + "->" + this.p2;
    }

    // tell if this object is the same as the specified one
    this.equals = function(other){
        return this.p1.equals(other.p1) && this.p2.equals(other.p2);
    }

    // determine the length
    this.length = function(){
        var dx = this.p2.x - this.p1.x;
        var dy = this.p2.y - this.p1.y;
        return Math.sqrt(dx*dx + dy*dy);
    }

    // determine the middle point
    this.middle = function(res){
        return this.pointAtRate(0.5,res);
    }

    // determine the point at the given rate from the first one
    this.pointAtRate = function(r,res){
        var dx = this.p2.x - this.p1.x;
        var dy = this.p2.y - this.p1.y;
        var x = this.p1.x+dx*r;
        var y = this.p1.y+dy*r;
        if (typeof(res) == "undefined"){
            res = new Point(x,y);
        } else {
            res.x = x;
            res.y = y;
        }
        return res;
    }

    // deliver the normal passing from the point at the given rate from the first one
    this.normal = function(r,res){
        var p = this.pointAtRate(r);
        var a = Math.acos((this.p2.x - this.p1.x)/this.length());
        if (typeof(res) == "undefined"){
            res = new Axis(p,a+Math.PI/2);
        } else {
            res.p = p;
            res.a = (this.a+Math.PI/2) % (2*Math.PI);
        }
        return res;
    }
}

// a circle
function Circle(c,r,n){
    this.c = c;           // center
    this.r = r;           // radius
    this.name = (typeof(n) == "undefined") ? null : n;  // name

    // deliver a string representing this object
    this.toString = function(){
        return this.name + ": " + this.c + ", " + this.r;
    }

    // tell if this object is the same as the specified one
    this.equals = function(other){
        return this.c.equals(other.c) && this.r == other.r;
    }

    // deliver the intersections of this circle with the specified other line, axis or circle,
    // returning them in res1 and res2, if specified
    this.intersect = function(other,res1,res2){
        var res = null;
        if (other instanceof Line || other instanceof Axis){
            var oa = other.a;
            var ob = other.b;
            var oc = other.c;
            if (other instanceof Axis){
                var sina = Math.sin(l2.a);
                var cosa = Math.cos(l2.a);
                oa = sina;
                ob = -cosa;
                oc = -l2.p.x*sina+l2.p.y*cosa;
            }
            if (ob != 0){
                var a2 = oa*oa;
                var b2 = ob*ob;
                var disb = -2 * b2 * this.c.x + 2 * oa * oc +
                    2 * oa * ob * this.c.y;
                var r2 = this.r*this.r;
                var dis = disb*disb - 4 * (a2 + b2) *
                    (b2*this.c.x*this.c.x + oc*oc +
                    2*oc*ob*this.c.y + b2*this.c.y*this.c.y - r2*b2);
                if (dis >= 0){
                    var sq = Math.sqrt(dis);
                    var x1 = (-disb + sq) / (2 * (a2 + b2));
                    var x2 = (-disb - sq) / (2 * (a2 + b2));
                    var y1 = (- oa * x1 - oc) / ob;
                    var y2 = (- oa * x2 - oc) / ob;
                    if (typeof(res1) == "undefined"){
                        res = [];
                        res[0] = new Point(x1,y1);
                        if (dis > 0) res[1] = new Point(x2,y2);
                    } else {
                        res1.x = x1;
                        res1.y = y1;
                        if (dis > 0){
                           res2.x = x2;
                           res2.y = y2;
                        }
                    }
                } else {
                    if (typeof(res1) == "undefined"){
                        res = [noPoint];
                    } else {
                        res1.x = noPoint.x;
                        res1.y = noPoint.y;
                    }
                }
            } else {
                var a2 = oa*oa;
                var cy2 = this.c.y*this.c.y;
                var dis = 4*a2*a2*cy2 - 4*a2*(oc*oc +
                    2*oa*this.c.x*oc + a2*this.c.x*this.c.x +
                    a2*cy2 - a2*this.r*this.r);
                if (dis >= 0){
                    var sq = Math.sqrt(dis);
                    var x1 = -oc/oa;
                    var x2 = x1;
                    var y1 = (2*a2*this.c.y + sq) / (2 *a2);
                    var y2 = (2*a2*this.c.y - sq) / (2 *a2);
                    if (typeof(res1) == "undefined"){
                        res = [];
                        res[0] = new Point(x1,y1);
                        if (dis > 0) res[1] = new Point(x2,y2);
                    } else {
                        res1.x = x1;
                        res1.y = y1;
                        if (dis > 0){
                           res2.x = x2;
                           res2.y = y2;
                        }
                    }
                } else {
                    if (typeof(res1) == "undefined"){
                        res = [noPoint];
                    } else {
                        res1.x = noPoint.x;
                        res1.y = noPoint.y;
                    }
                }
            }
        } else if (other instanceof Circle){
            // another circle
            if (this.c.x != other.c.x){
                // a != c  centers not on the same vertical
                return solvesys(this.c.x,this.c.y,this.r,other.c.x,other.c.y,other.r,res1,res2);
            } else {
                // a = c;  centers on the same vertical
                // same as above, but swap x and y
                var pi = solvesys(this.c.y,this.c.x,this.r,other.c.y,other.c.x,other.r,res1,res2);
                if (typeof(res1) == "undefined"){
                    if (pi.length > 0){
                        var x = pi[0].x;
                        pi[0].x = pi[0].y;
                        pi[0].y = x;
                    }
                    if (pi.length == 2){
                        var x = pi[1].x;
                        pi[1].x = pi[1].y;
                        pi[1].y = x;
                    }
                } else {
                    if (!isNaN(res1.x)){
                        var x = res1.x;
                        res1.x = res1.y;
                        res1.y = x;
                    }
                    if (!isNaN(res2.x)){
                        var x = res2.x;
                        res2.x = res2.y;
                        res2.y = x;
                    }
                }
                return pi;
            }
        }

        // solve the system that determines the intersections
        function solvesys(a,b,r,c,d,s,res1,res2){
            var k = (- a*a + c*c - b*b + d*d + r*r - s*s)/(-2*a+2*c);
            var h = (b-d)/(c-a);
            var A = h*h + 1;
            var B = 2*k*h - 2*a*h - 2*b;
            var C = k*k - 2*a*k + a*a + b*b - r*r;
            var det = B*B - 4*A*C;
            var res = null;
            if (det >= 0){
                var sq = Math.sqrt(det);
                var y1 = (-B + sq)/2*A;
                var y2 = (-B - sq)/2*A;
                var x1 = k + h*y1;
                var x2 = k + h*y2;
                if (det == 0){
                    if (typeof(res1) == "undefined"){
                        res = [new Point(x1,y1)];
                    } else {
                        res1.x = x1;
                        res1.y = y1;
                        res2.x = noPoint.x;
                        res2.y = noPoint.y;
                    }
                } else {
                    if (typeof(res1) == "undefined"){
                        res = [new Point(x1,y1),new Point(x2,y2)];
                    } else {
                        res1.x = x1;
                        res1.y = y1;
                        res2.x = x2;
                        res2.y = y2;
                    }
                }
            } else {
                if (typeof(res1) != "undefined"){
                    res1.x = noPoint.x;
                    res1.y = noPoint.y;
                    res2.x = noPoint.x;
                    res2.y = noPoint.y;
                }
            }
            return res;
        }
        return res;
    }
}

</script>
<script>
// graph drawing

// graph extra data
function GraphExtras(){
    this.colSize = 120;          // size of column
    this.rowSize = 100;          // size of row
    this.svg = null;             // reference to the picture
}

// node extra data
function NodeExtras(){
    this.background = "white";   // background color
    this.svgShape = null;        // shape of the node
    this.svgLabel = null;        // label on the shape
    this.svgLLabel = null;       // long label on the shape
    this.longLabel = "";         // long label
    this.r = 20;                 // radius
    this.graph = null;           // reference to the graph
    this.state = null;           // reference to the state
}

// create a new node with the specified data
function newNode(graph,name,backround,llabel){
    var ex = new NodeExtras();
    ex.background = backround;
    ex.longLabel = llabel;
    ex.graph = graph;
    var n = graph.newNode(name);
    n.extras = ex;
    return n;
}

// edge extra data
function EdgeExtras(){
    this.label = "";             // label
    this.svgPath = null;
    this.knots = [];
}

// create a new edge with the specified data
function newEdge(graph,name,label,from,to){
    var ex = new EdgeExtras();
    ex.label = label;
    var e = graph.newEdge(from,to,name,true);
    e.extras = ex;
    return e;
}

var currentElement = null;          // element being dragged
var currentX = 0;                   // current coords of pointer
var currentY = 0;

// make the element movable
function grabElement(evt){
    evt.preventDefault();           // prevent default drag-n-drop
    currentElement = evt.target;
    currentX = evt.clientX;
    currentY = evt.clientY;
    currentElement.style.cursor = "grab";

    var obj = evt.target.myGraphRef;
    if (obj instanceof Node){
        var el = obj.extras.svgLLabel;
        el.style.display = "none";
    }
}

// make the movable element firm
function releaseElement(evt) {
    evt.preventDefault();           // prevent default drag-n-drop
    if (currentElement != null){
        currentElement.style.cursor = "move";
        currentElement = null;
    }
}

// drag the movable element
function dragElement(evt){
    evt.preventDefault();           // prevent default drag-n-drop
    if (currentElement == null) return;
    var dx = evt.clientX - currentX;
    var dy = evt.clientY - currentY;
    currentX = evt.clientX;
    currentY = evt.clientY;
    var cur = currentElement.myGraphRef;
    if (cur instanceof Node){
        var el = cur.extras.svgShape;
        var oldcx = el.cx.baseVal.value;
        var oldcy = el.cy.baseVal.value;
        el.cx.baseVal.value += dx;
        el.cy.baseVal.value += dy;
        var cx = el.cx.baseVal.value;
        var cy = el.cy.baseVal.value;
        el = cur.extras.svgLabel;
        var x = el.x.baseVal.value;
        var y = el.y.baseVal.value;
        el.x.baseVal.value = x+dx;
        el.y.baseVal.value = y+dy;
        // drag all outgoing edges
        for (var i = cur.edgelist.iterator(); i.hasNext();){
            var e = i.next();
            var knots = e.extras.knots;
            knots[0] = [cx+dx,cy+dy];
            knots[4] = [e.to.extras.svgShape.cx.baseVal.value,
                e.to.extras.svgShape.cy.baseVal.value];
            makeStraightSpline(e,knots,dx,dy);
            updateSpline(e);

            el = e.extras.svgLabel;
//            var x = parseFloat(el.getAttributeNS(null,"x"));
//            var y = parseFloat(el.getAttributeNS(null,"y"));
//            el.setAttributeNS(null,"x",knots[2][0]);
//            el.setAttributeNS(null,"y",knots[2][1]-20);
middleTangent(e.extras.svgPath,parseFloat(el.getAttributeNS(null,"width")),el,document.getElementById("svgdfa"));
        }
        // drag all incoming edges
        for (var i = cur.inedgelist.iterator(); i.hasNext();){
            var e = i.next();
            if (e.to == e.from) continue;                 // autoloop, done above
            var knots = e.extras.knots;
            knots[0] = [e.from.extras.svgShape.cx.baseVal.value,
                e.from.extras.svgShape.cy.baseVal.value];
            knots[4] = [cx+dx,cy+dy];
            makeStraightSpline(e,knots,dx,dy);
            updateSpline(e);

            el = e.extras.svgLabel;
//            var x = parseFloat(el.getAttributeNS(null,"x"));
//            var y = parseFloat(el.getAttributeNS(null,"y"));
//            el.setAttributeNS(null,"x",knots[2][0]);
//            el.setAttributeNS(null,"y",knots[2][1]-20);
middleTangent(e.extras.svgPath,el.width.baseVal.value,el,document.getElementById("svgdfa"));
        }

        // drag the runner seated, if it is here
        var seated = document.getElementById("runnerSeated");
        if (seated != null && seated.style.display != "none"){    // displayed
            var seatx = seated.x.baseVal.value;
            var seaty = seated.y.baseVal.value;
            if (Math.abs(seatx-oldcx) <= cur.extras.svgShape.r.baseVal.value &&
                Math.abs(seaty-oldcy) <= cur.extras.svgShape.r.baseVal.value){   // on the node
                seated.x.baseVal.value += dx;
                seated.y.baseVal.value += dy;
            }
        }

    } else if (cur instanceof Edge){
        // update the coords of the moved knot
        var circle = currentElement;
        if (currentElement.tagName == "foreignObject"){    // dragging label
            circle = reuseKnots[1];
        }
        circle.cx.baseVal.value += dx;
        circle.cy.baseVal.value += dy;
        var n = currentElement.myGraphRefn;
        var knot = cur.extras.knots[n];
        var cx = circle.cx.baseVal.value;
        var cy = circle.cy.baseVal.value;
        knot[0] = cx;
        knot[1] = cy;

        // when moving the middle knot, move also the others on the arc between the nodes.
        if (n == 2){          // middle knot, move also the others
            var m = 0.8;

            // autoloop
            if (cur.to == cur.from){
                // rotate and translate the other points
                var cir = cur.to.extras.svgShape;
                var x0 = cir.cx.baseVal.value;
                var y0 = cir.cy.baseVal.value;
                var r = cir.r.baseVal.value;
                var p = intersectCirRad(r/2,cx,cy,x0,y0);
                var px = p[0];    // point on the line from knot to center at distance r/2
                var py = p[1];
                var lr = line2(cx,cy,x0,y0);  // line from knot to center
                var a = -lr.b;    // parameters of the normal of lr
                var b = lr.a;
                var c = -a * px - b * py;
                var x1 = 0;       // determine another point of the normal
                var y1 = 0;
                if (b == 0){
                    y1 = 0;
                    x1 = -c / a;
                } else {
                    y1 = -c / b;
                }
                var p1 = intersectCirRad(r/2,px,py,x1,y1);   // point at distance r/2 from p on the normal
                var p1x = p1[0];
                var p1y = p1[1];
                var d1x = p1x - px;    // determine the symmetrical
                var d1y = p1y - py;
                var p2x = px - d1x;
                var p2y = py - d1y;
                var k = cur.extras.knots[1];
                k[0] = p1x;
                k[1] = p1y
                var c = reuseKnots[0];           // update it because it is visible
                c.cx.baseVal.value = k[0];
                c.cy.baseVal.value = k[1];
                k = cur.extras.knots[3];
                k[0] = p2x;
                k[1] = p2y;
                c = reuseKnots[2];
                c.cx.baseVal.value = k[0];
                c.cy.baseVal.value = k[1];
            } else {
                var k = cur.extras.knots[1];
                k[0] += dx * m;
                k[1] += dy * m;
                var c = reuseKnots[0];           // update it because it is visible
                c.cx.baseVal.value += dx * m;
                c.cy.baseVal.value += dy * m;
                k = cur.extras.knots[3];
                k[0] += dx * m;
                k[1] += dy * m;
                c = reuseKnots[2];
                c.cx.baseVal.value += dx * m;
                c.cy.baseVal.value += dy * m;
            }
        }

        updateSpline(cur);
        if (n == 2){          // middle knot, move the label
            el = cur.extras.svgLabel;
//            var x = parseFloat(el.getAttributeNS(null,"x"));
//            var y = parseFloat(el.getAttributeNS(null,"y"));
//            el.setAttributeNS(null,"x",knot[0]);
//            el.setAttributeNS(null,"y",knot[1]-20);
middleTangent(cur.extras.svgPath,el.width.baseVal.value,el,document.getElementById("svgdfa"));
        }
    }
}

// determine the parameters of the line that passes from the specified two points
function line2(x1,y1,x2,y2){
    var a = y2 - y1;
    var b = x1 - x2;
    var c = - x1 * a - y1 * b;
    return {"a":a,"b":b,"c":c};
}

// update the spline of the specified edge
function updateSpline(edge){
    var nk = edge.extras.knots.length;
    // get the coordinates of the knots
    var x = [];
    var y = [];
    for (var i = 0; i < nk; i++){
        var k = edge.extras.knots[i];
        x[i] = k[0];
        y[i] = k[1];
    }
    // compute the control points p1 and p2 for x and y
    var px = computeControlPoints(x);
    var py = computeControlPoints(y);
    //
    // x,y         [0]      [1]      [2]      [3]      [4]
    // px.p1,py.p1    [0]      [1]      [2]      [3]
    // px.p2,py.p2       [0]      [1]      [2]      [3]
	
    // compute the intersection with the from node
    var r = edge.from.extras.r;
    var x1 = x[0];
    var y1 = y[0];
    var x2 = px.p1[0];
    var y2 = py.p1[0];
    var intr = intersectCirRad(r,x1,y1,x2,y2);

    // use the translated tangents and the intersections as endpoints
    var dx = x2 - x1;
    var dy = y2 - y1;
    var segments = edge.extras.svgPath.pathSegList;
    var seg = segments.getItem(0);   // moveto
    seg.x = intr[0];
    seg.y = intr[1];
    seg = segments.getItem(1);       // first curveto
    seg.x1 = intr[0]+dx;
    seg.y1 = intr[1]+dy;
    seg.x2 = px.p2[0];
    seg.y2 = py.p2[0];
    seg.x = x[1];
    seg.y = y[1];

    // compute the intersection with the to node
    r = edge.to.extras.r;
    x1 = x[nk-1];
    y1 = y[nk-1];
    x2 = px.p2[nk-2];
    y2 = py.p2[nk-2];
    intr = intersectCirRad(r,x1,y1,x2,y2);
    dx = x2 - x1;
    dy = y2 - y1;
    seg = segments.getItem(nk-1);    // last curveto
    seg.x1 = px.p1[nk-2];
    seg.y1 = py.p1[nk-2];
    seg.x2 = intr[0]+dx;
    seg.y2 = intr[1]+dy;
    seg.x = intr[0];
    seg.y = intr[1];

    // update the path
    for (var i = 1; i < nk-2; i++){
        seg = segments.getItem(i+1);
        seg.x1 = px.p1[i];
        seg.y1 = py.p1[i];
        seg.x2 = px.p2[i];
        seg.y2 = py.p2[i];
        seg.x = x[i+1];
        seg.y = y[i+1];
    }
    // showFrame(edge.extras.svgPath);
}

// compute the control points for the specified knots's coordinates
// see: http://www.particleincell.com/blog/2012/bezier-splines/
function computeControlPoints(K){
    var p1 = [];
    var p2 = [];
    var n = K.length - 1;
	
    // rhs vector
    var a = [];
    var b = [];
    var c = [];
    var r = [];
	
    // first segment
    a[0] = 0;
    b[0] = 2;
    c[0] = 1;
    r[0] = K[0] + 2*K[1];
	
    // intermediate segments
    for (var i = 1; i < n-1; i++){
        a[i] = 1;
        b[i] = 4;
        c[i] = 1;
        r[i] = 4 * K[i] + 2 * K[i+1];
    }
    // last segment
    a[n-1] = 2;
    b[n-1] = 7;
    c[n-1] = 0;
    r[n-1] = 8*K[n-1] + K[n];

    // solves Ax = b with the Thomas algorithm
    for (var i = 1; i < n; i++){
        var m = a[i] / b[i-1];
        b[i] += - m * c[i - 1];
        r[i] += - m * r[i-1];
    }
    trace('r',"computeControlPoints r",r,"b",b);
    // compute the first control points for all the knots
    p1[n-1] = r[n-1] / b[n-1];
    for (var i = n-2; i >= 0; i--){
        p1[i] = (r[i] - c[i] * p1[i+1]) / b[i];
    }
    // compute the second control points for all the knots
    for (var i = 0; i < n-1; i++){
        p2[i] = 2 * K[i+1] - p1[i+1];
    }
    p2[n-1] = 0.5 * (K[n] + p1[n-1]);
    trace('r',"computeControlPoints",K,"p1:",p1,"p2:",p2);
    return {p1:p1, p2:p2};
}

// determine the intersection between the specified line and a circumference
// centered in the first line point and having the specified radius
function intersectCirRad(r,x1,y1,x2,y2){
    var a = Math.sqrt((x2 - x1) * (x2 - x1) + (y2 - y1) * (y2 - y1));
    var y = (y2 - y1) * r / a + y1;
    var x = (x2 - x1) * r / a + x1;
    trace('r',"intersectCirRad",r,x1,y1,x2,y2,":",x,y);
    return [x,y];
}

// draw the specified graph
function drawGraph(graph){
    if ('r' in trc){
        graph.trace();
    }
    // let's start with the first node, and put it in a column, then put the ones reached
    // by it in a second column, and the ones reached by the second column in the third, etc.
    var columns = [];
    var currCol = [];
    columns[0] = currCol;
    currCol.push(graph.nodes.getFirst());
    for (;;){
        trace('r',"cycle",columns.length,"scan",currCol.length);
        var nextCol = [];
        for (var i = 0; i < currCol.length; i++){
            var n = currCol[i];
            trace('r',"currCol idx",i);
            for (var e = n.edgelist.iterator(); e.hasNext();){
                var j = e.next();
                trace('r',"edge",j.toString());
                var to = j.to;
                // if not present in any columns, including the new one, add
                var found = false;
                sea: {
                    for (var k = 0; k < columns.length; k++){
                        for (var h = 0; h < columns[k].length; h++){
                            if (columns[k][h] == to){
                                found = true;
                                break sea;
                            }
                        }
                    }
                    for (var h = 0; h < nextCol.length; h++){
                        if (nextCol[h] == to){
                            found = true;
                            break sea;
                        }
                    }
                }
                if (!found){
                    trace('r',"push",to);
                    nextCol.push(to);
                }
            }
        }
        if (nextCol.length > 0){
            columns.push(nextCol);
            currCol = nextCol;
        } else {
            break;
        }
    }
    var max = 0;
    for (var i = 0; i < columns.length; i++){
        trace('r',"col",i,columns[i].length);
        max = Math.max(max,columns[i].length);
        var col = columns[i];
        for (var j = 0; j < col.length; j++){
            trace('r',"node",col[j].toString());
        }
    }
    // now determine the size of the picture
    var width = columns.length * graph.extras.colSize;
    var height = max * graph.extras.rowSize;

    var envel = document.getElementById("dfasvg");
    envel.innerHTML = "<svg width=0 height=0 onmouseup=releaseElement(evt) " +
        "onmousemove=dragElement(evt) onmouseenter=releaseElement(evt) id=svgdfa>\n" +
        "<defs><marker id=markerArrow markerWidth=8 markerHeight=7 refx=8 refy=3 orient=auto>\n"+
        "    <path d=\"M0,0 L2,3 L0,6 L8,3 L0,0\" style=\"fill:black;\" stroke-linecap=\"round\" />\n"+
        "</marker></defs></svg>\n" +
        "<div id=overlay class=overlay></div>\n" +
        "<div id=left class=lefthandle></div>\n" +
        "<div id=bottom class=bottomhandle></div>";
    var s = document.getElementById("svgdfa");
    s.setAttributeNS(null,"width",width);
    s.setAttributeNS(null,"height",height);

    envel.style.width = width + "px";
    envel.style.height = height + "px";
    var left = document.getElementById("left");
    var bottom = document.getElementById("bottom");
    var overlay = document.getElementById("overlay");
    overlay.style.width = envel.offsetWidth + "px";
    overlay.style.height = envel.offsetHeight + "px";
    overlay.style.display = "none";
    overlay.style.top = "0px";
    left.style.top = "0px";
    left.style.left = (envel.offsetWidth - 4) + "px";
    left.style.height = (envel.offsetHeight - 4) + "px";
    left.addEventListener("mousedown",grabBorder,false);
    left.addEventListener("mouseup",releaseBorder,false);
    bottom.style.top = (envel.offsetHeight - 4) + "px";
    bottom.style.width = (envel.offsetWidth + 1) + "px";
    bottom.addEventListener("mousedown",grabBorder,false);
    bottom.addEventListener("mouseup",releaseBorder,false);

    graph.extras.svg = s;
    s.extras = graph;
    var longlabels = document.getElementById("dfasvglabels");
    longlabels.innerHTML = "";

    // build the paths for the spline frames
    svgFrames = [];
    for (var i = 0; i < 5; i++){
        var path = document.createElementNS("http://www.w3.org/2000/svg","path");
        path.setAttributeNS(null,"fill","none");
        path.setAttributeNS(null,"stroke","gray");
        path.setAttributeNS(null,"stroke-width",1);
        path.setAttributeNS(null,"d","M0,0 L0,0 L0,0 L0,0");
        svgFrames[i] = path;
        s.appendChild(path);
    }

    // now place the nodes evenly spaced in columns
    var colw = width / columns.length;
    for (var i = 0; i < columns.length; i++){
        var col = columns[i];
        var sepnr = col.length + 1;        // number of separating spaces
        var step = height / sepnr;
        for (var j = 0; j < col.length; j++){
            var c = document.createElementNS("http://www.w3.org/2000/svg","circle");
            c.setAttributeNS(null,"r",col[j].extras.r);
            c.setAttributeNS(null,"cx",i*colw + colw/2);
            var cy = step*(j+1);
            if (col.length == max){
                // fullest column, place nodes in the middle of their rows, leaving then
                // less space at the ends
                cy = (graph.extras.rowSize / 2) + graph.extras.rowSize * j;
            }
            c.setAttributeNS(null,"cy",cy);
            trace('r',"drawGraph",col[j],i*colw + colw/2,step*(j+1));
            c.setAttributeNS(null,"fill",col[j].extras.background);
            c.setAttributeNS(null,"stroke","black");
            c.setAttributeNS(null,"stroke-width","1");
            c.setAttributeNS(null,"onmousedown","grabElement(evt)");
            c.setAttributeNS(null,"onmouseenter","showState(evt)");
            c.setAttributeNS(null,"onmouseleave","hideState(evt)");
            c.setAttributeNS(null,"class","draggable");
            c.style.cursor = "move";
            c.myGraphRef = col[j];
            col[j].extras.svgShape = c;
            s.appendChild(c);

            // label
            var t = document.createElementNS("http://www.w3.org/2000/svg","foreignObject");
            var tb = document.getElementById("textBox");
            if (typeof(showpat) == "undefined"){
                tb.style.fontSize = "11pt";
                t.style.fontSize = "11pt";
            } else {                            // pat state names are long
                tb.style.fontSize = "9pt";
                t.style.fontSize = "9pt";
            }
            tb.innerHTML = col[j].name;
            var w = tb.clientWidth + 1;
            var h = tb.clientHeight + 1;
            t.setAttributeNS(null,"width",w);
            t.setAttributeNS(null,"height",h);
            t.setAttributeNS(null,"x",i*colw + colw/2 - w/2);
            t.setAttributeNS(null,"y",cy - 9);
            t.setAttributeNS(null,"class","draggable");
            t.setAttributeNS(null,"onmousedown","grabElement(evt)");
            t.setAttributeNS(null,"onmouseenter","showState(evt)");
            t.setAttributeNS(null,"onmouseleave","hideState(evt)");
            t.style.cursor = "move";
            t.textContent = col[j].name;
            t.myGraphRef = col[j];
            col[j].extras.svgLabel = t;
            s.appendChild(t);

            // long label
            t = document.createElement("DIV");
            t.className = "longlabel";
            longlabels.appendChild(t);
            col[j].extras.state.traceHtml1(t);
            col[j].extras.svgLLabel = t;
        }
    }

    // now place the edges and their labels
    var edgenr = 0;
    for (var i = graph.nodes.iterator(); i.hasNext();){
        var n = i.next();
        trace('r',"node",n);
        for (var j = n.edgelist.iterator(); j.hasNext();){
            var e = j.next();
            var knots = e.extras.knots;
            knots[0] = [e.from.extras.svgShape.cx.baseVal.value,
                e.from.extras.svgShape.cy.baseVal.value];
            knots[4] = [e.to.extras.svgShape.cx.baseVal.value,
                e.to.extras.svgShape.cy.baseVal.value];
            makeStraightSpline(e,knots);
            trace('r',"drawGraph edge",e,knots[0]," ",knots[1]," ",knots[2]," ",knots[3]," ",knots[4]);
            var path = document.createElementNS("http://www.w3.org/2000/svg","path");
            path.setAttributeNS(null,"fill","none");
            path.setAttributeNS(null,"stroke","black");
            path.setAttributeNS(null,"stroke-width",1);
            path.setAttributeNS(null,"d","M0,0 C0,0 0,0 0,0 C0,0 0,0 0,0 C0,0 0,0 0,0 C0,0 0,0 0,0");
            path.setAttributeNS(null,"marker-end","url(#markerArrow)");
            path.setAttributeNS(null,"class","edgedrag");
            path.setAttributeNS(null,"onmouseenter","showKnots2(evt)");
            path.setAttributeNS(null,"id","e"+edgenr);
            edgenr++;
            path.myGraphRef = e;
            e.extras.svgPath = path;
            s.appendChild(path);
            updateSpline(e);

            // the label, anchored to the middle knot
            t = document.createElementNS("http://www.w3.org/2000/svg","foreignObject");
            var tb = document.getElementById("textBox");
            tb.style.fontSize = "9pt";
            t.style.fontSize = "9pt";
            tb.innerHTML = e.extras.label;
            var w = tb.clientWidth + 1;
            var h = tb.clientHeight + 1;
            t.setAttributeNS(null,"width",w);
            t.setAttributeNS(null,"height",h);

            // it is set on the normal, and this is different for parallel edges and autoloops
            t.setAttribute("transform","rotate(0,0,0)");
            middleTangent(path,w,t,s);
            t.setAttributeNS(null,"class","draggable");
            t.setAttributeNS(null,"onmousedown","grabElement(evt)");
            t.setAttributeNS(null,"onmouseenter","showKnots2(evt)");
            t.innerHTML = e.extras.label;
            t.myGraphRef = e;
            t.myGraphRefn = 2;
            e.extras.svgLabel = t;
            s.appendChild(t);
        }
    }

    // create the reusable knots
    for (var i = 0; i < 3; i++){
        reuseKnots[i] = createReusableKnot(s);
    }
}

// set the intermediate ones of the specified knots so as to draw a straight spline,
// or an arc for parallel lines, or a loop (translated if dx and dy specified)
function makeStraightSpline(e,knots,dx,dy){
    var x0 = knots[0][0];
    var y0 = knots[0][1];
    var xn = knots[4][0];
    var yn = knots[4][1];
    var deltax = xn - x0;
    var deltay = yn - y0;
    if (e.to == e.from){                 // autoloop
        if (arguments.length > 2){
            knots[1] = [knots[1][0]+dx,knots[1][1]+dy];
            knots[2] = [knots[2][0]+dx,knots[2][1]+dy];
            knots[3] = [knots[3][0]+dx,knots[3][1]+dy];
        } else {
            var r = e.from.extras.r;
            var x1 = x0 + r;
            var y1 = y0 + r;
            var inter = intersectCirRad(r,x1,y1,x1+r,y1+r);
            knots[1] = [x1,y1+r*0.7];
            knots[2] = inter;
            knots[3] = [x1+r*0.7,y1];
        }
    } else if (e.to.edgeTo(e.from)){     // two edges, same nodes
        var Dx = xn - x0;
        var Dy = yn - y0;
        var distq = Dx*Dx + Dy*Dy;
        var dist = Math.sqrt(distq);
        var D = 15;
        var E = 12;
        var Dxd = Dx/dist;
        var Dyd = Dy/dist;
        if (e.from.index < e.to.index){
            knots[1] = [x0 + Dx/3 + E*Dyd,y0 + Dy/3 - E*Dxd];
            knots[2] = [x0 + Dx/2 + D*Dyd,y0 + Dy/2 - D*Dxd];
            knots[3] = [xn - Dx/3 + E*Dyd,yn - Dy/3 - E*Dxd];
        } else {
            knots[1] = [x0 + Dx/3 + E*Dyd,y0 + Dy/3 - E*Dxd];
            knots[2] = [x0 + Dx/2 + D*Dyd,y0 + Dy/2 - D*Dxd];
            knots[3] = [xn - Dx/3 + E*Dyd,yn - Dy/3 - E*Dxd];
        }
    } else {
        knots[1] = [x0 + deltax/3,y0 + deltay/3];
        knots[2] = [x0 + deltax/2,y0 + deltay/2];
        knots[3] = [xn - deltax/3,yn - deltay/3];
    }
}

function middleTangent(path,w,t,s){
    var segments = path.pathSegList;
    var n = segments.numberOfItems;
    var seg = segments.getItem(n/2);   // segment that ends at the middle point
    var x1 = seg.x2;
    var y1 = seg.y2;
    var x0 = seg.x;                    // middle point
    var y0 = seg.y;
    seg = segments.getItem((n+1)/2);   // segment that starts at the middle point
    var x2 = seg.x1;
    var y2 = seg.y1;
    // the tangent passes from these three points
    var l = new Axis(new Point(x1,y1),new Point(x2,y2));
    var norm = l.normal(new Point(x0,y0));
    var p1 = norm.pointAt(-10);
    t.setAttributeNS(null,"x",p1.x-w/2);
    t.setAttributeNS(null,"y",p1.y-7);

}
function drawAxis(x1,y1,x2,y2,svg){
console.log("-2-",x1,y1,x2,y2);
    var l = document.createElementNS("http://www.w3.org/2000/svg","line");
    l.setAttributeNS(null,"x1",x1);
    l.setAttributeNS(null,"y1",y1);
    l.setAttributeNS(null,"x2",x2);
    l.setAttributeNS(null,"y2",y2);
    l.setAttributeNS(null,"stroke","gray");
    l.setAttributeNS(null,"stroke-width","1");
    svg.appendChild(l);
}

var currentbElement = null;          // element being dragged
var currentbX = 0;                   // current coords of pointer
var currentbY = 0;

// grab the border
function grabBorder(evt){
    evt.preventDefault();            // prevent default drag-n-drop
    currentbElement = evt.target;
    currentbX = evt.clientX;
    currentbY = evt.clientY;
    currentbElement.style.cursor = "grab";
    if (currentbElement.id == "left"){
        currentbElement.style.cursor = "col-resize";
    } else if (currentbElement.id == "bottom"){
        currentbElement.cursor = "row-resize";
    }
    document.getElementById("overlay").style.display = "block";
    document.addEventListener("mousemove",dragBorder,false);
}

// release the grab on the border
function releaseBorder(evt) {
    evt.preventDefault();           // prevent default drag-n-drop
    if (currentbElement != null){
        var envel = document.getElementById("dfasvg");
        if (currentbElement.id == "left"){
            currentbElement.style.cursor = "w-resize";
            envel.style.width = overlay.offsetWidth + "px";
            document.getElementById("svgdfa").setAttributeNS(null,"width",overlay.offsetWidth);
        } else if (currentbElement.id == "bottom"){
            currentbElement.style.cursor = "s-resize";
            envel.style.height = overlay.offsetHeight + "px";
            document.getElementById("svgdfa").setAttributeNS(null,"height",overlay.offsetHeight);
        }
        currentbElement = null;
        document.getElementById("overlay").style.display = "none";
    }
    document.removeEventListener("mousemove",dragBorder,false);
}

// drag the border
function dragBorder(evt){
    evt.preventDefault();           // prevent default drag-n-drop
    if (currentbElement == null) return;
    var dx = evt.clientX - currentbX;
    var dy = evt.clientY - currentbY;
    currentbX = evt.clientX;
    currentbY = evt.clientY;
    if (currentbElement.id == "left"){
        var le = currentbElement.offsetLeft;
        currentbElement.style.left = (le+dx) + "px";
        document.getElementById("overlay").style.width = (le+dx + 3) + "px";
        document.getElementById("bottom").style.width = (le+dx + 5) + "px";
    } else if (currentbElement.id == "bottom"){
        var top = currentbElement.offsetTop;
        currentbElement.style.top = (top+dy) + "px";
        document.getElementById("overlay").style.height = (top+dy + 3) + "px";
        document.getElementById("left").style.height = (top+dy - 1) + "px";
    }
}

// display a postit containing the contents of the state
function showState(evt){
    if (currentElement != null) return;  // element grabbed
    evt.preventDefault();                // prevent default drag-n-drop
    var node = evt.target.myGraphRef;
    var el = node.extras.svgLLabel;
    el.style.display = "block";

    var s = node.extras.svgShape;
    var cx = s.cx.baseVal.value;
    var cy = s.cy.baseVal.value;

    var svg = node.extras.graph.extras.svg;
    el.style.left = svg.parentNode.offsetLeft + (cx + node.extras.r) + "px";
    el.style.top = svg.parentNode.offsetTop + (cy + node.extras.r) + "px";
}

// display the postit containing the contents of the state
function hideState(evt){
    evt.preventDefault();           // prevent default drag-n-drop
    var node = evt.target.myGraphRef;
    var el = node.extras.svgLLabel;
    el.style.display = "none";
}

var reuseKnots = [];       // array of reusable knots

// create a reusable knot
function createReusableKnot(svg){
    var k = document.createElementNS("http://www.w3.org/2000/svg","circle");
    k.setAttributeNS(null,"r",4);
    k.setAttributeNS(null,"fill","Azure");
    k.setAttributeNS(null,"stroke","black");
    k.setAttributeNS(null,"stroke-width","1");
    k.setAttributeNS(null,"onmousedown","grabElement(evt)");
    k.setAttributeNS(null,"class","draggable");
    k.setAttributeNS(null,"style","display:none;cursor:move");
    svg.appendChild(k);
    return k;
}

// show the knots
function showKnots2(evt){
    var el = evt.target;
    var edge = el.myGraphRef;
    for (var i = 0; i < 3; i++){
        var k = reuseKnots[i];
        k.myGraphRef = edge;
        k.myGraphRefn = i+1;
        k.style.display = "";
        k.setAttributeNS(null,"cx",edge.extras.knots[i+1][0]);
        k.setAttributeNS(null,"cy",edge.extras.knots[i+1][1]);
    }
    setTimeout(function(){hideKnots2();},2000);
}

// hide the knots
function hideKnots2(evt){
    for (var i = 0; i < 3; i++){
        var k = reuseKnots[i];
        k.style.display = "none";
    }
}

// show the frame of a spline
function showFrame(spi,svg){
    var spisegments = spi.pathSegList;
    var len = spisegments.numberOfItems;
    var pi;
    var c1;
    var c2;
    var pf;
    for (var i = 0; i < len; i++){
        var segment = spisegments.getItem(i);
        if (i == 0){
            pi = [segment.x,segment.y];
        } else {
            c1 = [segment.x1,segment.y1];
            c2 = [segment.x2,segment.y2];
            pf = [segment.x,segment.y];
            // draw frame
            var frsegs = svgFrames[i-1].pathSegList;
            var frseg = frsegs.getItem(0);
            frseg.x = pi[0];
            frseg.y = pi[1];
            frseg = frsegs.getItem(1);
            frseg.x = c1[0];
            frseg.y = c1[1];
            frseg = frsegs.getItem(2);
            frseg.x = c2[0];
            frseg.y = c2[1];
            frseg = frsegs.getItem(3);
            frseg.x = pf[0];
            frseg.y = pf[1];
            pi = pf;
        }
    }
}

var svgFrames = null;      // svg paths for the spline frames
</script>
<script>
// animate the matching

// at each step there is a runner that walks the graph running on the edges and staying a
// little on states, and at each step a new row in a table is drawn with the items.
// At the end of matching, an animation shows the marking from the final items backwards,
// and another the choosing of the prior tree

var lastStateTab;
function addStateItems(state){
    var tab = "<table class=rho border=\"1\" style=\"display:inline-block;vertical-align:top;\">"
    tab += "<tr><td> state: " + state.number + "</td></tr>";
    for (var i = 0; i < state.items.length; i++){
        tab += "<tr><td>" + i + ":" + bsItemToString(state.items[i]) + "</td></tr>";
    }
    tab += "</table>";
    var el = document.createElement("span");
    el.innerHTML += tab;
    document.getElementById("dfaprogress").appendChild(el);
    lastStateTab = el.firstChild;
    flashGlow(lastStateTab);
}

// draw a flashing shadow border on the specified element
function flashGlow(ele){
    ele.style.animation = "blink 0.5s linear";
    ele.style.webkitAnimation = "blink 0.5s linear";
    ele.addEventListener("animationend",function(){
        ele.style.animation = "";
        ele.style.webkitAnimation = "";},
        false);
    ele.addEventListener("webkitAnimationEnd",function(){
        ele.style.animation = "";
        ele.style.webkitAnimation = "";},
        false);
}

// draw a flashing shadow border on the specified svg element
function flashGlowSvg(ele){
    ele.style.animation = "blinksvg 0.5s linear";
    ele.style.webkitAnimation = "blinksvg 0.5s linear";
    ele.addEventListener("animationend",function(){
        ele.style.animation = "";
        ele.style.webkitAnimation = "";},
        false);
    ele.addEventListener("webkitAnimationEnd",function(){
        ele.style.animation = "";
        ele.style.webkitAnimation = "";},
        false);
}

// animation along a path, defined because Firefox has a bug in animatemotion
function animatemotion(){
    this.element = null;      // the shape to move
    this.path = null;         // the path along with the move has to occur
    this.dur = 0;             // the duration
    this.clock = null;        // the clock
    this.endfun = null;       // end function
    this.abort = false;       // request to abort animation
    this.ticks = 0;           // number of frames to play
    this.point = {"x":0,"y":0};
    this.point1 = {"x":0,"y":0};
    this.curtic = 0;          // current frame

    // initialize
    this.init = function(ele,path,dur,end){
        this.element = ele;
        this.path = path;
        this.dur = dur;
        this.endfun = end;
        this.ticks = dur / 50;    // 20 frames/sec
        this.curtic = 0;
        this.abort = false;
        clearInterval(this.clock);
        this.clock = null;
        ele.setAttribute("transform","rotate(0,0,0)");
    }

    // start the motion
    this.beginElement = function(){
        clearInterval(this.clock);
        this.clock = setInterval(this.play.bind(this),50);
        this.curtic = 0;
        this.abort = false;
        this.play();
    }

    // end the motion
    this.endElement = function(){
        clearInterval(this.clock);
        this.clock = null;
        this.abort = true;
    }

    // pause the motion
    this.pauseElement = function(){
        clearInterval(this.clock);
        this.clock = null;
        this.paused = true;
    }

    // resume the motion
    this.resumeElement = function(){
        if (this.paused){
            this.paused = false;
            this.clock = setInterval(this.play.bind(this),50);
        }
    }

    // move the element
    this.play = function(){
        this.curtic++;
        if (this.abort || this.curtic == this.ticks){
            this.endElement();
            return this.endfun.call(this);
        }
        var ratioDone = this.curtic / this.ticks;
        this.pointAt(ratioDone - 0.01,this.point);
        this.pointAt(ratioDone + 0.01,this.point1);
        var angle = Math.atan2(this.point1.y-this.point.y,this.point1.x-this.point.x)*180 / Math.PI;

        // move the shape to next point on the path 
        this.pointAt(ratioDone,this.point);
        this.element.x.baseVal.value = this.point.x-20;
        this.element.y.baseVal.value = this.point.y-20;
        this.element.transform.baseVal.getItem(0).setRotate(angle,this.point.x,this.point.y);
    }

    // compute the point at the specified percent along the path
    this.pointAt = function(perc,point){
        if (perc < 0) perc = 0;
        lined: {
            // this is for a bug in Firefox: when the points are lined up, getTotalLength
            // delivers 0: compute here instead the length
            var segments = this.path.pathSegList;
            var len = segments.numberOfItems;
            var s = segments.getItem(0);
            var x0 = s.x;
            var y0 = s.y;
            s = segments.getItem(len-1);
            var xn = s.x;
            var yn = s.y;
            for (var i = 1; i < len; i++){
                s = segments.getItem(i);
                var x = s.x1;
                var y = s.y1;
                if ((y-y0)*(xn-x0) - (x-x0)*(yn-y0) > 0.01) break lined;
                x = s.x2;
                y = s.y2;
                if ((y-y0)*(xn-x0) - (x-x0)*(yn-y0) > 0.01) break lined;
                x = s.x;
                y = s.y;
                if ((y-y0)*(xn-x0) - (x-x0)*(yn-y0) > 0.01) break lined;
            }
            len = Math.sqrt((xn-x0)*(xn-x0) + (yn-y0)*(yn-y0));
            len = len * perc;
            var a = Math.sqrt((xn - x0) * (xn - x0) + (yn - y0) * (yn - y0));
            point.x = (xn - x0) * len / a + x0;
            point.y = (yn - y0) * len / a + y0;
            return;
        }
        // the control points of the path are not lined up
        if (perc > 0){
            len = this.path.getTotalLength();
            len = len * perc;
            var p = this.path.getPointAtLength(len);
            point.x = p.x;
            point.y = p.y;
        } else {
            var segments = this.path.pathSegList;
            var s = segments.getItem(0);
            point.x = s.x;
            point.y = s.y;
        }
    };
}

// a movie player
function MovieClass(){
    this.clock = null;             // clock interval timer
    this.tick = 0;                 // period, in millisecs
    this.frame = 0;                // number of frame played
    this.extras = null;            // extra data
    this.play = null;              // play callback
    this.pause = null;             // pause callback
    this.stop = null;              // stop callback 
    this.state = 0;                // 0: created, 1: playing, 2: paused, 3: stopped, 4: ended
    this.playButton = null;        // play/pause button
    this.stopButton = null;        // stop button

    // deliver a string representing this player
    this.toString = function(){
        var str = "movie " + this.tick + " frame:" + this.frame;
        return str;
    }

    // initialize the player
    this.createMovie = function(tick,play,pause,stop,framelist){
        this.tick = tick;
        this.frame = 0;
        this.play = play;
        this.pause = pause;
        this.stop = stop;
    }

    // play the movie
    this.playMovie = function(){
        this.state = 1;
        if (this.frame == 0){      // begin movie
            // start the movie
        }
        if (this.clock == null){
            this.clock = setInterval(this.playMovie.bind(this),this.tick);
        }
        this.play.call(this);
        this.frame++;
    }

    // pause the movie
    this.pauseMovie = function(){
        if (this.state != 1) return;
        this.state = 2;
        if (this.pause != null) this.pause.call(this);
        // firing again the interval timer changes the timing because some time since the
        // previous tick has been already passed. It would be more correct to start a timer
        // for the remaining time that calls a function that starts the interval.
        // However there would be a need to take this into account when another pause/play
        // is done.
        // When the tick is small (or the timing is not much important) there it no need for this.
        clearInterval(this.clock);
        this.clock = null;
    }

    // stop the movie
    this.stopMovie = function(){
        if (this.state == 3 || this.state == 4) return;
        this.state = 3;
        if (this.stop != null) this.stop.call(this);
        clearInterval(this.clock);
        this.clock = null;
        this.frame = 0;
        if (this.playButton != null){
            this.playButton.innerHTML = "play &#x25b6;";
        }
    }

    // end the movie
    this.endMovie = function(){
        this.state = 4;
        clearInterval(this.clock);
        this.clock = null;
        this.frame = 0;
        if (this.playButton != null){
            this.playButton.innerHTML = "play &#x25b6;";
        }
    }

    // callback for the play/pause button
    function playButton(evt){
        var movie = this.myMovie;
        switch (movie.state){
        case 0: case 2: case 3: case 4:
            this.innerHTML = "pause &#x2225;";
            if (movie.state == 4){
                clearInterval(movie.clock);
                movie.frame = 0;           // replay
            }
            movie.playMovie();
            break;
        default:                           // playing
            this.innerHTML = "play &#x25b6;";
            movie.pauseMovie();
        }
    }

    // callback for the stop button
    function stopButton(evt){
        var movie = this.myMovie;
        movie.stopMovie();
        movie.playButton.innerHTML = "play &#x25b6;";
    }

    // create the buttons as children of the specified element
    this.createButtons = function(el){
        var that = this;
        this.playButton = document.createElement("BUTTON");
        this.playButton.innerHTML = "play &#x25b6;";
        this.playButton.onclick = playButton;
        this.playButton.myMovie = this;
        el.appendChild(this.playButton);
        this.stopButton = document.createElement("BUTTON");
        this.stopButton.innerHTML = "stop &#x25fc;";
        this.stopButton.onclick = stopButton;
        this.stopButton.myMovie = this;
        el.appendChild(this.stopButton);
    }    
}

function matchAnimateExtras(){
    this.frameList = null;         // list of frames in forward ordering
    this.frameBack = null;         // list of frames in backward ordering
    this.currframe = null;         // current frame
    this.svg = null;
    this.pathanimation = null;     // path animation
    this.mpath = null;             // path in it
    this.runner = null;            // the runner
    this.still = null;             // the runner still
    this.seated = null;            // the runner seated
    this.phase = 0;                // phase: 0: matching, 1 marking, 2 pruning
    this.player = null;            // reference to the player
    this.ani = null;               // animatemotion simulator

    // deliver a string representing this object
    this.toString = function(){
        return "phase " + this.phase + " frame: " + this.player.frame + " state: " + this.player.state;
    }
}

var ffAnimatemotionBug = true;   // ff bug on gettotallength not yet solved

function matchAnimate(){
    if (stateList == null){       // no match done
        return;
    }

    document.getElementById("playerbuttons").innerHTML = "";
    document.getElementById("animatephase").innerHTML = "";
    document.getElementById("dfaprogress").innerHTML = "";

    var movie = new MovieClass();
    movie.extras = new matchAnimateExtras();
    movie.extras.player = movie;
    movie.createMovie(500,myplay,mypause,mystop,new matchAnimateExtras());
    movie.createButtons(document.getElementById("playerbuttons"));
    // get the head of the forward list of pnodes
    for (var i = stateList; i != null; i = i.next){
        movie.extras.frameList = i;
    }
    movie.extras.frameBack = stateList;
    movie.extras.svg = document.getElementById("svgdfa");

    var runner = document.createElementNS("http://www.w3.org/2000/svg","image");
    movie.extras.runner = runner;
    runner.width.baseVal.value = 42;
    runner.height.baseVal.value = 19;
    runner.href.baseVal = "data:image/gif;base64," +
        "R0lGODlhewA5AMQZAP///+/v74xaKWtKGJxjEK1rCM6EAN6tSv+1EP+1AK2EEJzn/5Te/4zO73" +
        "ulxkprhGOMrTlSa5ScpXOEnDlKYxAhWmt7tbW93pylzkpanAgQOZScznuEtWtrewAAAAAAACH/" +
        "C05FVFNDQVBFMi4wAwEAAAAh/hN3d3cuZ2lmYW5pbWFkb3MuY29tACH+HUdpZkJ1aWxkZXIgMC" +
        "41IGJ5IFl2ZXMgUGlndWV0ACH5BAkFABcALAIAAwB2ADMAAAX+4CWOZGmeaKqubHtVWqxVlevS" +
        "eG7vfG/iGo8sVvPBKpHI4wGBOBwWyPKRBOJ8WONwO4PNdjWlo7Eom89oRsMhpUYoL2t2TvJ2c7" +
        "nu9/Zs+NdPUW1uTU9jDIhqf4AWDxQ6dDxEQFuUNEQ3djJXdWOLn6ANiH5sEZyRKpNDQppEXBoU" +
        "HY+RNEwQFoahuqMNEDSoKXZFrUEyHkKTHAAAAbN0eLBOutOIDr/APUNFIjMaAgoBy3Aj21kVHl" +
        "N906BqzthgJ94J8wkHFxQaLxQE5hUUTJ4WJeK1q4Gpd5EG0JtnoKGBAgUS8DPygEyZgYDaJHES" +
        "kN2Dcgh5VIi40MDCeSD+bVRownLJGy/DNDww1FGgr5A9aBxAkKAhgQEDIP5MCWYTUREVJtDMxc" +
        "7aUZw/IjBwgG8PUqgoYPxbMmFCIXYNHuTDmrXCmI9PyZJbqW6dQKdqyVF48ihtXH0XB+rdq0hN" +
        "hLFY/Um5dpdFBVssEytOjGvMAl92sfh7MIFw4RbEKuXxcAGgxcqRMzFBe1ktnslPTIUu27mR5d" +
        "KFYXiYsIDq6jpIzt6GHdJLxal/g1GKcOgj7+M/kCgpdulVDFFqXiOf7kozNAqiGuyeHvfIpObV" +
        "ISDazr175i3iGRwszz6eEAp1/TlAZLy9/R8UpEEPS/5+6QwWSCAgBhtA4N+BI2T+AAEHgnTVFQ" +
        "cZIGgfgA5ssMETHAgowQEHSGCBhNxlkAGDEIiYQRIjCniAAhJECCJsIloQhYgliDiBBAqwaOCL" +
        "hSnIAQcbMHiiCSJ28I0CHUTAI1YxAonBk0EOaUIEGRjJ4gRKLolQkxiIQCCELqIQgQDfdJCklt" +
        "hEYKYET34pYpYqUECmmQ+gSccbAhCQo4YW0OjCmAJ0MEGddvrwgJU55mhmB0MmkcQKgAoaZqF/" +
        "ZjBBBwpwKGBXfl5g4psnKLFoBxxMQGkLVDap4Y99SilCjCVOekGql5rJ6akrNGnhrhyUCGeNFn" +
        "jlqogLZripq/dBYgOVFgC5KxSdimlinWroAvmjhhJASGiyGASAgQQBVFZpsxayiqwKSqgpKJtt" +
        "ZvtjtO1VsMy8y2BQAxL3pgSghRgI+SsLan4zoJfZTgCqf0nRSy8GFEzATMPikjDiBlDG+u8Jch" +
        "7JIpsjSGDwxfdJoPDICl8gwXoAOtnvp2/+K2eiiWJbsKwIykvyzcsEQCiVC0LZaxPBBmtmnjAn" +
        "amtXjJ4roc043xxAZ7Puy+uPFD+5YdFFL7otmkw3Ta8IAWzwS4y7lt2lyTgWTWagIGvpjwQmUx" +
        "CBBB34U0EH3iap2noVRJgq0MEaK8Haa8uNa1yOKuFS2xKGAAAh+QQJBQAXACwCAAYAdgAuAAAF" +
        "/uAljmRpnmiqrmx7VVqsVZXr0nhu73xv4rJgzQerRCKPBwTicFggk+QRiPNZicHsjDbb1ZCOxm" +
        "JMLpsZDQdEGqG8qNc4CRbL2XPdW7PB5zefa2xLTWEMhod9fw8UOnI8dUBZVFx5LJRCNCUVYX0N" +
        "aJ2giGkQEVWOK0V0QlqXMhQdpY40ShAWhKC4nYgQmacoqkOqWhoeHjI0HAAAAYyyeBRMudJ8hg" +
        "69vo/HJDMaAgoBym4jQ3EVHkkTe9O4aM3YPOTbAgn0CQcXFBovFARXNBRKOPU5JEoamljv5Ayo" +
        "R8+AQwMFCiToR+SBmDEE06gRpC4XgwfxEsKTyNAAQ3oh/m1UqLUkUBs6wTQ8ICQwlIWUIi1VOI" +
        "AggUMCAwZEBIpTJaSiL9LR7KirwbWcqCIcrDMH6i8NANFNGMTuoz6rvzY1AIkU7LiVNdcNtFb2" +
        "XQUKTRi1NbsPI8G7eD9NNfsWylO6qGi1ZDm4cK09C3jNJQJwwl/AOlmlwuPhQsCLjhe3mLXmMW" +
        "SRdwA2KaX5RKYHFsh+Xj2O2IQFDtx5MRIGJOvbrWV6chDhq+lIEQrZxk387JEHxLYMk+EJjefi" +
        "t+tItoPVk1Po2OcovxMJgqHS2em2GlbBAprh4dOLSE5BrmVO6NXLp13TAkL5+C9EgCChPwcOFm" +
        "SQn3yvZMCBAxts/gAgBBmwJOCAuEUwgDcKKCDBBQEEIMIGATb4XwYRQAgZBRMK4M1DBmR4AQYK" +
        "ZgCii088KKJVbZh4ogEKHHCABDKa0GCAIc6Yk4sddJBjfx1MMMEKEWQQo5DYNAnBfwlu0N8EHS" +
        "SRggUdQrABBgxCuUOTLrpIZi0H/rdEmSCqgMEFVl6IwQM9iqmCi1AQVguXZfqQYQAHGAALcWzW" +
        "eYWTX/r3HwcMGtqCgMoEiqOjq6kYwAaU2pDBBiJg4F+jPbjIwQbLSGqAAOplyEGQVkzwpggHFM" +
        "mqpha8maGpCgwg34cyCuiiCBXAYsoJF+5oIgWzrsAgExhoqGAHJtopggUXiACAoTKXtmkCBgrg" +
        "WKECAsCCRJlHiHDmfxYAmOAS0r5BgjLwWsuBmSZwoKO3FZqY5ARUfvkqBv+xyGimA1bw5q+dxr" +
        "sMBhNoWwJ/EhwA7rcWSoDBqyMAzGe74ygcQI9LrjhvsiS4qCSWRRZ5pQQcbEUvx+OIoPApSByR" +
        "cpbkwtyCtQkdUa6YIQAAIfkECQUAFwAsAgAGAHYAMAAABf7gJY5kaZ5oqq5se1Wap2lV7aK2W+" +
        "d377O73Ww4q/iML8ojA7E4HI1o9GmBZB6RyCsX3P2+KxhxTKuVb5UHxMFYuN8MhlTqljeokMn1" +
        "wdduvWBgYmVBhIU0OkwQi3t8fSRrT1FvlHVTEI5agIEtYmZkNENChCI8JZ+im6UTknOuUnFtC3" +
        "EOVRkRppw4oWWgYzJEHRcYE0iBNhGZaxuvzbILDZjGuiddpV1EZtoVwgAAJtM9SGJ8kc3OsxC5" +
        "1GiqFxoUCgYGBwEAFEY1A8eIEZFQDeJQsvOqjYN17AJpQJCgYQJ6BAZINFBAUAQLkypNcZDn3z" +
        "kGDnAlZEfAocmT+/6+VPjHcUIfCiRgPHgCkGAUOQ80jOSk4YDDeQQKzKM4INyRICnS0KT58aDR" +
        "nWEoROkwAB4JmFBV0FDyYILXRQDnyImgM2uYClCKPTWLowKrsOfEMrCA0KyRJ/jYioswMJbfv3" +
        "6hkdVbikKeF4SPqFnEuLFjxk6gLFC3VlcFCl7rJj7rq0ghD2kiuaGcsIaaB5o3Q+1SIwKUB4gF" +
        "VYgwwQLqyqo3w/DwABpscSKUPEGdu3hSGK7v5OSCLRTmBr7LGp++63JOz50rvKGLmzr1bNlYa4" +
        "jQRp338ypgeEJFROqCg+jjHx/EPgJ0p/Lzt4XXFWxACLHpJ+ApK21AAgYiDf6oIAkZWOCgVx0I" +
        "0EEHfiyoXwYcbIABBhtsIIEEBxiggAISZGChfBlk0CEHjGQQoTwifljhicY1aIUVJUQggAAjKn" +
        "CABL/RmBsTHBRpAQoU7MjjjxPMKGRWKVqQoYYXcKBCBEnuKMEET7LVYIYiBCDCkSxEMKEeXUKV" +
        "IgRUVmmBiS5ECYGTabqQRRYdPHCmlBo6AOcNijhY5w9YTjjihx8WycGbPjDxpgUb/DloCxREeM" +
        "Cll344AY6NrnEkm5JOeuWEmGK6Zahx8pliiqK2YOYEIJY6IZ0sOOoAB6y2amcHiGKqAIUpZCGC" +
        "FsmkOCUEuOaqa5m8IvorBbRecOe0E3pKsOEGRTKB6rLBdgCrBLOicGelE5b7LbbYbsutChl8Cy" +
        "wJ4064Y4++foiBg+qum0KDHr47rJmGXkpPqZmCm6++KmRo5Kp6BozpwLJSGC3CK6ioIYeKQtjj" +
        "xgooKQC0E1O8ArJTSlnkluWmTMHKIIcs8g8MV3jnsAuGAAA7";
    movie.extras.svg.appendChild(runner);
    runner.style.display = "none";

    var still = document.createElementNS("http://www.w3.org/2000/svg","image");
    movie.extras.still = still;
    still.width.baseVal.value = 20;
    still.height.baseVal.value = 27;
    still.href.baseVal = "data:image/gif;base64," +
        "R0lGODlhsQDuAPZmAAAAABkQCAMIEAsREyEZEDEhDDshCAAALAgQKRAVIRUiKRApMRApOh4xPC" +
        "EhISkpLzMzMzo6OkcpEFIpEGYzAHs8CGY6EEExKVc6IXNCGVhCLElCOAgQSgsZTCE6QhAcZRkp" +
        "axkpdiZCSjVBSCRKVSxSYzJbaTVjc0hISl5KRl5aT0JKUlJSUmZmZnNzaHNzc3l7fYRFEIxKGZ" +
        "RKEItSEa1SEKVaHLlaGZplDbV7EJxSIbxjIal3JcVjIcVrIc5rKdZzKd57McWQHd6QHeWlLv+1" +
        "Mf23QP/KRiEphCExjyk6nCk8pTFrhDFCrTFKvUJzlEp7lEqEnGuMnE2PrVKctVqlxWOtzmO11m" +
        "u11mu93nPF5nPF73vO9Hve/4WGiJmZma2tpbC1tczMzN3f1/Dt7f///wAAAAAAAAAAAAAAAAAA" +
        "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA" +
        "AAAAAAAAAAACH5BAVGAGYALAAAAACxAO4AAAf/gGaCg4SFhoeIiYqLjI2Oj5CRkpOUlZaXmJma" +
        "m5ydnp+goaKjpKWmp6ipqqusra6vsJ4tEbQiIhAosbq7ji4oDQ0iJSVPU1RTTyQJMLzNzmYoCQ" +
        "0nT1VXWlxdXFtbXV0kD8/irigKDCdU11xcWVhYVvBWWFskLOP3pywRCyVUWdzt4gnE8u9EAnwI" +
        "RW140ICJlW3t3lm5QrHivyxMACQ81IKFx48eW2xkVM5DFGxaKqpcqWXLFA8DRg5SMeAAh5s4cy" +
        "JAsKFQiwcR7OFjocCkli5Z4K1cmYXLlRIJesoUBIDDkiZYsS7ZuhVJCA4CIgyCICDEgZjjEphs" +
        "mnTiUotb/7I8WUBgKiEHB5Ak2bsVqxMnTf42+SrA3pcDS5xw0OjMwYInWLikfMtSy5QGjO0S2j" +
        "BAQQcQoEEgUaIkq9YPB8yEYXHg74fMsVAIKGFly2TKFVtWKSFAquZCYsJ8caHiwgABAhCILp01" +
        "yYELXyJwcA3bFQEGU7RoeYd7YksrBh38TvQFhooNERIgBwAgOYgkWZUc2OAiQYi/B8S/mn1liz" +
        "ssuF3R1BVzoTXeIQ4k9wEIIeilBBIgdLCTcqQ1Id8FG3CghBNJCODKBQJEYVuAFdkWRQMEqHDg" +
        "IQQI8MFofZmWFRIfdBBCX0kgQAABILimACsEIFAFO27h1hIVJAzg2/+Kg2wgAAdJCMbVlDFaSF" +
        "qFSAgAQAeJObdKAAw8xB1u/1RhEARMGhJAXlhdWaFpbnLl5mDsIQHYB+GgAuY8JP5DoAJ5pklI" +
        "VVdZWGibSEA4mpuMMtfBln+FsAAqDjSAxW1vZZHSEw0EKuggAHwAGHNNLBFChDt10MGijc6pxE" +
        "5YIdHBKRcscCll8mzqgaefUnWfX03IigByyum1VauNBgtCaUlwcEoCVWxBphZUmDBCr4YkMN2o" +
        "ISDQHgIvHroEsq1OmcSspQwwBRcAvuUfEwPohy0hAkQqIXurHkruvlcugQQDpThQQlxFqrRFFZ" +
        "gBoIBQ81J10wIbBFAWnPxWHOz/pKQscE3BuU2hHgkvodlwIWCggICdVlas8mC8fpJAFFxwTNHB" +
        "CSwwRRdT/DiyIQLYOa7KQDfxgcihoEDCdhxbkZIHHlTRBRUH7VwIAPf93CiVx1a8FQe5iKLAFF" +
        "vInEUWJ4jgNBUeSj2oqFbHmdW4h6aMrIUciCTK0e2yNAUJTk9RmNpjtSY3aYUm8QEHqX6GRJvk" +
        "NnHuKA+IKDNFUFDBxRMCuAD4ID07kay/HAzwQAteuHABewJw2TajweocCgP/vWWFpicM8IUZYs" +
        "AQAQS3MNzrBq21HetZYuHuAgQLqKoqv0LL+8kDTEhLmbQkOACGGC044MEJURwTNbZleU64/+dg" +
        "LRlBsUCXxrUoCSg9ubS3lF7pE7M3VcX3vQrAeGBIHFAXIQQ4AHxkxLjP1S0UERgYZVIiggukAA" +
        "INiMKl2iEtgDWsNRVywmu6RogDbGhUe0nCVUbFulexjwpaEJsWSgAAAkyjNlmYmRUY0DJBteYv" +
        "S1gMgu5juJso7yYhKGCFcnS37byFC1RgD9+08455VIGGOwPAVlDzP0PghQMHSAAHBQEBbUVpTk" +
        "hAQCi+FralaCELDRDACf7hDnlwwWNLmldNsniJBNnpSkJznScY0A4zZsEDIYoLRWZ3OS1uThOy" +
        "+WJphgYKB0SPY5riDRQEObMVGuiQmYjAAUq1lQ5skf8TCpCHGWs3yRi6EQskqCImNZEAtuUwFC" +
        "XAFEUsw4AnnBEeWXgaApy3Sk1s0nHO+oQC/MEUMz1hbPDgxgkE8MleZgIBUVpCB4jGCQ/0cSXH" +
        "IIgbnzgAMOBOECsIpzhHsAJnSuIBonpV6tKmiQcck0T9iUICVCAGMKjgASI4ARSgMIV+9vMExT" +
        "OnI1AwnTCCQGiXvEQDZkeiLTwhAS74wkJKEAVr/McdZySBQB9BgAGIKlEfAFcwMbGBNebNXVQY" +
        "QAAu8AB0yOOi7mhHCWq4UZ8coFs9kuYKwrACAZQTEw2YQgyNZIUFAGAAJ6hC7FhShV3VlBERSG" +
        "dpwgiGMoAhXpn/IIE7iIoZvo3tpBZ5qO+eiggFhCAEHdjQB1AwhjKMIQLVmYQCbAlWi2SBBAI4" +
        "5jWZYoWZkrURqmKBCxpAIxeQoQxlaAEAaPqIhQ41U0xgwEnqWpEoMKCZfz3EARoQhsTe5AuILY" +
        "MXtGQJCDDBiJmiAhP8Qdkr7AZ/mVUEAFbQVjHgpbOI/QICOABbSCygCo+VnShV8h8rzIWasU3E" +
        "AGZ7WDKgAABiCO0XOtCsa00ilq0NUFKiIAJVJlcRZVlBdEULgfGWYbpL6JBcswNPplyBu7z8bi" +
        "JauQQR4BYMLTDvdKPEgZ9CQgTabK+AsrC3+Mo3Ea05F2jLEIb8Spe6CLWb/yPcKUvtVsEECT2w" +
        "bKvWARggdgwuwK1oP3CuC1jAAil4xG+TAs+kzOUCGm6ECwLAoxt9oAVlEIMLIoCCqpbhBRzoQA" +
        "aIcIQi5GACKWZECfZKmbEhybsxRoQGMsADIeBAAh/4gHhZwJ4WtnUFAKBBEYRQ5SIc4cqLiFyF" +
        "WYIFJugxyohgwQR4cIQ6H4EINEgAAl7AZfYMQAxiSEAGhoCDAEhACEQ+Qg4koAgRMJSoJIgrnA" +
        "1BASIbYQg54EGVcVCAByigywN4wQZwQGge0GACljbCmRMRgROsuURUYACMJ62IC6R6CDEAgAFo" +
        "kIMc0CAAhpZAASRAZyIIoc40oIERlv9tBCLEcRBBffU1qACxMZCB1onAALObPQEaEMHYRTCCEB" +
        "BNhCEkWtWqFoK3mc2DRIhAQAukwsLGAAZ9jBXbZtDAENg9ATsfYdl1Lnedt61qUzN7CIw+BARc" +
        "TVlqLQA6LEgACZjQW3zT4N9GwAEGML7tI/AgAHTuOBGIzewKJGIBKJSZFqqwgAAsBGTZKAG+DX" +
        "GBIfx75Mcm+BFoAAAKoDvgElB2nXGAXEJYk8UqGVukAWCSLWQDbTM3hAQszelzq5oIFsCBBYa8" +
        "bCEYIAOqVnQBWB09yLbnBA/5hxUGMOuoD6IFlf53DAzAg7Ab4cR3NsAEcJCBXYd90YpoQMqZMo" +
        "X/o0KhJRtLAJTdzgIK2NwINAi6pk997CMMIdk0qHudAa+Ioy8lCycCW1JSoni3I6IFEsBBna2c" +
        "gQzQ4PF2DzsROL0IFJxAekuBB9JSwoDFm75JGchBuMPt7+LPngKYLUTkypipd1TQ978nRAoowG" +
        "tzD+H6188BDmigARU1YsUNxULvo++IF7ygAAXQAAbWvwET8OYFjWXyUuIyfvI/4gV5rUIUjJEU" +
        "DzyCBQpkJGgEffaHCBHABEgxNjEjAo+AArZEJgNYgJLgeRvTAI0lVE32RwQogYggeGFTG1PAgI" +
        "6AcsFlV6nEgZJwgP4xD1PgX4zQABkoAgaGgosAgMjkEi64/wjWBFaacoI0KAkLlUJbEAXW1Qgk" +
        "wGS0AwFgEAY/GAkRFDZbQAUW2AgtYFIqoQVPoAAq0AK20ISPcIApkUL+R4UmsFdZUAWfRgAn4G" +
        "Ze6AgpsGSXYgUiyAgtAIf/cVcK008LIGFtqIPAtXJjyAgrwAQRcSlPAAAwyHJ9+AgiIFRi6Agr" +
        "8E4CsnYLcIYVt4iIAAFRoClWoFGNEIlDtQVQ4Q7shImMUFKacgWeyAgj8E7UIllawADPZoqJQB" +
        "tndAJ8mAhBFREmcHtMMIO0eAhmox0ncG+HEAFClQVUABlW8GbBGHgoxAUnUISKMAJCJRFbYAKS" +
        "9oyHEDlNEQWMRQgNAP9cs0Rty8CNJMEEkSGFjeABSed+c4iOimACtVEF8ZgIYYJRU2ACTxBQ8p" +
        "gIHgBDq9h5L9VmU8AEyfePg/AAVdASMqdkFVEFU2AFgaiQHShUl1N0hkACSZczFqkIB9gUlwGR" +
        "JXICs/iRg1ACTjSFiVCFK2FBKIkIIqApWMCSp3cC/+ESzhiTg7AASiOKtXdM7iCKKHBtPGkID4" +
        "CRT0CNhtAC75QUDPAFb7WB/9iK//AS1fhOLjECswAMR0kItqcpTaUIEHCNWDgASNWPX0kIR6h0" +
        "ivAA/qB0AGBLA7mWjpWNnReXuxE9HrmW0OYPWoCQiTACwPUOSqUFJOB9fmkGI7D/iVoQBTnIlr" +
        "MjD5rSl4sJDYR4hjZJCC9gAkzhAcZ4lLZ3RneFCC+gkv/xmDu5lks2NsXIESZFEFfQAC4wBpc5" +
        "CAE5NkwQmWYAAQ/YH09AAOa3Arn4lV5FYBqJjGF4BUalACRwAmJ0mSQQlxQpjHFJNgCwADBDBe" +
        "H4kSIQl1jwkIVgNpoCBYiYSx5zm4x5jWRTnFq1cgmgALnEBKW4mCuAgQ6VgyUVFyZgK11wAtv4" +
        "lY2ZQiu3mRGwnSXgNACqnoMQAQ8YQxVpBr9FLVTQBRnBoE3ym/RQCA3wVTgToH7poEjjUERTUi" +
        "kRNvXJoCGJUVDTk8mYBbKGoYWAmjEFkz75/w8lEAAyWgg4+R/S2BMswATZMAUZJqPqmJry9gJw" +
        "yQWKuKMzWoiX0gABMAAkUAIMAACaYwYNEAEnuZYXgJolkhHPaQImQAIrMALs8QHdQpUKGQEiIH" +
        "HDNYkL0KPwUAXLuAB5sQQfIAAaaZEJUAJTsBsl8HlRQAJKQxBjo5md0z8JyY0MMQX9kQUlQIh1" +
        "NZFgVaAIkBhhpJAPAC5nwQTXoE3FIH9LtRJDaB8cEp3oqC3phQAmMCIVMTl9YgUN8FGruYgOsC" +
        "0gkACWI6sCVhG16gTThI4t8EtK8AELxXy/+nnUdiOpgY4NcB+k8QEBmULL6i5QAE0fAIx9qACL" +
        "M63V6v+rApYFJtABe1qV0zEuH+Bo1nqtV8hyB3AAxRmM4aOnySqu8LQF5lmkz6gCAGAnu0oFyv" +
        "qrbbFyEBOTLNAzOTJJpapdMbSM2VECffqP2uKqZ2RRMAVT7SCRJ2ACKJSefpmd/TEFUdA9VWAN" +
        "g2QFEgkFZdMAT7AxMOmXDvCqWPAEJ3CzZEqmJSACTNMAJCBBpOlXt5kATwAR+mezZGoQX9Mf2z" +
        "EPUcCvXwktKaEp2LAO/3mEKaR79yOjENCWApFMTECCFDE2DTCxazkApwVWQ7iLs3QCbHqUvCpL" +
        "1NIAUNAOlgG1twk7mJIU04BMGOOkgkAAAxNcWiACWrUFvwi49PL/BP5RkpaiBX+ruIIwAAKbml" +
        "PwACQADpIrfRM6NrwHADq6uQCEcvBQqALwdaI7NQTgaQQwARJgATKQuoPgAjIwAzEQAzcABCcW" +
        "A7I7CDLwA8D7A0AwAa3Xu4KAATvgA8r7AxJwu8ZrBhhwA8rrAzvQvBnwvBMgvcp7A82LAc8bvd" +
        "T7AzYgATLgvcarAdr7AzowATNgvr2rATWwvDFgATrgvrKbAjqgvECQARZQA10KuCqQvzswvNn7" +
        "v06Kv/r7ujfQdrKrAjIwvc27wM/rAjHQAz+wAxMgAxJsvBRswTYwATqwwb1LwTugvhNgA/47wT" +
        "EwwDIgATYwA4opuyQMBDEg/wE7MAPPawYznAE2rAM53MG6OwE+gMMqrLwnNsQ/HAMXvHVDHMOp" +
        "S8EXTLxNrMJRrMQwTMUfrAM/cMUcrMRZvMVOLLoUDAQ64MJAwMUjHANkbMNnHMabO8YtbANtrM" +
        "I0XAA6MMddvL8EcMdEzMG/awEBIANAkMJ+/AMWAABqLMKy2wK/OwGIDASKnLopYAM9gAELkAE/" +
        "EMmiO8k3oAErUMGavLmc7MkY0AM3YMA7Osk1kAJSgL6hLLmqzMqubL+SjMIp8AXwuwO0LLrIC8" +
        "NhoAI1cAO7vLmlPAMhBszC/L09cMUuMAPJfL49UAEi0cHXe743UAHMQME3UM29awHX7P8FZgAD" +
        "GbDNz+vN2GwGXkABPcC7xmvO8JfOPRC77XzN76zO8ty7GRDN8PcF6tzHslvBFQB/YODNPmy8+R" +
        "zQqhG9q2zQ+iwI8EvI/9zQZpACNVADGtC7jCzRKeDMF624KHABGvBADqDFFZClZsDRiksAFFDR" +
        "N0ABAXDH5ywIM9ADFgC4F1ABQPADPhAEOlAAcizNgrDRQEABgKvOFyy8PDzAMeAAKsACBVADg5" +
        "xwwUgcKRDSKTCvhyABNxAEOa2+BYDJPyADBlABBkAByfsDFcCti9ACKdDWoZlZLXABxFsBFVAD" +
        "M0DXBRAAExADGYABz/YAAJABNqADOpABw5a8PiD/A0LsAzYwvUNsARoQ2ZI92aMDAy7A1lu4Ah" +
        "KQARVw1xUwAQwM1wVAAc4svEBw2kEQBC39u6Y8AxOw1xaAfrJdAAQAbBNQwiVcxjYQBMBLvTtw" +
        "w509AxU93BVNARksAzJg1xKQvafd3Nc8Af74VA9gADUQvNOrA/MLuzaA3MitA4qtd2XdehnA1+" +
        "Odvzod1gQgARTQ2Yi93d6dAcjdejKgA9vd3XJ8xjPw2yW8vEAQzWNHVg5AAcJLvT6gvsL22hKQ" +
        "4AFQACdmARMAbDFgAxJO2Ml72qZ8AzNgARIgYSmw2cEMvDZA3lsHyK97Yq673Cee4Blg3vpbAw" +
        "XQqIDjADh9/8H7DcgFsMLKuwM64OAy8NuEHcLBe9o+YNczkAGg7cZmENcZfAOm3dw7gNw28Nvj" +
        "+9U/rtjoJwFafMH9bQAwvjMoYAA5/dtAUL0BkAE+kNP8DQTbXcLC+9u9XQMV0NcXgOSHsAEXQN" +
        "r7rb9dfcEr3NxOLgN5bQEDPMA9YABvLTVPHQRiTuZ3TOP6veiPftrPrQEoAH+T0AIbIAEVwOaO" +
        "rt+dLuZA4AOG7dNjDsmhu0qNF+qDjn47EAS+/ej6Pb3Ae81cvgkooN41YMHA+9uvDuslPOYSEA" +
        "By3OoVgMrYcgEzoOinHexy3OuP7tg+cM0v/gksINe4y+bQ7usD7APMPv/rBtBLElADyp4Bgazq" +
        "2p7jPQDnEhDdnxABox0Dwn0DPaDt+p3TwibHPTABvVQAFZDaMlDm5u7rZ14BFEABEtDlnWDnGJ" +
        "ABFGAANvDp9e4DwwbJUn1IBmAAN7AD6X3a9A68FRAAEIDV+RDgYa7tPH3jFRDaajN9GiDbg67t" +
        "OU0BKv8h/e7svK67AJB+q2Q3ihUDrg7zhW62rBAANW/yM+AAzCBQWg3xO10DBsDuukD0HA/rP2" +
        "DRG9UCOO3rp10BBSDysaDSP/DzsX4DNS1QGjADY+7pqk0Baq0LEIDxXB3rPkDUAoUBFXDmwhsE" +
        "0fz0I8ECRN8DQODqP9ADFd9LKTAq1vIO5wbQ9s9wAWMN1fk+85h08Rjg4Bfg9QiR6QUPAEkmUM" +
        "auGZguDoEAADs=";
    movie.extras.svg.appendChild(still);
    still.style.display = "none";

    var seated = document.createElementNS("http://www.w3.org/2000/svg","image");
    movie.extras.seated = seated;
    seated.id = "runnerSeated";
    seated.width.baseVal.value = 40;
    seated.height.baseVal.value = 31;
    seated.href.baseVal = "data:image/gif;base64," +
        "R0lGODlhKAAfAPf/AB8fUBgWaisrdiIheTU1e15YZkdHdk1bfbJhHrtnH75sI89tHcRtI8JwLN" +
        "Z2KMt7NdB9Nt1/MOF+JrF1Rrd6QZSFEr+vJte6AefSAuvRAOjRD9TINLqBUbeFXryKXaWlVLyL" +
        "Y7OPbLeRbr+VarORdrWVfL6dfsOBRsWESsqJV8SOXMCRZsGSb8iZa9OXY9Geb8KYcsqcccCbes" +
        "ifesyheuLRTCIhiDU1jSUnlSotlCUimSYonikrnzY3mCkloycroC0xqjU2pD1AhTdAkUtOiVhY" +
        "mmFfjWVkh2NjlGhnkGZokGxulHR0k396llNjpV14o2lop31+pXl3sm+DkWuEmnyOnXyUo3+ZsH" +
        "egu3+jyX+oyYaLiJyZi5CZm7OZiYGTpIiXpYebpoiap4ufr4SfsoyfsZukrYais4umtoulvI6q" +
        "vJSksZSos5Wsu6GirKmnrqaorainu7Gut6eyubK7v8aihMqmhc2ohcWkisqmiM2qi9iqgdGriN" +
        "GukNuzkti3mN27ndC5otm6oNK9rdm/qM+/tMbAp9TCr93Dr9vUp8bBssXJutHNstnFudvKu+HD" +
        "pObMsJ6exYGqxICszIuvzIexzo2yzJewxJWyyJq3ypy4yY210o693Je50Zq70pa/3KurwaG2xa" +
        "S6xqy6xaa7zLi8w66v1KO+0I+/45a64pDC25zC3azAy73Bw7PCy7rGzaLB1K7C0KHH3qjH37bK" +
        "2bnN2pTB4prE4pXG6JvL65fP8ZvO85vS9pzU+6nL5rfK4bvS4KPV9aHV+6Tb/qjd/6ri/rHm/8" +
        "HBwsXLzsjNz9XMxdzNwNLSyt7ZzsXF1MXN08vN0dDP1MTR1cTU287Y3NTU09rX1tHV2tTY2Nvb" +
        "2uXUxOrZx+HWyerayebc1OHf3dvh3eXi1uHg3uvk3e3q3vDn3MHV4szX4M3Z4cza6NLb4Nja4N" +
        "HV7Nfj4t7i4+Ph4Onn5evr7PLr4/Du7PLx6+vu8fHv8+zw8vT08/j39Pb49v379fL1+/f7/f39" +
        "/QAAACH5BAUAAP8ALAAAAAAoAB8AAAj/AP8JHEiwoMGD/46xOXUPocOC+B7+u6bpVq9MESU6dE" +
        "OgSKmD82LZGtZLDTaNDkHl4PHDRpyC2TDxImZrDjyUCNcJuBEkCJAh4gZWSzNsmKdkOB0yOVIE" +
        "SE8cSAR+I0MsWJs5x5IihIasR5AcQXZA+UcPzLBbVcacQaYVoTOwBMKa+jcH1acqliZ9bHvwWo" +
        "4ecnr0sEfP0rBcuXSJ4uuQyI1/RaT4A3erKLFO1RgjjPYyypJ4+GQVzfVFmuaHTAy88ZduFzFM" +
        "aKjNmXf6YJFI8RYZWjWsTCYzi2sbbFKASwULdHZtWnNllPCC4TRkuIAhkb1Ow8hw0vScILkaGz" +
        "4w//Ln7xmuYLxW0etO8FeqfuT1wRomzBd7guZIkSevLtewULTd9880ruznTz6z7DIFUgJK84qB" +
        "/tSCCyXuGDRPIfEQ9M0hOLkiDYTT9OLLegTdo0ICJAzEjwcLjJDRQ6OcAyEtuoiRFUF6ONAAJA" +
        "TdEQEDemh0CToGunMLFlZUSNALDLBQUD0cSLCCROJwAsw+5DGTxiqsZFjQHwpwY5AyCHjx0DFU" +
        "FJOLEkkYAcABXbxz0DIoIDTBIA/BoUUxwQyhQwADsIPPiwSNAwNCIGzjED90VEKMMU74MAASzR" +
        "BK0DsiIOoIPoTRI0853BBCAwVhcCKJKlkI8cQWCpywggx83FCRRx00tIDCA4H00YEyzOyxBx4Q" +
        "PMCBByCEQEIJJJhghx+KSPNMK9iA0w4z2nTTzTbbaKNNI4gIAogfMaTgAjnWxKDCDI8s4408lg" +
        "rorkMBAQA7";
    movie.extras.svg.appendChild(seated);
    seated.style.display = "none";

    if (!ffAnimatemotionBug){
        // to be used when Firefox has the bug fixed
        var animate = document.createElementNS("http://www.w3.org/2000/svg","animateMotion");
        animate.setAttribute("begin","indefinite");
        animate.setAttribute("dur","1s");
        animate.setAttribute("fill","freeze");
        animate.setAttribute("rotate","auto");
        animate.myMovie = movie;
        animate.addEventListener('endEvent',pathAnimationEnd,false);
        movie.extras.pathanimation = animate;
        movie.extras.mpath = document.createElementNS("http://www.w3.org/2000/svg","mpath");
        animate.appendChild(movie.extras.mpath);
        // attach it to the runner
        runner.appendChild(animate);
    } else {
        movie.extras.ani = new animatemotion();
        movie.extras.ani.init(runner,null,1000,pathAnimationEnd);
        movie.extras.ani.myMovie = movie;
    }

    // connect the pnodes in forward ordering
    var list = new LinkedList();
    for (var i = stateList; i != null; i = i.next){
        list.prepend(i);
        if (list.head.next != null) i.suc = list.head.next.val;        // set the forward pointers
    }
}

// terminate the animation of the runner along an edge, and dispay the next state
function pathAnimationEnd(){
    // hide the runner, display the still
    this.myMovie.extras.runner.style.display = "none";
    if (this.myMovie.extras.currframe.suc == null){
        return;
    }
    var to = this.myMovie.extras.currframe.to.node.extras.svgShape;
    var cx = to.cx.baseVal.value;
    var cy = to.cy.baseVal.value;
    if (this.myMovie.extras.currframe.suc.suc == null){ // last one
        var seated = this.myMovie.extras.seated;
        seated.style.display = "";
        seated.x.baseVal.value = cx-20;
        seated.y.baseVal.value = cy-18;
    } else {
        var still = this.myMovie.extras.still;
        still.style.display = "";
        still.x.baseVal.value = cx-10;
        still.y.baseVal.value = cy-15;
    }
    flashGlowSvg(to);
    addStateItems(this.myMovie.extras.currframe.suc.from);
    this.myMovie.extras.currframe.suc.elem = lastStateTab;
}
    
// make the next frame in the movie
function myplay(){
    var svg = this.extras.svg;
    if (!ffAnimatemotionBug){
        if (svg.animationsPaused()){
            svg.unpauseAnimations();
            return;
        }
    } else {
        if (this.extras.ani.paused){
            this.extras.ani.resumeElement();
        }
    }

    //twriteln("myplay",this.extras);
    if (this.frame == 0){      // begin movie
        document.getElementById("dfaprogress").innerHTML = "<p>States encountered:<p>";
        document.getElementById("animatephase").textContent = "matching";
        var firstnode = this.extras.frameList.from.node.extras.svgShape;
        var cx = firstnode.cx.baseVal.value;
        var cy = firstnode.cy.baseVal.value;
        if (this.extras.frameList.suc == null){    // first and also last one
            this.extras.seated.style.display = "";
            this.extras.x.baseVal.value = cx-20;
            this.extras.y.baseVal.value = cy-18;
        } else {
            this.extras.still.style.display = "";
            this.extras.still.x.baseVal.value = cx-10;
            this.extras.still.y.baseVal.value = cy-15;
        }
        flashGlowSvg(firstnode);
        addStateItems(this.extras.frameList.from);
        this.extras.frameList.elem = lastStateTab;
        this.extras.currframe = null;
        return;
    }
    mat: if (this.extras.phase == 0){
        if ((this.frame-1) % 3 == 0){        // one every two
            if (this.extras.currframe == null){
                this.extras.currframe = this.extras.frameList;
            } else {
                this.extras.currframe = this.extras.currframe.suc;
            }
            if (this.extras.currframe.suc == null){   // end of matching
                if (BS_AUGM){
                    this.extras.phase = 1;
                } else {
                    this.endMovie();
                    document.getElementById("animatephase").textContent = "";
                    this.extras.phase = 0;
                }
                this.extras.currframe = null;
                break mat;
            }
            this.extras.still.style.display = "none";
            this.extras.seated.style.display = "none";
            this.extras.runner.style.display = "";
            // get the path of the edge
            var from = this.extras.currframe.from.node;
            var to = this.extras.currframe.to.node;
            var edge = from.edgeTo(to);
            if (!ffAnimatemotionBug){
                this.extras.mpath.setAttributeNS("http://www.w3.org/1999/xlink","href",
                    "#" + edge.extras.svgPath.getAttributeNS(null,"id"));
                this.extras.pathanimation.beginElement();
            } else {
                this.extras.ani.path = edge.extras.svgPath;
                this.extras.ani.beginElement();
            }
        }
    }
    mar: if (this.extras.phase == 1){                      // marking
        if (this.extras.currframe == null){
            this.extras.currframe = this.extras.frameBack;
            document.getElementById("animatephase").textContent = "marking";
        } else {
            this.extras.currframe = this.extras.currframe.next;
            if (this.extras.currframe == null){         // end of marking
                this.extras.phase = 2;
                break mar;
            }
        }
        var currpnode = this.extras.currframe;
        for (var i = 0; i < currpnode.from.items.length; i++){
            if (currpnode.iidNodes[i] == null) continue;
            flashGlow(currpnode.elem.rows[i+1].cells[0]);
            currpnode.elem.rows[i+1].style.backgroundColor = "Aqua";
        }
    }
    pru: if (this.extras.phase == 2){                      // pruning
        if (this.extras.currframe == null){
            // if there is no pruning, skip this phase
            var currpnode = this.extras.frameBack;
            var pruned = false;
            var iid = currpnode.activeIids[0];
            for (var t = currpnode; t != null; t = t.next){    // take the first path of iid's
                if (t.from.items[iid].left.size() > 1){
                    pruned = true;
                    break;
                }
                t.iid = iid;
                if (t.next != null) iid = t.next.activeIids[iid];
            }
            if (!pruned){
                this.endMovie();
                document.getElementById("animatephase").textContent = "";
                this.extras.phase = 0;
                break pru;
            } else {
                this.extras.currframe = this.extras.frameList;
                document.getElementById("animatephase").textContent = "pruning";
            }
        } else {
            this.extras.currframe = this.extras.currframe.suc;
            if (this.extras.currframe == null){   // end of matching
                this.endMovie();
                document.getElementById("animatephase").textContent = "";
                this.extras.phase = 0;
                break pru;
            }
        }
        // spot the pruned items
        var currpnode = this.extras.currframe;
        for (var i = 0; i < currpnode.from.items.length; i++){
            if (currpnode.iidNodes[i] == null) continue;
            if (i != currpnode.iid){
                flashGlow(currpnode.elem.rows[i+1].cells[0]);
                var style = currpnode.elem.rows[i+1].style;
                style.backgroundColor = "Beige";
                style.transitionProperty = "background-color";
                style.transitionDuration = "0.5s";
            }
        }
    }
}

// pause the movie
function mypause(){
    if (!ffAnimatemotionBug){
        var svg = this.extras.svg;
        if (!svg.animationsPaused()){
            svg.pauseAnimations();
        }
    } else {
        this.extras.ani.pauseElement();
    }
}

// stop the movie
function mystop(){
    if (!ffAnimatemotionBug){
        this.extras.pathanimation.endElement();
    } else {
        this.extras.ani.endElement();
    }
    document.getElementById("animatephase").textContent = "";
    document.getElementById("dfaprogress").innerHTML += "stopped";
}

</script>
<script>
// ---------- Items in B&S -----------------

// symbol part in B&S augmented DFA's: it is made of a sequence of integers, that
// behaves much the same as a string. Each element represents the entering or leaving of
// a node in a path thru the AST. The elements are indexes of AST nodes with flags attached
// tellig the entering or leaving (see below).
function BSsymbol(){
    // this is an array of indexes of ast nodes
    this.arr = null;

    // deliver a Html string representing this symbol
    this.toString = function(){
        var str = "";
        for (var i = 0; i < this.arr.length; i++){
            str += BSeleToString(this.arr[i]);
        }
        return str;
    }

    // deliver a plain string representing this symbol
    this.toNoHtmlString = function(){
        var str = "";
        if (this.arr != null){
            for (var i = 0; i < this.arr.length; i++){
                str += BSeleToString(this.arr[i],true);
            }
        }
        return str;
    }

    // tell if this symbol is equal to the specified one
    this.equals = function(other){
        return arraysIdentical(this.arr,other.arr);
    }

    // compare this symbol with the specified one
    // this is good only for sorting because it sorts elements on their encodings
    this.compareTo = function(other){
        var n = this.arr.length;
        if (other.arr.length < n) n = other.arr.length;
        var i = 0;
        var j = 0;
        while (n-- != 0){
            var c1 = this.arr[i++];
            var c2 = other.arr[j++];
            if (c1 != c2) return c1 - c2;
        }
        return this.arr.length - other.arr.length;
    }

    // deliver a new symbol taking the specified substring of this one
    this.substring = function(begin, end){
        var sym = new BSsymbol();
        sym.arr = this.arr.slice(begin,end);
        return sym;
    }

    // deliver the length of this symbol
    this.length = function(){
        return this.arr.length;
    }

    // deliver the element at the specified index
    this.eleAt = function(i){
        if (i < 0) return this.arr[this.arr.length+i];
        return this.arr[i];
    }

    // deliver a trimmed object if the last element is not an open or a close
    this.getTag = function(){
        var ele = this.arr[this.arr.length-1];
        var kind = BSeleKind(ele);
        if (kind != ELEOPEN && kind != ELECLOSE){
            return this.substring(0,-1);
        }
        return this;
    }

    // deliver a trimmed object if the first or last element is not an open or a close
    this.tag = function(){
        var start = 0;
        var end = this.arr.length;
        var trim = false;
        var ele = this.arr[this.arr.length-1];
        var kind = BSeleKind(ele);
        if (kind != ELEOPEN && kind != ELECLOSE){
            end = -1;
            trim = true;
        }
        ele = this.arr[0];
        var kind = BSeleKind(ele);
        if (kind != ELEOPEN && kind != ELECLOSE){
            start = 1;
            trim = true;
        }
        if (trim){
            return this.substring(start,end);
        }
        return this;
    }

    // append the elements of the specified symbol to this one
    this.concat = function(other){
        if (this.arr == null) this.arr = [];
        this.arr = this.arr.concat(other.arr);
    }

    // tell if this symbol starts with the specified one
    this.startsWith = function(other){
        if (other.arr.length > this.arr.length) return false;
        var i = other.arr.length;
        while (i--){
            if (this.arr[i] !== other.arr[i]) return false;
        }
        return true;
    }

    // tell if this symbol ends with the specified one
    this.endsWith = function(other){
        if (other.arr.length > this.arr.length) return false;
        var i = other.arr.length;
        var l = this.arr.length;
        while (i--){
            if (this.arr[--l] !== other.arr[i]) return false;
        }
        return true;
    }
}

var ELEKIND = 1000000;            // field for the kind
var ELEOPEN = 1;                  // entering
var ELECLOSE = 2;                 // leaving

// deliver a string representing the direction of the path (entering, leaving, passing)
function BSeleKindToString(kind){
    return ["leaf","open","close"][kind];
}

// deliver the reference to the AST node of the specified element
function BSeleToAst(ele){
    return astMap.get(ele % ELEKIND);
}

// deliver the position of the specified element
function BSeleToPos(ele){
    return astMap.get(ele % ELEKIND).pos;
}

// deliver the number of the AST node of the specified element
function BSeleToAstNum(ele){
    return ele % ELEKIND;
}

// deliver the kind of the specified element (direction of the path)
function BSeleKind(ele){
    return Math.floor(ele / ELEKIND);
}

// deliver the element corresponding to the specified ast and direction
function astToBSele(ast,kind){
    return ast.seq + kind*ELEKIND;
}

// tell if the specified element is a terminal (not epsilon)
function isBSeleTerminal(ele){
    if (Math.floor(ele / ELEKIND) == 0){
        if (astMap.get(ele % ELEKIND).kind == 0) return true;
    }
    return false;
}

// check that the ele is an open or close parenthesis of a *|+ group
function isEleRep(ele,kind){
    var res = null;
    doit: {
        var k = BSeleKind(ele);
        if (k != kind) break doit;
        var ast = BSeleToAst(ele);
        if (ast.kind == 3 && (ast.groupKind == G_RE0 || ast.groupKind == G_RE1)){
            res = ast.pos;
        }
    } // doit
    // trace('n',"isEleRep",BSeleToString(ele,true),posToString(res));
    return res;
}

// check that the specified element is an open or closed parenthesis of a *|+ group
// which is enclosed in another a *|+ group
function isRep(ele,kind){
    // trace('n',"isRep start",BSeleToString(ele,true),kind);
    var res = null;
    doit: {
        var k = BSeleKind(ele);
        if (k != kind) break doit;
        res = isEleRep(ele,kind);
        if (res != null) break doit;
        var ast = BSeleToAst(ele);
        if (ast.pos.length == 0) break doit;
        var pos = ast.pos.slice(0,-1);
        // visit all the ast and find the father of ele (the one that has one level less in its pos)
        for (var i = 0; i < astMap.arr.length; i++){
            var a = astMap.arr[i][1];
            if (arraysIdentical(a.pos,pos)){
                if (a.kind == 3 && (a.groupKind == G_RE0 || a.groupKind == G_RE1)){
                    res = a.pos;
                    break doit;
                }
            }
        }
    } // doit
    // trace('n',"isRep",BSeleToString(ele,true),posToString(res));
    return res;
}

// deliver a string representing the specified element
function BSeleToString(ele,nohtml){
    var str = "";
    var eleKind = BSeleKind(ele);
    var ast = BSeleToAst(ele);

if (!levelNumbering){
    if (astSenMap.get(ast.pos) == null){
        return "";
    }
    if (eleKind == ELEOPEN || eleKind == ELECLOSE){
        if (ast.kind == 0){                // terminal
            return "";
        }
    }
}

    if (eleKind == ELEOPEN){               // node entry
        str += "("
    } else if (eleKind == ELECLOSE){       // node exit
        str += ")"
    } else {
        if (ast.kind == 0){                // terminal
            str += ast.sym;
        } else if (ast.kind == 1){
            str += "|";
        } else if (ast.kind == 2){
            str += "\u00b7";
        } else if (ast.kind == 4){
            str += nohtml ? "\u03b5" : "&epsilon;";
} else if (ast.kind == 5){
            str += nohtml ? "\u03a6" : "&Phi;";
        } else {
            str += nohtml ? "\u03b5" : "&epsilon;";   // a group without open or close flags acts as empty
        }
    }
    if (nohtml){
        str += posToString(ast.pos);
    } else {
        str += posToSub(ast.pos);
    }
    return str;
}

// deliver a new symbol
function newBSsymbol(){
    var sym = new BSsymbol();
    sym.arr = [];
    for (var i = 0; i < arguments.length; i++){
        var arg = arguments[i];
        if (arg instanceof BSsymbol){
            sym.arr = sym.arr.concat(arg.arr);
        } else {
            sym.arr[sym.arr.length] = arg;
        }
    }
    return sym;
}

// ---------- AST's -----------------

var G_GRO = 0;    // ()
var G_OPT = 1;    // []
var G_RE0 = 2;    // ()*
var G_RE1 = 3;    // ()+
var G_BOD = 4;    // group body

// deliver a string representing the specified kind
function aKindToString(kind){
    return ["term","alt","conc","group","empty","void"][kind];
}

// deliver a string representing the kind of the specified ast
function astKindToString(ast){
    var str = aKindToString(ast.kind);
    if (ast.kind == 3){
        str += groupIcon[ast.groupKind];
    }
    return str;
}

var GR_OPEN = "(";
var GR_CLOSE = ")";

// AST nodes
function AstNode(){
    this.seq = 0;              // serial number
    this.bro = null;           // brother
    this.son = null;           // son
    this.fat = null;           // father
    this.kind = 0;             // 0: leaf, 1: alt, 2: conc, 3: group, 4: empty, 5: void (empty set)
    this.sym = 0;              // kind = 0: symbol
    this.groupKind = 0;        // kind of group (if group)
    this.pos = [];             // sequence of indexes of level numbering
    this.cursor = 0;           // index in the input
    this.isNull = false;       // B&S attributes
    this.ini = new SetClass();
    this.fin = new SetClass();
    this.dig = new SetClass();
    this.altnr = 0;            // number of alternative (when this node is an alternative)

    // deliver a string representing this node
    this.toString = function(){
        var str = "ast seq: " + this.seq;
        str += " pos:";
        str += posToString(this.pos);
        str += " ";
        if (this.altnr != 0) str += "|" + this.altnr + " ";
        if (this.kind == 0){
            str += "leaf ";
            str += this.sym;
        } else if (this.kind == 1){
            str += "alt ";
        } else if (this.kind == 2){
            str += "conc ";
        } else if (this.kind == 4){
            str += "\u03b5";
} else if (this.kind == 5){
            str += "\u03a6";
        } else {
            str += " ";
            str += groupKind[this.groupKind];
        }
        str += " at: ";
        str += this.cursor;
        if (this.bro != null){
            str += " bro: ";
            str += this.bro.seq;
        }
        if (this.son != null){
            str += " son: ";
            str += this.son.seq;
        }
        if (this.fat != null){
            str += " fat: ";
            str += this.fat.seq;
        }
        str += " Null: " + this.isNull;
        str += " Ini: ";
        str += bsSetToString(this.ini,true);
        str += " Fin: ";
        str += bsSetToString(this.fin,true);
        str += " Dig: ";
        str += bsSetToString(this.dig,true);
        return str;
    }

    // deliver a string representing the RE rooted in this node
    this.toRE = function(nohtml,nopos){
        if (this.arguments == 1) nohtml = false;
        if (this.arguments == 2) nopos = true;
        var str = ""
        if (this.kind == 0){          // leaf
            str += " ";
            str += this.sym;
            if (!nopos){
                str += posToSub(this.pos,nohtml);
            }
        } else if (this.kind == 1){   // alt
            for (var i = this.son; i != null; i = i.bro){
                if (i != this.son) str += " |";
                str += i.toRE(nohtml,nopos);
            }
        } else if (this.kind == 2){   // conc
            for (var i = this.son; i != null; i = i.bro){
                str += i.toRE(nohtml,nopos);
            }
        } else if (this.kind == 4){   // empty
            if (nohtml){
                str += " \u03b5";
            } else {
                str += " &epsilon;";
            }
            if (!nopos){
                str += posToSub(this.pos,nohtml);
            }
} else if (this.kind == 5){   // empty set
            if (nohtml){
                str += " \u03a6";
            } else {
                str += " &Phi;";
            }
        } else {                      // group
            if (this.groupKind == G_OPT){
                str += "[";
            } else if (this.groupKind == G_BOD){
                str += "\u00ab";
            } else {
                str += GR_OPEN;
            }
            if (!nopos){
                str += posToSub(this.pos,nohtml);
            }
            str += this.son.toRE(nohtml,nopos);
            if (this.groupKind == G_OPT){
                str += "]";
            } else if (this.groupKind == G_BOD){
                str += "\u00bb";
            } else {
                str += GR_CLOSE;
            }
            str += groupSym[this.groupKind];
            if (!nopos){
                str += posToSub(this.pos,nohtml);
            }
        }
        return str;
    }

    // deliver a string representing shortly this ast
    this.shortly = function(){
        var str = "ast seq: " + this.seq;
        str += " pos:";
        str += posToString(this.pos);
        str += " ";
        if (this.altnr != 0) str += "|" + this.altnr + " ";
        if (this.kind == 0){
            str += "leaf ";
            str += this.sym;
        } else if (this.kind == 1){
            str += "alt ";
        } else if (this.kind == 2){
            str += "conc ";
        } else if (this.kind == 4){
            str += "\u03b5";
} else if (this.kind == 5){
            str += "\u03a6";
        } else {
            str += " ";
            str += groupKind[this.groupKind];
        }
        return str;
    }

    // fields to draw the ast
    this.width = 0;             // width of the subtree
    this.height = 0;            // height of the subtree
    this.iconWidth = 0;         // width of the root
    this.iconHeight = 0;        // height of the root
    // deliver the icon of the root
    this.getIcon = function(){
        var res = "";
        switch (this.kind){
        case 0: res += this.sym; break;
        case 1: res += "|"; break;
        case 2: res += "\u2219"; break;
        case 3: res += groupIcon[this.groupKind]; break;
        case 4: res += "&epsilon;"; break;
        case 5: res += "&Phi;"; break;
        }
        res += posToSub(this.pos);
        if (this.altnr != 0) res += "<sup>|" + this.altnr + "</sup>";
        return res;
    }

    // convert this ast into a RE with the parentheses changed according to the
    // reintroduction rule
    this.reparenthesize = function(){
        var str = ""
        if (this.kind == 0){          // leaf
            str += " ";
            str += this.sym;
        } else if (this.kind == 1){   // alt
            for (var i = this.son; i != null; i = i.bro){
                if (i != this.son) str += " |";
                str += i.reparenthesize();
            }
        } else if (this.kind == 2){   // conc
            for (var i = this.son; i != null; i = i.bro){
                str += i.reparenthesize();
            }
        } else if (this.kind == 4){   // empty
} else if (this.kind == 5){   // empty set
        } else {                      // group
            if (this.groupKind == G_OPT){
                str += "[";
            } else if (this.groupKind == G_BOD){
                str += "\u00ab";
            } else if (this.groupKind == G_RE0){
                str += "(({(";
            } else {
                str += "({(";
            }
            str += this.son.reparenthesize();
            if (this.groupKind == G_OPT){
                str += "]";
            } else if (this.groupKind == G_BOD){
                str += "\u00bb";
            } else if (this.groupKind == G_RE0){
                str += ")})* | {})";
            } else if (this.groupKind == G_RE1){
                str += ")})+";
            } else {
                str += ")})";
            }
        }
        return str;
    }
}

var astSeq = 0;            // sequence number of ast nodes

// deliver a new ast node with the specified kind
function newAstNode(kind){
    var node = new AstNode();
    node.kind = kind;
    node.cursor = cursor;
    node.seq = astSeq++;
    trace('a',"newAstNode",node.seq,kind);
    astMap.set(node.seq,node);
    return node;
}
var groupKind = [
    "GRO","OPT","RE0","RE1","BOD"];
var groupSym = [
    "","","*","+",""];
var groupIcon = [
    GR_OPEN+GR_CLOSE,"[]",GR_OPEN+GR_CLOSE+"*",GR_OPEN+GR_CLOSE+"+","\u00ab\u00bb"];

// deliver a string representing the specified set of BSsymbols
function bsSetToString(set,nohtml){
    var str = "";
    str += "{";
    if (set == null){
        str += "null";
    } else {
        var first = true;
        for (var i = 0; i < set.arr.length; i++){
            if (first){
                first = false;
            } else {
                str += ", ";
            }
            if (nohtml){
                str += set.arr[i].toNoHtmlString();
            } else {
                str += set.arr[i].toString();
            }
        }
    }
    str += "}";
    return str;
}

// deliver a string representing the specifed position
function posToString(pos){
    if (pos == null) return "null";
    if (pos.length == 0) return "\u2227";
    if (pos[0] == Number.MAX_VALUE) return "$";
    var str = "";
    for (var i = 0; i < pos.length; i++){
        if (i > 0) str += '.';
        str += pos[i];
    }
    return str;
}

// deliver a Html markup representing the specifed position, or a simple markup
function posToSub(pos,nohtml){
    if (arguments.length == 1) nohtml = false;
    var str = "";
    if (levelNumbering){
        if (!nohtml) str += "<sub>";
        if (pos.length == 0){
            str += "\u2227";
        }
        if (pos[0] == Number.MAX_VALUE){
            str += "$";
        } else {
            for (var i = 0; i < pos.length; i++){
                if (i > 0) str += ".";
                str += pos[i];
            }
        }
        if (!nohtml) str += "</sub>";
    } else {
        if (!nohtml) str += "<span class=subn>";
        var idx = astSenMap.get(pos);
        if (idx != null){
            str += idx;
        }
        if (!nohtml) str += "</span> ";
    }
    return str;
}
var levelNumbering = true;          // whether positions are represented with level numbering

// trace the subtree rooted in the specified ast
function traceAst(ast){
    for (var a = ast; a != null; a = a.bro){
        twriteln("node:",a);
        traceAst(a.son);
    }
}

// number all the nodes rooted in the specified ast with their positions
function setPosAst(ast,pos,fat){
    if (ast == null) return;
    if (pos.length == 0) astSen = 0;
    ast.pos = pos;
    ast.fat = fat;
    if (ast.kind != 1 && ast.kind != 2){     // not conc or alt
        astSenMap.set(pos,++astSen);
    }
    var n = 1;
    for (var a = ast.son; a != null; a = a.bro){
        setPosAst(a,pos.concat([n]),ast);
        n++;
    }
}
var astSen = 0;          // sequential numbering index
var astSenMap;           // map from level numbered positions to sequential numbers

// compare two positions
function compareToPos(p1,p2){
    trace('m',"compareToPos",posToString(p1),posToString(p2));
    var n = p1.length;
    if (p2.length < n) n = p2.length;
    var i = 0;
    var j = 0;
    while (n-- != 0){
        var c1 = p1[i++];
        var c2 = p2[j++];
        if (c1 != c2) return c1 - c2;
    }
    return p1.length - p2.length;
}

var astMap;         // map from integers to ast nodes

var alphabet;       // the set of terminals

// build the set of terminals present in the ast rooted in the specified node
function astAlphabet(ast){
    if (ast == null) return;
    if (ast.kind == 0){
        alphabet.push(ast.sym);
    } else {
        for (var a = ast.son; a != null; a = a.bro){
            astAlphabet(a);
        }
    }
}

// ---------- Syntax analysis of a RE -----------------

var curNode;    // current node
var ast;        // current ast
var astRoot;    // root ast
var cursor;     // index in RE
var re;         // re to be analysed

// build the ast
function buildAst(test){
    trace('e',"buildAst");
    astMap = new MapClass();
    astSeq = 0;
    astSenMap = new MapClass();
    error = false;
    cursor = 0;
    curNode = null;
    expression();
    if (error || getsym() != -1){    // error or whole re not consumed
        if (!test){
            ele = document.getElementById("error");
            ele.selectionStart = cursor; // show the error
            ele.selectionEnd = re.length;
            ele.focus();
            document.getElementById("error").textContent = "malformed RE " + errorMessage;
            // trace('e',e.stack,e);
        }
        return;
    }
    if ('e' in trc){
        for (var i = 0; i < astMap.size(); i++){
            var entry = astMap.getEntry(i);
            twriteln("buildAst astMap",entry[0],entry[1]);
        }
    }

    ast = curNode;
    setPosAst(ast,[],null);
    if ('e' in trc){
        traceAst(ast);
    }

    if (!test){
        document.getElementById("annotated").innerHTML = ast.toRE();
        // twriteln(ast.reparenthesize());
    }

    eofAst = new newAstNode(0);
    eofAst.sym = EOF;                    // eof
    eofAst.pos = [Number.MAX_VALUE];
    if (BS_AUGM){
        computeAstNew(ast);
    } else {
        computeAst(ast);
    }
    if (error){
        document.getElementById("error").textContent = errorMessage;
        return;
    }
    if ('e' in trc){
        twriteln("buildAst done ast:");
        traceAst(ast);
    }

    if (!test){
        drawAst(ast);
    }
    astRoot = ast;
    alphabet = [];
    astAlphabet(ast);
}

var eofAst;     // ast for the end of text
var EOF = "\u22a2";

// parse an expression
function expression(){
    trace('a',"expression start at:",cursor);
    curNode = null;
    var r = null;
    var altnode = null;
    doit: {
        subexpression();                      // allow also nothing
        if (error) return;
        if (curNode == null){
            curNode = newAstNode(4);          // return empty
            curNode.sym = "\u03b5";
        }
        r = curNode;
        var n = 1;
        l: for (;;){
            var sym = getsym();
            if (sym < 0) break;
            if (sym != "|"){
                cursor--;
                break;
            }
            if (altnode == null){
                altnode = newAstNode(1);
                altnode.son = r;
                r = altnode.son;
                r.altnr = n;
            }
            var q = curNode;                  // save
            n++;
            trace('a',"expression inner at:",cursor);
            subexpression();                  // alternative, require a term
            if (error) return;
            if (curNode == null){
                curNode = newAstNode(4);      // return empty
                curNode.sym = "\u03b5";
            }
            r.bro = curNode;                  // store anyway
            r = curNode;
            r.altnr = n;
        } // l;
    } // doit
    if (altnode != null){
        curNode = altnode;
    }
    trace('a',"expression end at:",cursor,curNode,"re",curNode == null ? "" : curNode.toRE());
}

// parse a subexpression
function subexpression(){
    trace('a',"subexpression start at:",cursor);
    curNode = null;
    factor();
    if (error) return;
    var concnode = null;
    var first = curNode;
    if (curNode != null){
        var q = curNode;
        var n = 1;
        l: for (;;){
            var p = curNode;
            n++;
            trace('a',"subexpression inner at:",cursor);
            factor();
            if (error) return;
            if (curNode != null){    // several terms
                if (concnode == null){
                    concnode = newAstNode(2);
                    concnode.son = p;
                    q = p;
                }
            } else {
                curNode = p;
                break;
            }
            q.bro = curNode;
            q = curNode;
        } // l
    }
    if (concnode != null){
        curNode = concnode;
    }
    trace('a',"subexpression end at:",cursor,curNode,"re",curNode == null ? "" : curNode.toRE());
}

var STRUCTURED = false;
// parse a factor
function factor(){
    trace('a',"factor start at:",cursor);
    curNode = null;
    var sym = getsym();
    var groupnode = null;
    trace('a',"factor sym",sym);
    doit: if (sym == -1){
        trace('a',"factor return",error);
        return;
    } else if (sym == "|" || sym == GR_CLOSE || sym == "]"){
        cursor--;
    } else if (sym == "["){
        expression();
        if (error) return;
        groupnode = newAstNode(3);
        groupnode.groupKind = G_OPT;
        groupnode.son = curNode;
        if (getsym() != "]"){
            error = true;
            errorMessage = "syntax: ] not closed";
            return;
        }
    } else if (sym == GR_OPEN){
        trace('a',"factor group start");
        expression();
        if (error) return;
        groupnode = newAstNode(3);
        groupnode.groupKind = G_GRO;
        groupnode.son = curNode;
        if (getsym() != GR_CLOSE){
            error = true;
            errorMessage = "syntax: ) not closed";
            return;
        }
        sym = getsym();
        trace('a',"factor group end",sym);
        if (sym == "*"){
            if (STRUCTURED){
                groupnode.groupKind = G_BOD;
                var g = newAstNode(3);
                g.groupKind = G_RE0;
                g.son = groupnode;
                groupnode = g;
            } else {
                groupnode.groupKind = G_RE0;
            }
        } else if (sym == "+"){
            if (STRUCTURED){
                groupnode.groupKind = G_BOD;
                var g = newAstNode(3);
                g.groupKind = G_RE1;
                g.son = groupnode;
                groupnode = g;
            } else {
                groupnode.groupKind = G_RE1;
            }
        } else if (sym != -1){
            cursor--;
        }
    } else {
if (astEmpty){
    if (sym == "Îµ"){
        curNode = newAstNode(4);      // return empty
        curNode.sym = sym;
        break doit;
    }
    if (sym == "Î¦"){
        curNode = newAstNode(5);      // return empty set
        curNode.sym = sym;
        break doit;
    }
}
        curNode = newAstNode(0);
        curNode.sym = sym;
    } // doit
    if (groupnode != null){
        curNode = groupnode;
    }
    for (;;){
        var sym = getsym();
        if (sym == "*"){
            groupnode = newAstNode(3);
            groupnode.groupKind = G_RE0;
            groupnode.son = curNode;
        } else if (sym == "+"){
            groupnode = newAstNode(3);
            groupnode.groupKind = G_RE1;
            groupnode.son = curNode;
        } else if (sym != -1){
            cursor--;
            break;
        } else {
            break;
        }
        curNode = groupnode;
    }

    trace('a',"factor end at:",cursor,curNode,"re",curNode == null ? "" : curNode.toRE());
}
var astEmpty = false;       // whether Îµ and Î¦ accepted

// get the next character from the RE
function getsym(){
    trace('b',"getsym cursor:",cursor,"re",re);
    var res;
    for (; cursor < re.length; cursor++){
        if (re[cursor] != " ") break;
    }
    if (cursor >= re.length){   // eof
        res = -1;
    } else {
        res = re[cursor++];
    }
    trace('b',"getsym ret cursor:",cursor,"re",re,"res",res);
    return res;
}

</script>
<script>
// ---------- Building the B&S DFA  -----------------

var BS_AUGM;     // whether we are building an augmented B&S

// compute the B&S attributes for the subtree rooted in the specified ast node for the basic B&S
function computeAst(ast){
    trace('e',"computeAst:",ast,"sub-re:",ast.toRE());
    switch (ast.kind){
    case 0:                               // terminal
        ast.isNull = false;
        ast.ini = new SetClass();
        ast.ini.add(newBSsymbol(ast.seq));
        ast.fin = new SetClass();
        ast.fin.add(newBSsymbol(ast.seq));
        ast.dig = new SetClass();
        break;
    case 4:                               // empty
        ast.isNull = true;                // empty
        ast.ini = new SetClass();
        ast.fin = new SetClass();
        ast.dig = new SetClass();
        break;
    default:
        ast.ini = new SetClass();
        ast.fin = new SetClass();
        ast.dig = new SetClass();
        for (var a = ast.son; a != null; a = a.bro){
            computeAst(a);
        }
    }
    switch (ast.kind){
    case 1:                       // alternative
        trace('e',"computeAst: alt start",ast);
        ast.isNull = false;
        if (ast.son == null) ast.isNull = true;
        for (var a = ast.son; a != null; a = a.bro){
            ast.isNull |= a.isNull;
            ast.ini.addAll(a.ini);
            ast.fin.addAll(a.fin);
            ast.dig.addAll(a.dig);
        }
        trace('e',"computeAst: alt end",ast);
        break;
    case 2:                       // concatenation
        trace('e',"computeAst: conc start",ast);
        var iniDone = false;
        var lastNotNull = ast.son;         // in case all are null
        var digfin = new SetClass();
        for (var a = ast.son; a != null; a = a.bro){
            trace('e',"computeAst: conc ele",a);
            if (!a.isNull) lastNotNull = a;
            ast.isNull &= a.isNull;
            if (!iniDone){
                ast.ini.addAll(a.ini);
                if (!a.isNull){
                    iniDone = true;
                }
            }
            ast.dig.addAll(a.dig);
            if (a != ast.son){                // first
                var iniarr = a.ini.toArray();
                var finarr = digfin.toArray();
                for (var i = 0; i < finarr.length; i++){
                    for (var j = 0; j < iniarr.length; j++){
                        ast.dig.add(newBSsymbol(finarr[i],iniarr[j]));
                    }
                }
            }

            // compute the fin of all elements up to and including the current one
            digfin.clear();
            for (var aa = lastNotNull; aa != null; aa = aa.bro){
                digfin.addAll(aa.fin);
                if (aa == a) break;
            }
        }
        for (var a = lastNotNull; a != null; a = a.bro){
            ast.fin.addAll(a.fin);       // union of all those of the null tail + last not null
        }
        trace('e',"computeAst: conc end",ast);
        break;
    case 3:                               // sub-re
        trace('e',"computeAst: group start",ast,"body",ast.son);
        if (ast.groupKind == G_RE1 || ast.groupKind == G_GRO || ast.groupKind == G_BOD){
            ast.isNull = ast.son.isNull;
        } else {
            ast.isNull = true;
        }
        ast.ini.clear();
        var iniarr = ast.son.ini.toArray();
        ast.ini.addAll(ast.son.ini);

        ast.fin.clear();
        var finarr = ast.son.fin.toArray();
        ast.fin.addAll(ast.son.fin);

        ast.dig.addAll(ast.son.dig);
        digrams: {
            if (STRUCTURED && (ast.groupKind == G_RE0 || ast.groupKind == G_RE1)) break digrams;  // body does it ???
            if (ast.groupKind != G_GRO && ast.groupKind != G_OPT){
                for (var i = 0; i < finarr.length; i++){
                    for (var j = 0; j < iniarr.length; j++){
                        ast.dig.add(newBSsymbol(finarr[i],iniarr[j]));
                    }
                }
            }
        } // digrams
        trace('e',"computeAst: group end",ast);
        break;
    }
    if (ast.pos.length == 0){           // top node
        var e = eofAst;
        var finarr = ast.fin.toArray();
        for (var i = 0; i < finarr.length; i++){
            ast.dig.add(newBSsymbol(finarr[i],e.seq));
        }
    }
    trace('e',"computeAst done:",ast);
}

// compute the B&S attributes for the subtree rooted in the specified ast node for the augmented B&S
function computeAstNew(ast){
    trace('e',"computeAst:",ast,"sub-re:",ast.toRE());
    switch (ast.kind){
    case 0:                               // terminal
        ast.isNull = false;
        ast.ini = new SetClass();
        ast.ini.add(newBSsymbol(astToBSele(ast,ELEOPEN),ast.seq));
        ast.fin = new SetClass();
        ast.fin.add(newBSsymbol(ast.seq,astToBSele(ast,ELECLOSE)));
        ast.dig = new SetClass();
        ast.dig.addAll(ast.ini);
        ast.dig.addAll(ast.fin);
        break;
    case 4:                               // empty
        ast.isNull = true;                // empty
        ast.ini = new SetClass();
        ast.ini.add(newBSsymbol(astToBSele(ast,ELEOPEN)));
        ast.fin = new SetClass();
        ast.fin.add(newBSsymbol(astToBSele(ast,ELECLOSE)));
        ast.dig = new SetClass();
        ast.dig.add(newBSsymbol(astToBSele(ast,ELEOPEN),astToBSele(ast,ELECLOSE)));
        break;
    default:
        ast.ini = new SetClass();
        ast.fin = new SetClass();
        ast.dig = new SetClass();
        for (var a = ast.son; a != null; a = a.bro){
            computeAstNew(a);
        }
    }
    switch (ast.kind){
    case 1:                       // alternative
        trace('e',"computeAst: alt start",ast);
        ast.isNull = false;
        ast.ini.add(newBSsymbol(astToBSele(ast,ELEOPEN)));
        ast.fin.add(newBSsymbol(astToBSele(ast,ELECLOSE)));
        var ini = new SetClass();
        var fin = new SetClass();
        if (ast.son == null) ast.isNull = true;
        for (var a = ast.son; a != null; a = a.bro){
            ast.isNull |= a.isNull;
            ini.addAll(a.ini);
            fin.addAll(a.fin);
            ast.dig.addAll(a.dig);
        }
        var iniarr = ini.toArray();
        for (var i = 0; i < iniarr.length; i++){
            ast.dig.add(newBSsymbol(astToBSele(ast,ELEOPEN),iniarr[i]));   // enter subexpression
        }
        var finarr = fin.toArray();
        for (var i = 0; i < finarr.length; i++){
            ast.dig.add(newBSsymbol(finarr[i],astToBSele(ast,ELECLOSE)));    // leave subexpression
        }
        trace('e',"computeAst: alt end",ast);
        break;
    case 2:                       // concatenation
        trace('e',"computeAst: conc start",ast);
        ast.isNull = false;
        ast.ini.add(newBSsymbol(astToBSele(ast,ELEOPEN)));
        ast.fin.add(newBSsymbol(astToBSele(ast,ELECLOSE)));
        var prev = null;
        for (var a = ast.son; a != null; a = a.bro){
            trace('e',"computeAst: conc ele",a);
            ast.isNull &= a.isNull;
            ast.dig.addAll(a.dig);
            if (a != ast.son){                // not first
                var iniarr = a.ini.toArray();
                var finarr = prev.fin.toArray();
                for (var i = 0; i < finarr.length; i++){
                    for (var j = 0; j < iniarr.length; j++){
                        ast.dig.add(newBSsymbol(finarr[i],iniarr[j]));
                    }
                }
            }
            prev = a;
        }
        var iniarr = ast.son.ini.toArray();
        for (var i = 0; i < iniarr.length; i++){
            ast.dig.add(newBSsymbol(astToBSele(ast,ELEOPEN),iniarr[i]));   // enter subexpression
        }
        var finarr = prev.fin.toArray();
        for (var i = 0; i < finarr.length; i++){
            ast.dig.add(newBSsymbol(finarr[i],astToBSele(ast,ELECLOSE)));    // leave subexpression
        }
        break;
    case 3:                               // sub-re
        trace('e',"computeAst: group start",ast,"body",ast.son);
        if (ast.groupKind == G_RE1 || ast.groupKind == G_GRO || ast.groupKind == G_BOD){
            ast.isNull = ast.son.isNull;
        } else {
            ast.isNull = true;
        }
        ast.ini.add(newBSsymbol(astToBSele(ast,ELEOPEN)));
        ast.fin.add(newBSsymbol(astToBSele(ast,ELECLOSE)));
        ast.dig.addAll(ast.son.dig);
        var iniarr = ast.son.ini.toArray();
        for (var i = 0; i < iniarr.length; i++){
            ast.dig.add(newBSsymbol(astToBSele(ast,ELEOPEN),iniarr[i]));   // enter subexpression
        }
        var finarr = ast.son.fin.toArray();
        for (var i = 0; i < finarr.length; i++){
            ast.dig.add(newBSsymbol(finarr[i],astToBSele(ast,ELECLOSE)));    // leave subexpression
        }

        if (STRUCTURED){
            if (ast.groupKind == G_BOD){
                var iniarr = ast.son.ini.toArray();
                var finarr = ast.son.fin.toArray();
                for (var i = 0; i < finarr.length; i++){
                    for (var j = 0; j < iniarr.length; j++){
                        ast.dig.add(newBSsymbol(finarr[i],iniarr[j]));
                    }
                }
            }
        } else {
            if (ast.groupKind != G_GRO && ast.groupKind != G_OPT){
                var iniarr = ast.son.ini.toArray();
                var finarr = ast.son.fin.toArray();
                for (var i = 0; i < finarr.length; i++){
                    for (var j = 0; j < iniarr.length; j++){
                        ast.dig.add(newBSsymbol(finarr[i],iniarr[j]));
                    }
                }
            }
        }
        if (ast.groupKind == G_RE0 || ast.groupKind == G_OPT){
            ast.dig.add(newBSsymbol(astToBSele(ast,ELEOPEN),astToBSele(ast,ELECLOSE))); // ( e )
        }
        break;
    }
    if (ast.pos.length == 0){           // top node
        var e = eofAst;
        var finarr = ast.fin.toArray();
        for (var i = 0; i < finarr.length; i++){
            ast.dig.add(newBSsymbol(finarr[i],e.seq));
        }
    }
    trace('e',"computeAst done:",ast);
}

// compute the n-grams for the tree rooted in the specified ast
function computeNgrams(ast,dfa){
    trace('n',"computeNgrams",ast);
    var change = true;
    var arr = ast.dig.toArray();
    var added = 0;
    l: for (var i = 1; i < arr.length; i++){
        for (var j = 0; j < i; j++){
            // trace('n',"computeNgrams process:",i+":",arr[i].toNoHtmlString(),"and",
            //     j+":",arr[j].toNoHtmlString());
            var last = arr[i].eleAt(-1);
            var first = arr[j].eleAt(0);
            var start = arr[i].eleAt(0);
            var kind = BSeleKind(start);
            if (isBSeleTerminal(start) || kind == ELEOPEN && BSeleToAst(start).pos.length == 0){  // starts with terminal or (^
                add: if (last == first && !isBSeleTerminal(last)){     // do not concatenate with terminal
                    trace('n',"computeNgrams process:",i+":",arr[i].toNoHtmlString(),"and",
                        j+":",arr[j].toNoHtmlString());
                    if (!isAllowedSeq(arr[i],arr[j])) break add;     // avoid endless strings ()()...
                    var ele = newBSsymbol(arr[i].substring(0,-1),arr[j]);
                    for (var k = 0; k < arr.length; k++){
                        if (arr[k].equals(ele)) break add;   // no duplicates
                    }
                    if (added++ > 1000){                     // catch endless loops
                        twriteln("!!!!!");
                        error = true;
                        errorMessage = "B%S too many n-grams";
                        break l; 
                    }
                    arr.push(ele);
                    trace('n',"computeNgrams add1:",(arr.length-1)+":",ele.toNoHtmlString());
                }
            }
            last = arr[j].eleAt(-1);
            first = arr[i].eleAt(0);
            start = arr[j].eleAt(0);
            kind = BSeleKind(start);
            if (isBSeleTerminal(start) || kind == ELEOPEN && BSeleToAst(start).pos.length == 0){  // starts with terminal or (^
                add: if (last == first && !isBSeleTerminal(last)){      // do not concatenate with terminal
                    trace('n',"computeNgrams process:",j+":",arr[j].toNoHtmlString(),"and",
                        i+":",arr[i].toNoHtmlString());
                    if (!isAllowedSeq(arr[j],arr[i])) continue;
                    var ele = newBSsymbol(arr[j].substring(0,-1),arr[i]);
                    for (var k = 0; k < arr.length; k++){
                        if (arr[k].equals(ele)) break add;
                    }
                    arr.push(ele);
                    if (added++ > 1000){
                        twriteln("!!!!!");
                        error = true;
                        errorMessage = "B%S too many n-grams";
                        break l; 
                    }
                    trace('n',"computeNgrams add2:",(arr.length-1)+":",ele.toNoHtmlString());
                }
            }
        }
    }
    // extract then the ones that start with (^ into Init, and the ones that start with
    // a terminal into Follow
    trace('n',"computeNgrams compute ini and foll");
    dfa.initSet = new SetClass();
    dfa.followSet = new SetClass();
    for (var i = 0; i < arr.length; i++){
        var el = arr[i];
        var first = arr[i].eleAt(0);
        var last = arr[i].eleAt(-1);
        if (!isBSeleTerminal(last)) continue;    // does not end with terminal
        var kind = BSeleKind(first);
        if (kind == ELEOPEN && BSeleToAst(first).pos.length == 0){          // (^
            if (!purgedTag(dfa.initSet,el,dfa.purge)){
                dfa.initSet.add(el);
            }
            trace('n',"computeNgrams add ini",i,el.toNoHtmlString());
        } else if (isBSeleTerminal(first)){                 // terminal
            if (!purgedTag(dfa.followSet,el,dfa.purge)){
                dfa.followSet.add(el);
            }
            trace('n',"computeNgrams add foll",i,el.toNoHtmlString());
        }
    }
}

// check that the sequence obtained concatenating the first argument (trimmed by its last
// element) with the second one is allowed, i.e. it does not contain the concatenation
// of two bodies of the same *|+ group one of which generates the empty string
function isAllowedSeq(s1,s2){
    trace('g',"isAllowedSeq",s1.toNoHtmlString(),s2.toNoHtmlString());
    var res = true;
    doit: {
        // treat this case: (â§(1Îµ1)1(1Îµ1 and Îµ1)1

        // there is a need to detect also the partial groups at the beginning, e.g.:
        // a1.2.1)1.2.1)1.2)1(1(1.2 and 12: (1.2Îµ1.2)1.2  here we have two repetitions
        // of 1, and the first is nonempty and the second is empty
        
        var s = newBSsymbol(s1.substring(0,-1),s2);
        trace('g',"isAllowedSeq",s.toNoHtmlString());

        for (var i = 0; i < s.length(); i++){
            var ele = s.eleAt(i);
            var k = BSeleKind(ele);
            if (k == 0) continue;         // not an open or close
            var pos = BSeleToPos(ele);
            for (var j = i+1; j < s.length(); j++){
                ele = s.eleAt(j);
                var k1 = BSeleKind(ele);
                if (k != k1) continue;
                var pos1 = BSeleToPos(ele);
                if (arraysIdentical(pos,pos1)){
                    res = false;
                    break doit;
                }
            }
        }
        break doit;
    } // doit
    trace('n',"isAllowedSeq",s.toNoHtmlString(),"res",res);
    return res;
}

// tell if the element is not to be added because it has been purged
// N.B. the states reached from the initial one, when purged, have no convergences because
// the paths in the AST that lead to a same terminal are unique
function purgedTag(set,el,purge){
    if (purge == "none") return false;
    // el starts with a terminal and ends with a terminal, or starts with (^
    var res = false;
    var startpos = BSeleToPos(el.eleAt(0));
    var lastpos = BSeleToPos(el.eleAt(-1));
    var tag = el.tag();
    var arr = set.toArray();
    for (var i = 0; i < arr.length; i++){
        var e = arr[i];
        var startp = BSeleToPos(e.eleAt(0));
        var lastp = BSeleToPos(e.eleAt(-1));
        if (!arraysIdentical(startp,startpos)) continue;
        if (!arraysIdentical(lastp,lastpos)) continue;
        // choose one of them
        var t = e.tag();
        var cmp = 0;
        if (purge == "posix"){
            cmp = pat_comp_tags(tag,t);
        } else {
            compare: {
                var bp0t1 = pat_bp0(tag,t);
                var bp0t2 = pat_bp0(t,tag);
                if (bp0t1 > bp0t2){
                    cmp = 1;
                    break compare;
                }
                if (bp0t2 > bp0t1){
                    cmp = -1;
                    break compare;
                }
                // bp0t1 == bp0t2
                cmp = pat_subset_tags(tag,t);
            }
        }

        if (cmp > 0){                                     // tag of el less prior or equal, tell not to add
            res = true;
        } else if (cmp < 0){                              // remove the other
            set.remove(i);
            trace('n',"purgedTag removed",e.toNoHtmlString());
        }
        break;
    }
    trace('n',"purgedTag",posToString(startpos),posToString(lastpos),"res",res);
    return res;
}

// deliver a string of as many blanks * 2 as the argument
function indent(lev){
    var str = "";
    for (var i = 0; i < lev; i++){
        str += "  ";
    }
    return str;
}

// the items of the DFA states
function BSItem(){
    this.sym = null;      // the BSsymbol
    this.left = null;     // the set of iids
}

// deliver a string representing the specified item
function bsItemToString(item,nohtml){
    var st = new StringBuilder();
    st.append("[");
    if (nohtml){
        st.append(item.sym.toNoHtmlString());
    } else {
        st.append(item.sym.toString());
    }
    var arr = item.left.toArray();
    for (var j = 0; j < arr.length; j++){
        st.append(",#");
        st.append(arr[j]);
    }
    st.append("]");
    return st.toString();
}

// the transitions
function GBSTrans(){
    this.next = null;       // reference to the next transition
    this.nextState = null;  // the next state (endpoint of this transition)
    this.sym = 0;           // the terminal
    this.edge = null;       // reference to the Graph edge that represents it
}

// the states
function GBState(){
    this.suc = null;        // the reference to the next state in the list of states
    this.number = 0;        // state number
    this.transList = null;  // the head of the list of transitions
    this.items = [];        // the items
    this.isFinal = false;   // whether this state is final
    this.node = null;       // reference to the Graph node that represents it

    // deliver a string representation of this state
    this.toString = function(){
        var st = new StringBuilder();
        st.append(this.number);
        if (this.isFinal) st.append(" final");
        st.append(": ");
        for (var i = 0; i < this.items.length; i++){
            if (i > 0) st.append(", ");
            st.append(bsItemToString(this.items[i]));
        }
        for (var t = this.transList; t != null; t = t.next){
            st.append(" ");
            st.append(t.sym);
            st.append("->");
            st.append(t.nextState.number);
        }
        return st.toString();
    }

    // tell if this state contains the same items as the specified one, or the
    // same items as contained in the variable items (len indicates the number of
    // items in it
    this.equals = function(other,len){
        if (arguments.length == 1){
            if (this == other) return true;
            if (other == null) return false;
            return this.equals(other.items,other.items.length);
        }
        var items = other;
        if (this.items.length != len){
            return false;
        }
        for (var i = 0; i < len; i++){
            if (!this.items[i].sym.equals(items[i].sym) ||
                !this.items[i].left.equals(items[i].left)){
                return false;
            }
        }
        return true;
    }

    // trace this state
    this.trace = function(){
        twriteln("state:",this.number,this.isFinal ? "final" : "");
        twriteln("  items:");
        for (var j = 0; j < this.items.length; j++){
            twriteln("    ",j+":",bsItemToString(this.items[j],true));
        }
        twriteln("  transitions:");
        for (var t = this.transList; t != null; t = t.next){
            twriteln("    ",t.sym,"->",t.nextState.number);
        }
    }

    // trace this state in Html form
    this.toHtmlString = function(){
        var str = "";
        str += "<dd>state: " + this.number + (this.isFinal ? " final" : "") + "</dd>";
        str += "<dd style=\"text-indent: 2em;\">items:</dd>";
        for (var j = 0; j < this.items.length; j++){
            str += "<dd style=\"text-indent: 4em;\">" + j +
               ":" + bsItemToString(this.items[j]) + "</dd>";
        }
        str += "<dd style=\"text-indent: 2em;\">transitions:</dd>";
        for (var t = this.transList; t != null; t = t.next){
            str += "<dd style=\"text-indent: 4em;\">" + t.sym + "&rarr;" +
                t.nextState.number + "</dd>";
        }
        return str;
    }

    // trace this state in Html form
    this.traceHtml1 = function(ele){
        var str = "";
        str += "<div class=llabel> state: " + this.number + (this.isFinal ? " final" : "");
        str += "<dd class=llabel1>items:</dd>";
        for (var j = 0; j < this.items.length; j++){
            str += "<dd class=llabel2>" + j +
               ":" + bsItemToString(this.items[j]) + "</dd>";
        }
        str += "<dd class=llabel1>transitions:</dd>";
        for (var t = this.transList; t != null; t = t.next){
            str += "<dd class=llabel2>" + t.sym + "&rarr;" +
                t.nextState.number + "</dd>";
        }
        str += "</div>";
        ele.innerHTML = str;
    }
}

// create a new state with the specified number, and items
function newGBState(n,items,len){
    var s = new GBState();
    s.number = n;
    if (items != null){
        s.items = items.slice(0,len);
    }
    return s;
}

// the state table
function BStateTable(){
    this.head = null;       // the head of the list of states
    this.last = null;       // the tail of the list
    this.lastAdded = null;  // the last state added
    this.stateNr = 0;       // the number of states
    this.table = [];        // the table of states
    this.initSet = null;    // the set of items of the initial state
    this.followSet = null;  // the set of items that follow a terminal
    this.purge = "";        // none, posix, greedy

    // search the state containing the specified items
    this.search = function(items,len){
        for (var h = this.head; h != null; h = h.suc){
            if (h.equals(items,len)) return h;
        }
        return null;
    }

    // add a state with the specified items, if not present
    this.addUnique = function(items,len){
        trace('d',"addUnique");
        var h = this.search(items,len);
        this.lastAdded = h;
        if (h != null){                         // found
            trace('d',"addUnique found");
            return false;
        }
        h = newGBState(this.stateNr++,items,len); // allocate entry
        if (this.last == null) this.head = h;     // append to list
        else this.last.suc = h;
        this.last = h;
        this.lastAdded = h;
        trace('d',"addUnique added");
        return true;
    }

    // trace this table of states
    this.trace = function(){
        for (var s = this.head; s != null; s = s.suc){
            s.trace();
        }
    }

    // trace this table of states in Html form
    this.traceHtml = function(ele){
        var str = "";
        for (var s = this.head; s != null; s = s.suc){
            str += s.toHtmlString();
        }
        ele.innerHTML = str;
    }
}

var bsDFA;     // the DFA
var bsitems;   // items of the state currently built
var itmNr;     // their number

// add an item with the specified BSsymbol and iids to the current items, if not present
function addbsItem(sym,left){
    var itm = 0;
    var end = itmNr;
    var off = -1;
    while ((++off < end) &&          // search duplicates
        !bsitems[off].sym.equals(sym));
    if (off < end){                  // already present
        itm = off;
        trace('d',"add already present",bsItemToString(bsitems[itm]),"add iid",left);
        bsitems[itm].left.add(left);
    } else {
        bsitems[itmNr] = new BSItem();
        bsitems[itmNr].sym = sym;
        bsitems[itmNr].left = new SetClass();
        bsitems[itmNr].left.add(left);
        itm = itmNr;
        itmNr++;
        trace('d',"added",bsItemToString(bsitems[itm]));
    }
    return itm;
}

// add a new state with the current items
function addBState(dfa){
    var res = null;
    var items = bsitems.slice(0,itmNr);
    items.sort(function(i1,i2){return i1.sym.compareTo(i2.sym)});
    if (dfa.addUnique(items,itmNr)){
        for (var i = 0; i < itmNr; i++){
            var bssym = items[i].sym.eleAt(-1);     // last
            var sym = BSeleToAst(bssym).sym;
            if (sym == EOF){
                dfa.lastAdded.isFinal = true;
                break;
            }
        }
        trace('d',"added state:",dfa.lastAdded);
    } else {
        trace('d',"found state:",dfa.lastAdded);
    }
    res = dfa.lastAdded;
    return res;
}

// add a transition from the specifed states with the specified symbol
function addBSEdge(from,to,sym){
    var t;
    sea: {
        var pr = null;
        for (t = from.transList; t != null; t = t.next){      // find edge or last
            if ((t.nextState == to) &&                         // do not insert duplicates
                (t.sym == sym)){
                break sea;
            }
            pr = t;
        }
        t = new GBSTrans();
        t.nextState = to;
        t.sym = sym;
        if (pr == null){                // append
            from.transList = t;
        } else {
            pr.next = t;
        }
    }
    return t;
}

// build the DFA
function buildBS(ast,purge){
    trace('d',"buildBS",ast);
    dfa = new BStateTable();
    bsitems = [];
    itmNr = 0;
    if (arguments.length == 2){
        dfa.purge = purge;
    } else {
        dfa.purge = "posix";
    }
    if (BS_AUGM){
        computeNgrams(ast,dfa);
    } else {
        dfa.initSet = ast.ini;
        dfa.followSet = ast.dig;
    }
    var arr = dfa.initSet.toArray();
    for (var i = 0; i < arr.length; i++){
        addbsItem(arr[i],0);
    }
    var digarr = dfa.followSet.toArray();
    addBState(dfa);
    if ('d' in trc){
        trace('d',"buildBS initial state:");
        dfa.trace();
    }
    // visit the initial state and the ones generated after it
    // to create all states
    var cur = dfa.head;                    // build the next ones
    while (cur != null){
        trace('d',"processing state:",cur.number,alphabet);
        // determine the transitions to the next states
        for (var c = 0; c < alphabet.length; c++){  // for all b in sigma
            itmNr = 0;
            for (var i = 0; i < cur.items.length; i++){   // scan its items
                var itm = cur.items[i];
                var p = itm.sym.eleAt(-1);          // (())b: take b
                var sym = BSeleToAst(p).sym;
                if (sym != alphabet[c]) continue;
                trace('d',"item",i,bsItemToString(itm),": symbol",c);

                for (var j = 0; j < digarr.length; j++){
                    var ele = digarr[j];
                    if (ele.arr[0] != p) continue;
                    addbsItem(ele.substring(1,ele.length()),i);
                }
            }
            if (itmNr > 0){            // add the new state
                trace('d',"buildBS adding next state");
                var next = addBState(dfa);
                trace('d',"buildBS adding edge to it");
                addBSEdge(cur,next,alphabet[c]);
                trace('d',"buildBS adding next done");
            }
        }
        cur = cur.suc;
    }
    if ('d' in trc){
        trace('d',"buildBS DFA:",ast.toRE());
        dfa.trace();
    }
    return dfa;
}

// ---------- Matching  -----------------

// an element in the list of states encountered during matching
function PathNodeClass(){
    this.suc = null;       // the (element for the) next state encountered
    this.next = null;      // the (element for the) previous state encountered
    this.from = null;      // the from state
    this.to = null;        // the to state
    this.sym = 0;          // the terminal
    this.iid = 0;          // the iid of the selected item
    this.activeIids = [];  // the active iid of each item of the to state
    this.iidNodes = [];    // the nodes of the graph of the paths denoting the trees for items of the from state
    this.elem = null;      // element that shows the progress

    // deliver a string denoting this element
    this.toString = function(){
        var str = this.from.number;
        if (this.to != null) str += "-" + this.sym + "->" + this.to.number;
        str += " activeIids " + this.activeIids;
        str += " iid " + this.iid;
        str += " iidNodes " + this.iidNodes;
        return str;
    }

    // trace this element
    this.trace = function(){
        twriteln("from",this.from.number,
            this.to != null ? (this.sym + "->" + this.to.number) : "");
        for (var i = 0; i < this.from.items.length; i++){
            twriteln("    ",i+":",
                this.iidNodes[i] == null ? " " : "*",
                i == this.iid ? "!" : " ",
                bsItemToString(this.from.items[i],true),
                this.next != null ?
                    (typeof(this.next.activeIids[i]) == "undefined" ? "" : "act#"+this.next.activeIids[i]) : " ",
                this.iidNodes[i] == null ? "" : this.iidNodes[i]);
        }
        if (this.to != null){
            twriteln("  to",this.to.number);
            for (var i = 0; i < this.to.items.length; i++){
                twriteln("    ",i+":",
                    this.suc != null ?
                        (this.suc.iidNodes[i] == null ? " " : "*") : " ",
                    i == this.iid ? "!" : " ",
                    bsItemToString(this.to.items[i],true),
                    typeof(this.activeIids[i]) == "undefined" ? "" : "act#"+this.activeIids[i],
                    this.suc != null ?
                        (this.suc.iidNodes[i] == null ? "" : this.suc.iidNodes[i]) : "");
            }
        }
    }
}

// create a new PathNode with the specified data
function newPathNodeClass(from,to,sym){
    var node = new PathNodeClass();
    node.from = from;
    node.to = to;
    node.sym = sym;
    return node;
}

// match the string containing the text against the RE
function match(test,text,dfa){
    error = false;
    trace('m',"match start RE:",ast.toRE(true),"text",text);
    var head = null;
    var state = dfa.head;
    cursor = 0;
    for (var i = 0; i < text.length; i++){
        if ('m' in trc){
            trace('m',"match at:",i,"sym",text[i]);
            state.trace();
        }
        var next = null;
        for (var t = state.transList; t != null; t = t.next){
            if (t.sym == text[i]){
                next = t.nextState;
                break;
            }
        }
        if (next == null){
            error = true;
            errorMessage = "match: no next state";
            cursor = i;
            break;
        }
        var pnode = newPathNodeClass(state,next,text[i]);
        pnode.next = head;
        head = pnode;
        state = next;
    }
    pnode = newPathNodeClass(state,null,EOF);
    pnode.next = head;
    head = pnode;
    if (!state.isFinal){
        error = true;
        errorMessage = "match: ended in nonfinal state";
    }
    if (!test){
        if (error){                  // error or whole re not consumed
            var ele = document.getElementById("text");
            ele.selectionStart = cursor; // show the error
            ele.selectionEnd = text.length;
            ele.focus();
            document.getElementById("error").textContent = "not matched " + errorMessage;
        } else {
            document.getElementById("result").textContent = "matched";
        }
    }
    trace('m',"match end RE:",ast.toRE(true),"text",text,error ? "failure" : "success");
    if ('m' in trc){
        for (var i = head; i != null; i = i.next){
            twriteln(i);
        }
    }
    trace('m',"match end");
    return head;
}

// the list of states encountered during matching
var stateList = null;

// show the dfa
function showdfa(){
    var el = document.getElementById("thedfa");
    if (el.style.display == "block"){
        el.style.display = "none";
    } else {
        if (bsDFA != null){
            el.style.display = "block";
            showbs();
            var gr = new Graph();
            gr.name = "B&S DFA";
            gr.extras = new GraphExtras();
            for (var s = bsDFA.head; s != null; s = s.suc){
                s.node = newNode(gr,s.number,
                    s.isFinal ? "yellow" : "white",s.toString());
                s.node.extras.state = s;
            }
            for (var s = bsDFA.head; s != null; s = s.suc){
                for (var t = s.transList; t != null; t = t.next){
                    t.edge = newEdge(gr,"",t.sym,s.node,t.nextState.node);
                }
            }
            drawGraph(gr);
        }
    }
    matchAnimate();
}

// show the dfa displaying the First and Follow sets, and then the states
function showbs(){
    document.getElementById("bsfirst").innerHTML = bsSetToString(bsDFA.initSet);
    var followMap = new MapClass();
    var foll = bsDFA.followSet.toArray();
    for (var i = 0; i < foll.length; i++){
        var ele = foll[i];
        var sym = ele.arr[0];
        var value = followMap.get(sym);
        if (value == null){
            value = new SetClass();
        }            
        value.add(ele.substring(1));
        followMap.set(sym,value);
    }
    var elefoll = document.getElementById("bsfollow");
    elefoll.innerHTML = "<br>";
    for (var i = 0; i < followMap.size(); i++){
        var entry = followMap.getEntry(i);
        elefoll.innerHTML += BSeleToString(entry[0]) + ": " + bsSetToString(entry[1]) + "</br>";
    }
    var ele = document.getElementById("dfa");
    ele.innerHTML = "";
    bsDFA.traceHtml(ele);
}

</script>
<script>
// deliver the depth in the tree denoted by the specified tag
function pat_height(tag){
    var ele = BSeleToAst(tag);
    var res = ele.pos.length;
    if (BSeleKind(tag) == ELEOPEN){    // node entry
        res++;
    }
    // trace('o',"pat_height",BSeleToString(tag),res);
    return res;
}

// deliver the height of the last element of the specified BSsymbol, possibly terminated with a terminal
function pat_lastsp(tag){
    if (tag == null || tag.length() <= 1) return 0;
    var ele = tag.eleAt(-1);
    var kind = BSeleKind(tag);
    if (kind != ELEOPEN && kind != ELECLOSE){    // terminal
        ele = tag.eleAt(-2);
    }
    var res = pat_height(ele);   // last parenthesis
    return res;
}

// deliver the minimum height of the elements of the specified BSsymbol, possibly terminated with a terminal
var pat_minsp_idx;           // index of it
function pat_minsp(tag){
    if (tag == null || tag.length() <= 1) return 0;
    var res = Number.MAX_VALUE;
    pat_minsp_idx = 0;
    for (var i = 0; i < tag.length()-1; i++){
        var ele = tag.eleAt(i);
        var kind = BSeleKind(ele);
        if (kind != ELEOPEN && kind != ELECLOSE){    // terminal
            break;
        }
        var v = pat_height(ele);
        if (v < res){
            res = v;
            pat_minsp_idx = i;
        }
    }
    return res;
}

// deliver the minimum height of the BSsymbol alpha trimmed by the prefix common to beta
// except for the last element of the prefix
var pat_bp0_idx;                // the index of it
var pat_bp0_prefix;             // the prefix
function pat_bp0(alpha,beta){
    var lastsp = 0;
    var minsp = 0;
    pat_bp0_idx = 0;
    pat_bp0_prefix = 0;
    var lastidx = 0;
    var len = alpha.length();
    if (beta.length() < len) len = beta.length();
    for (var i = 0; i < len; i++){
        if (alpha.eleAt(i) != beta.eleAt(i)){    // found end of common prefix
            pat_bp0_prefix = i;
            if (i > 0){                          // prefix non-empty
                lastsp = pat_height(alpha.eleAt(i-1));
                lastidx = i - 1;
                trace('o',"pat_bp0 -1-",lastsp,lastidx);
            }
            minsp = Number.MAX_VALUE;
            for (var j = i; j < alpha.length(); j++){
                var v = pat_height(alpha.eleAt(j));
                if (v < minsp){
                    minsp = v;
                    pat_bp0_idx = j;
                    trace('o',"pat_bp0 -2-",minsp,pat_bp0_idx);
                }
            }
            break;
        }
    }
    var res = lastsp;
    if (minsp < res){
        res = minsp;
    } else {
        pat_bp0_idx = lastidx;
    }
    trace('o',"pat_bp0",alpha.toNoHtmlString(),beta.toNoHtmlString(),"= min(",lastsp,",",minsp,")");
    return res;
}

// tell which tag is prior
function pat_comp_tags(t1, t2){
    var bp0t1 = pat_bp0(t1,t2);
    var bp0t2 = pat_bp0(t2,t1);
    if (bp0t1 > bp0t2){
        return -1;                    // t1 prior to t2: t1 <. t2
    }
    if (bp0t2 > bp0t1){
        return 1;                     // t2 prior to t1: t2 <. t1
    }
    // bp0t1 == bp0t2
    return pat_subset_tags(t1,t2);
}

// tell if the first position is prior to the second one (< 0) or equal (= 0) or greater (> 0)
function compareToBSelemPos(e1,e2){
    var p1 = BSeleToAst(e1).pos;
    var p2 = BSeleToAst(e2).pos;
    var n = p1.length;
    if (p2.length < n) n = p2.length;
    var i = 0;
    var j = 0;
    while (n-- != 0){
        var c1 = p1[i++];
        var c2 = p2[j++];
        if (c1 != c2) return c1 - c2;
    }
    return p1.length - p2.length;
}

// tell if the first BSsymbol is â to the second one
var pat_subset_tags_res;
function pat_subset_tags(t1,t2,cmpres){
    // take first element after common prefix
    var len = t1.length();
    if (t2.length() < len) len = t2.length();
    var incl1 = false;
    var incl2 = false;
    var prefix = -1;
    for (var i = 0; i < len; i++){
        if (t1.eleAt(i) != t2.eleAt(i)){           // found end of common prefix
            prefix = i;
            break;
        }
    }
    var firstt1 = -1;
    var firstt2 = -1;
    if (prefix >= 0){
        firstt1 = prefix;
        firstt2 = prefix;
    } else {
        if (len == t1.length() && len < t2.length()){
            firstt2 = len;
        } else if (len == t2.length() && len < t1.length()){
            firstt1 = len;
        }
    }
    trace('o',"pat_subset_tags firstt1",firstt1,"firstt2",firstt2);
    if (firstt1 >= 0) trace('o',"firstt1",BSeleToString(t1.eleAt(firstt1),true));
    if (firstt2 >= 0) trace('o',"firstt2",BSeleToString(t2.eleAt(firstt2),true));
    // determine if t1 <. t2

    if (firstt1 >= 0 &&                    // t1/t2 exists
        BSeleKind(t1.eleAt(firstt1)) == ELEOPEN){    // and is (p
        if (firstt2 < 0){                  // t2/t1 does not exist
            incl1 = true;
            if (cmpres != null) cmpres.sset(1,1,firstt1,firstt2,t1.eleAt(firstt1),0);
        } else {
            if (BSeleKind(t2.eleAt(firstt2)) == ELEOPEN){      // it is (q
                if (compareToBSelemPos(t1.eleAt(firstt1),t2.eleAt(firstt2)) < 0){
                    incl1 = true;
                    if (cmpres != null) cmpres.sset(1,2,firstt1,firstt2,t1.eleAt(firstt1),t2.eleAt(firstt2));
                }
            } else {
                incl1 = true;
                if (cmpres != null) cmpres.sset(1,3,firstt1,firstt2,t1.eleAt(firstt1),t2.eleAt(firstt2));
            }
        }
    }
    if (!incl1){
        // determine if t2 <. t1
        if (firstt2 >= 0 &&                  // t2/t1 exists
            BSeleKind(t2.eleAt(firstt2)) == ELEOPEN){            // and is (p
            if (firstt1 < 0){                // t1/t2 does not exist
                incl2 = true;
                if (cmpres != null) cmpres.sset(2,1,firstt1,firstt2,t1.eleAt(firstt1),0);
            } else {
                if (BSeleKind(t1.eleAt(firstt1)) == ELEOPEN){   // it is (q
                    if (compareToBSelemPos(t2.eleAt(firstt2),t1.eleAt(firstt1)) < 0){
                        incl2 = true;
                        if (cmpres != null) cmpres.sset(2,2,firstt1,firstt2,t1.eleAt(firstt1),t2.eleAt(firstt2));
                    }
                } else {
                    incl2 = true;
                    if (cmpres != null) cmpres.sset(2,3,firstt1,firstt2,t1.eleAt(firstt1),t2.eleAt(firstt2));
                }
            }
        }
    }
    var res = 0;
    if (incl1) res = -1;                 // t1 prior to t2: t1 <. t2
    if (incl2) res = 1;                  // t2 prior to t1: t2 <. t1
    trace('o',"pat_subset_tags",t1.toNoHtmlString(),t2.toNoHtmlString(),"=",res);
    return res;
}

</script>
<script>
// ---------- Choosing the prior  -----------------

// the data representing the comparison of all the tags of the last transition in matching
function priorDataClass(){
    this.B = [];     // rho
    this.D = [];     // â
    this.BA = [];    // audit trail of B
    this.DA = [];    // audit trail of D
}
var priorData;   // the data representing the current comparison

// deliver the ast of the last element of the specified item
function itemAst(item){
    return BSeleToAst(item.sym.eleAt(-1));
}

// deliver the tag of the specified item (a BSsymbol with the last terminal removed)
function itemTag(item){
    return item.sym.substring(0,item.sym.length()-1);
}

// deliver the terminal ending the specified item
function itemTerminal(item){
    return BSeleToAst(item.sym.eleAt(-1)).sym;
}

// deliver an object representing a transition
function getTrans(pnode,i){
    if (pnode.activeIids[i] < 0){
        trace('m',"getTrans",i,"no trans");
        return;
    }
    var prev = pnode.next;
    var p = null;                   // ast of from state
    if (prev == null){              // pnode for the initial state
        p = astRoot;
    } else {
        trace('m',"getTrans--",pnode,i,"act",pnode.activeIids[i]);
        p = itemAst(prev.from.items[pnode.activeIids[i]]);
    }
    var item = pnode.from.items[i];
    var q = itemAst(item);          // to state
    var tag = itemTag(item);

    trace('m',"getTrans",posToString(p.pos),
        "--",item.sym,"-->",posToString(q.pos));
    return {"from":p,"to":q,"tag":tag,"item":item};
}

// deliver a string representing the specified transition
function transToString(t){
    return posToString(t.from.pos) +
        "--" + t.item.sym + "-->" + posToString(t.to.pos)
}

// mark the steps done in the specified pnode on the active paths, choosing the most prior
// one when there are several converging on a same node in the path
function effectiveTrans(data,pnode,dashb,test,n){
    trace('m',"effectiveTransitions",pnode);
    var from = pnode.from;
    var to = pnode.to;
    var prev = pnode.next;
    if ('m' in trc){
        pnode.trace();
    }

    for (var i = 0; i < to.items.length; i++){
        // trace('m',"effectiveTransitions item",i);
        choose: {
            if (pnode.suc != null && pnode.suc.iidNodes[i] == null) continue;   // item not belonging to any path
            var arr = to.items[i].left.toArray();
            var winner = arr[0];
            if (arr.length <= 1){                        // no convergence
                break choose;
            }
            var rho = -1;
            var rhop = -1;
            for (var j = 1; j < arr.length; j++){
                // compare the winner and the current one
                var p = arr[j];
                var pp = winner;
                var B = data.B[p][pp];
                rho = B[0];
                rhop = B[1];

                trace('m',"effectiveTransitions p",p,"pp",pp,"B",rho,rhop);
                rho = Math.min(rho,pat_minsp(from.items[p].sym));
                rhop = Math.min(rhop,pat_minsp(from.items[pp].sym));
                var D = data.D[pp][p];
                trace('m',"effectiveTransitions competing trans",
                    "<"+p+","+i+","+itemTag(from.items[p]).toNoHtmlString()+">",
                    "<"+pp+","+i+","+itemTag(from.items[pp]).toNoHtmlString()+">",
                    "rho",rho,"rhop",rhop,"D["+pp+"]["+p+"]",D);
                if ('m' in trc){
                    tracePaths(pnode,p,pp);
                }
                if (rho < rhop){
//twriteln("diff rhos");
                    winner = pp;
                } else if (rho > rhop){
//twriteln("diff rhos");
                    winner = p;
                } else if (D == 1){
//twriteln("diff D");
                    winner = pp;
                } else {
//twriteln("diff D?",D);
                    winner = p;
                }
                trace('m',"effectiveTransitions winner",winner);
            }
        } // choose
        pnode.activeIids[i] = winner;         // active iid
        trace('m',"effectiveTransitions item",i,"activeIids",pnode.activeIids[i]);

        if (!test){
            // the winner: item winner, transition from winner (from state) to i (to state)
            // get trans, and set its serial
            var newt;
            if (pnode.suc == null){          // last one
                newt = new IidEdgeClass();
                newt.fromState = pnode.from;
                newt.fromItem = winner;
                newt.toState = pnode.to;
                newt.toItem = 0;
            } else {
                newt = pnode.suc.iidNodes[i].getEdge(pnode.iidNodes[winner]);
            }
            newt.seq = IidEdgeSeq++;
            newt.tag = from.items[winner].sym.tag();
            // take the one that is not dead
            for (var j = pnode.iidNodes[winner].edgelist; j != null; j = j.next){
                var edg = j.val;
                if (edg.seq >= 0){
                    newt.prev = edg;
                    break;
                }
            }
            dashb.push(newt);
            trace('m',"effectiveTransitions winner",newt,newt.tag.toNoHtmlString());
            // all the others, each with the pair of rho, or if equal the D
            var p = winner;
            for (var j = 0; j < arr.length; j++){
                var pp = arr[j];
                if (pp == winner) continue;
                var B = data.B[p][pp];
                rho = B[0];
                rhop = B[1];
                rho = Math.min(rho,pat_minsp(from.items[p].sym));
                rhop = Math.min(rhop,pat_minsp(from.items[pp].sym));
                var nt;
                if (pnode.suc == null){          // last one
                    nt = new IidEdgeClass();
                    nt.fromState = pnode.from;
                    nt.fromItem = pp;
                    nt.toState = pnode.to;
                    nt.toItem = 0;
                } else {
                    nt = pnode.suc.iidNodes[i].getEdge(pnode.iidNodes[pp]);
                }
                nt.seq = -1;
                nt.tag = from.items[pp].sym.tag();
                // take the one that is not dead
                for (var j = pnode.iidNodes[pp].edgelist; j != null; j = j.next){
                    var edg = j.val;
                    if (edg.seq >= 0){
                        nt.prev = edg;
                        break;
                    }
                }
                trace('m',"effectiveTransitions loser",nt,nt.tag.toNoHtmlString());
                dashb.push(nt);
                var strl = "";
                strl += " because: ";

                var strs = "";
                // determine the origin of rho and D
                var pa = data.B[p][pp];
                var prevrho = pa[0];
                var prevrhop = pa[1];                   // <rho, rho'> = B[p][p']
                var updrho = pat_minsp(from.items[p].sym);
                var updrhop = pat_minsp(from.items[pp].sym);
                var rho = Math.min(prevrho,updrho);
                var rhop = Math.min(prevrhop,updrhop);
                var hooks = {"t":newt,"tp":nt,"n":n};   // to show the history
                trace('m',"effectiveTransitions loser",rho,rhop,p,pp,data.D[p][pp]);
                if (rho > rhop){
                    // looses because of rho
                    var gb = null;
                    if (prevrho > updrho){
                        // rho here
                        hooks.w = newAudit(9,n,rho,data.BA[p][pp][1],newt,nt);
                        gb = getB(hooks.w);
                    } else {
                        // rho from prev
                        hooks.w = data.BA[p][pp][0];
                        gb = getB(hooks.w);
                    }
                    strs += gb[0];                     // short reason
                    strs += " \u22d6 ";
                    strl += "<br>Ï<sub>" + newt.serial() + "</sub> = " + rho + ": " + gb[1];
                    if (prevrhop > updrhop){
                        // rhop here
                        hooks.wp = newAudit(9,n,rhop,data.BA[p][pp][1],nt,newt);
                        gb = getB(hooks.wp);
                    } else {
                        // rhop from prev
                        hooks.wp = data.BA[p][pp][1];
                        gb = getB(hooks.wp);
                    }
                    strs += gb[0];                      // short reason
                    strl += "<br>Ï<sub>" + nt.serial() + "</sub> = " + rhop + ": " + gb[1];
                } else if (data.D[p][pp] == 1){
                    // looses because of D
                    trace('o',"effectiveTransitions D",p,pp);
                    var da = data.DA[p][pp];
                    hooks.w = da;
                    hooks.wp = da;
                    gb = getD(da);
                    strs += gb[0];             // short reason
                    strl += "Ï<sub>" + newt.serial() + "</sub>, Ï<sub>" + nt.serial() + "</sub> = " + rho;
                    strl += " but once"
                    strl += "<br>" + gb[1];             // long reason
                }
                dashb.push([strs,strl,hooks]);
                trace('o',"effectiveTransitions reason",strs,"long",strl);
            }
        }
    }
    trace('m',"effectiveTransitions res",pnode);
    if ('m' in trc){
        pnode.trace();
    }
}

// build an array of the tags of the transitions that end in i
function transPath(pnode, i){
    var arr = [];
    for (; pnode != null; pnode = pnode.next){
        var tag = itemTag(pnode.from.items[i]);
        arr.push(tag);
        if (pnode.next != null){
            i = pnode.next.activeIids[i];
        }
    }
    arr.reverse();
    return arr;
}

// trace the paths starting in the specified items of the "from" state of pnode and working backwards
function tracePaths(pnode, i, j){
    var arr1 = transPath(pnode,i);
    var arr2 = transPath(pnode,j);

    var str = "";
    for (var i = 0; i < arr1.length; i++){
        str += arr1[i].toNoHtmlString();
    }
    twriteln("first",str);
    str = "";
    for (var i = 0; i < arr2.length; i++){
        str += arr2[i].toNoHtmlString();
    }
    twriteln("second",str);
    var rho1 = [];
    var cmpres = new compareTreesRes();
    var fork = tr(arr1,arr2,rho1,cmpres,1);

    var rho2 = [];
    tr(arr2,arr1,rho2,cmpres,2);
    var cmp = compareFrames(rho1,rho2,arr1,arr2,fork,cmpres);
    if (cmp < 0){
        twriteln("first prior");
    } else if (cmp > 0){
        twriteln("second prior");
    } else {
        twriteln("!!! uncomparable paths\n");
    }
}

// the comparison of two trees
function compareTreesRes(){
    this.winner = 0;
    this.isRho = false;
    this.rho1 = 0;
    this.rho2 = 0;
    this.frame = 0;       // frame at which the comparison of rho decreed the winner
    this.fork = 0;
    this.bp01 = 0;        // index of min at fork
    this.bp02 = 0;
    this.rhodown1 = 0;    // index of tail of equal rhos
    this.rhodown2 = 0;
    this.minsp1 = 0;      // index of min in rhodown or in fork
    this.minsp2 = 0;
    this.isSubset;
    this.subskind = 0;    // 1: t2/t1 does not exist, 2: exists and is (q<.p, 3: exists and is )q
    this.subs1 = 0;
    this.subs2 = 0;
    this.set = function(winner,isRho,rho1,rho2,frame){
        this.winner = winner;
        this.isRho = true;
        this.rho1 = rho1;
        this.rho2 = rho2;
        this.frame = frame;
    }
    this.sset = function(winner,kind,subs1,subs2,ele1,ele2){
        this.winner = winner;
        this.isRho = false;
        this.isSub = true;
        this.subskind = kind;
        this.subs1 = subs1;
        this.subs2 = subs2;
        this.ele1 = ele1;
        this.ele2 = ele2;
    }
    this.toString = function(){
        var str = "winner: " + this.winner;
        if (this.isRho){         // because of rho
            str += " rho: " + this.rho1 + ", " + this.rho2 + " at frame: " + this.frame;
            str += " fork: " + this.fork + " min at fork: " + this.bp01 + ", " + this.bp02;
            str += " down at frames: " + this.rhodown1 + "(min at: " + this.minsp1 + "),";
            str += this.rhodown2 + "(min at: " + this.minsp2 + ")";
        } else {
            str += " kind: " + this.subskind + " subs: " + this.subs1 + ", " + this.subs2;
        }
        return str;
    }
}

// compare the specified frames for their rhos first and their subsetting
// arr1, arr2 arrays of tags or symbols
function compareFrames(rho1,rho2,arr1,arr2,fork,cmpres){
    trace('o',"compareFrames",cmpres);
    var res = 0;
    // n.b. the paths have the same length because they recognized the same string
    var prior1 = false;
    var prior2 = false;
    for (var i = rho1.length-1; i >= 0; i--){
        if (rho1[i] > rho2[i]){
            prior1 = true;
            cmpres.set(1,true,rho1[i],rho2[i],i);
            break;
        } else if (rho2[i] > rho1[i]){
            cmpres.set(2,true,rho1[i],rho2[i],i);
            prior2 = true;
            break;
        }
    }
    if (!prior1 && !prior2){
        var cmp = pat_subset_tags(arr1[fork].getTag(),arr2[fork].getTag(),cmpres);
        if (cmp < 0){
            prior1 = true;
        } else if (cmp > 0){
            prior2 = true;
        }
    }
    if (prior1){
        res = -1;
    } else if (prior2){
        res = 1;
    }
    trace('o',"compareFrames res",res,cmpres);
    return res;
}

// arr1, arr2 array of tags or symbols
function tr(arr1,arr2,rho1,cmpres,which){
    trace('o',"tr");
    var fork = 0;
    var rho = -1;
    for (var i = 0; i < arr1.length; i++){
        var t1 = arr1[i].getTag();
        var t2 = arr2[i].getTag();
        trace('o',"tr",i,"equals",t1.equals(t2),
            t1.toNoHtmlString(),"==",t2.toNoHtmlString());
        if (!t1.equals(t2) && (rho < 0)){
            rho = pat_bp0(t1,t2);
            fork = i;
            if (which == 1){
                cmpres.bp01 = pat_bp0_idx;
                cmpres.rhodown1 = i;
                cmpres.minsp1 = cmpres.bp01;
            } else {
                cmpres.bp02 = pat_bp0_idx;
                cmpres.rhodown2 = i;
                cmpres.minsp2 = cmpres.bp02;
            }
        } else if (rho >= 0){
            var r = Math.min(rho,pat_minsp(t1));
            if (r != rho){
                if (which == 1){
                    cmpres.rhodown1 = i;
                    cmpres.minsp1 = pat_minsp_idx;
                } else {
                    cmpres.rhodown2 = i;
                    cmpres.minsp2 = pat_minsp_idx;
                }
            }
            rho = r;
        }
        rho1[i] = rho;
    }
    cmpres.fork = fork;
    cmpres.isRho = true;      // for the time being, possibly redefined later
    trace('o',"tr res",cmpres);
    return fork;
}

// update the values that represent the previous comparisons
function proceedOneStep(data,n,pnode){
    trace('m',"proceedOneStep step pnode");
    if ('m' in trc){
        pnode.trace();
    }
    var prev = data;
    data = new priorDataClass();
    // take all the path steps from the from state to the next one, considering only
    // the ones with the iid's computed by effectiveTrans
    var from = pnode.from;
    // the check on q <. q' in the paper serves only to make sure to compare two transitions
    // only once instead of twice (the second time swapping them)

    var to = pnode.to;
    for (var i = 1; i < to.items.length; i++){
        if (pnode.suc != null && pnode.suc.iidNodes[i] == null) continue;         // item not belonging to any path
        var q = i;
        var p = pnode.activeIids[q];
        var ptrans = pnode.suc.iidNodes[q].getEdge(pnode.iidNodes[p]);
        var porig;
        if (pnode.next != null){
            porig = pnode.next.activeIids[p];      // origin, to check that pp below is the same step
        }
        var alpha = itemTag(pnode.from.items[p]);
        for (var j = 0; j < i; j++){
            if (pnode.suc != null && pnode.suc.iidNodes[j] == null) continue;         // item not belonging to any path
            var qp = j;
            var pp = pnode.activeIids[qp];
            var pptrans = pnode.suc.iidNodes[qp].getEdge(pnode.iidNodes[pp]);
            var alphap = itemTag(pnode.from.items[pp]);
            trace('m',"proceedOneStep","<"+p+","+q+","+alpha.toNoHtmlString()+">",
                "<"+pp+","+qp+","+alphap.toNoHtmlString()+">");
            var rho = 0;
            var rhop = 0;
            // check that the items have the same origin in the previous pnode
            var pporig;
            if (pnode.next != null){
                pporig = pnode.next.activeIids[pp];
            }

            if (porig == pporig || pnode.next == null){              // p = p'
                // here we have two transitions from the same item leading to different items
                // probably I could compare instead their active iid's
                if (alpha.equals(alphap)){
                    continue;
                }
                var cmp = pat_subset_tags(alpha,alphap,null);
                trace('m',"proceedOneStep",
                    alpha.toNoHtmlString(),alphap.toNoHtmlString(),
                    ":",cmp < 0 ? "prior" : "not prior");
                // to compare two tags, take away the common prefix, then the first
                // is prior if it starts with (p and the second: starts with )q or
                // with (q with p <. q

                rho = pat_bp0(alpha,alphap);    // rho = bp0(alpha,alpha');
                rhop = pat_bp0(alphap,alpha);   // rho' = bp0(alpha',alpha)
                if (data.D[q] == null) data.D[q] = [];
                if (rho > rhop){
                    data.D[q][qp] = 1;               // D[q][q'] = 1 if rho > rho';
                    mSet(data.DA,q,qp,newAudit(3,n,rho,rhop,ptrans,pptrans));
                } else if (rho < rhop){
                    data.D[q][qp] = -1;              // D[q][q'] = -1 if rho < rho';
                    mSet(data.DA,qp,q,newAudit(3,n,rhop,rho,pptrans,ptrans));
                } else if (cmp < 0){
                    data.D[q][qp] = 1;               // D[q][q'] = 1 if alpha â alpha';
                    mSet(data.DA,q,qp,newAudit(1,n,rho,rhop,ptrans,pptrans));
                } else if (cmp > 0){
                    data.D[q][qp] = -1;              // D[q][q'] = 1 if alpha â alpha';
                    mSet(data.DA,qp,q,newAudit(1,n,rhop,rho,pptrans,ptrans));
                }
                var wrho = newAudit(8,n,rho,rhop,ptrans,pptrans);
                var wrhop = newAudit(8,n,rhop,rho,pptrans,ptrans);
                mSet(data.BA,q,qp,[wrho,wrhop]);
                mSet(data.BA,qp,q,[wrhop,wrho]);
            } else {
                var Bp = prev.B[p][pp];                   // assign rho and rho': <rho, rho'> = B'[p][p']
                rho = Bp[0];
                rhop = Bp[1];
                trace('m',"proceedOneStep distinct start rho",rho,rhop);
                var mrho = pat_minsp(alpha);
                rho = Math.min(rho,mrho);                 // rho = min{rho, minsp(alpha)};
                var mrhop = pat_minsp(alphap);
                rhop = Math.min(rhop,mrhop);              // rho' = min{rho', minsp(alpha')};
                var wrho = prev.BA[p][pp][0];
                if (mrho < Bp[0]){                        // new rho
                    wrho = newAudit(9,n,rho,prev.BA[p][pp][0],ptrans,pptrans);
                }
                var wrhop = prev.BA[p][pp][1];
                if (mrhop < Bp[1]){        // new rhop
                    wrhop = newAudit(9,n,rhop,prev.BA[p][pp][1],pptrans,ptrans);
                }
                mSet(data.BA,q,qp,[wrho,wrhop]);
                mSet(data.BA,qp,q,[wrhop,wrho]);

                if (data.D[q] == null) data.D[q] = [];
                if (rho > rhop){
                    data.D[q][qp] = 1;               // D[q][q'] = 1 if rho > rho';
                    mSet(data.DA,q,qp,newAudit(6,n,rho,rhop,ptrans,pptrans,wrho,wrhop));
                } else if (rho < rhop){
                    data.D[q][qp] = -1;              // D[q][q'] = -1 if rho < rho';
                    mSet(data.DA,qp,q,newAudit(6,n,rhop,rho,pptrans,ptrans,wrhop,wrho));
                } else {
                    data.D[q][qp] = prev.D[p][pp];   // D[q][q'] = D'[p][p']
                    if (prev.DA[p] != null){
                        mSet(data.DA,q,qp,prev.DA[p][pp]);
                    }
                    if (prev.DA[pp] != null){
                        mSet(data.DA,qp,q,prev.DA[pp][p]);
                    }
                }
            }
            mSet(data.D,qp,q,-data.D[q][qp]);   // D[q'][q] = -D[q][q']
            mSet(data.B,q,qp,[rho,rhop]);       // B[q][q'] = <rho, rho'>;
            mSet(data.B,qp,q,[rhop,rho]);       // B[q'][q] = <rho', rho>

            trace('m',"proceedOneStep res",
                priorDataToString("B",data.B,q,qp,data.B[q][qp]),
                priorDataToString("D",data.D,q,qp,data.D[q][qp]));
        }
    }
    trace('m',"proceedOneStep end");
    return data;
}

// deliver a string representing the specified value
function priorDataToString(name,arr,i,j,val){
    var str = name + "[" + i + "][" + j + "]: " + val;
    return str;
}

// ---------- Enumerating the paths ---------

// deliver a list of paths; each path is a list of steps

// construction of a graph with one node for each item of the list of pnodes belonging
// to a tree, and a transition from each node to the nodes of the items denoted by its
// iids. This graph serves to enumerate all the paths, each one denoting a valid parse tree

// deliver a list of the iids of the specified item of the specified from state in pnode:
// it is a list of edges (StepClass)
function iidSetToList(pnode,itm){
    trace('t',"iidSetToList",pnode,itm);
    if (pnode == null) return null;
    var list = new LinkedList();
    var arr = pnode.from.items[itm].left.toArray();
    for (var i = 0; i < arr.length; i++){
        var el = new StepClass();
        el.from = pnode;
        el.fromItem = itm;
        el.to = pnode.next;
        el.toItem = arr[i];
        list.add(el);
    }
    trace('t',"iidSetToList ret",el.fromItem);
    return list.head;
}

var iidNodeHead;       // the head of nodes
var iidNodeSeq;        // the serial number of the nodes

// a node
function IidNodeClass(){
    this.next = iidNodeHead;
    iidNodeHead = this;
    this.seq = iidNodeSeq++;
    this.edgelist = null;

    // deliver a string representing this node
    this.toString = function(){
        var str = this.seq + " edges:";
        for (var i = this.edgelist; i != null; i = i.next){
            str += " " + i.val;
        }
        return str;
    }

    // deliver the edge from this node to the specified one
    this.getEdge = function(to){
        var res = null;
        for (var i = this.edgelist; i != null; i = i.next){
            if (i.val.to == to){
                res = i.val;
                break;
            }
        }
        return res;
    }
}

// an edge
function IidEdgeClass(){
    // this.name = "";
    this.from = null;
    this.to = null;
    this.fromState = null;
    this.fromItem = 0;
    this.toState = null;
    this.toItem = 0;
    this.item = null;
    this.toString = function(){
        var str = this.serial() + ": ";
        // str += this.name + " ";
        str += this.fromState.number + "/" + this.fromItem;
        if (this.toState == null){
            str += ":initial";
        } else {
            str += "->" + this.toState.number + "/" + this.toItem;
        }
        return str;
    }

    // fields for the dashboard
    this.seq = 0;              // serial number, only for tracing
    this.prev = null;          // reference to previous transition
    this.tag = newBSsymbol();  // tag
    this.isFinal = false;      // whether this transition belong to the path of the prior tree

    // deliver a string representing the serial nr of this transition
    this.serial = function(){
        var str = "";
        if (this.seq < 0){
            str += "â ";
        } else {
            str += this.seq;
        }
        return str;
    }

    // clone this object
    this.clone = function(){
        var n = new IidEdgeClass();
        for (var i in this){
            n[i] = this[i];
        }
        return n;
    }
}
var IidEdgeSeq;    // serial numbers of IidEdgeClass objects

// deliver a string representing a path
function iidPathToString(root){
    var str = "";
    for (var i = root.head; i != null; i = i.next){
        var ele = i.val.val;
        str += ele.fromState.number + "/" + ele.fromItem + ":";
        str += bsItemToString(ele.item,true);
        if (i.next != null){
            str += "--> ";
        }
    }
    return str;
}

// trace the graph
function tracegraph(){
    for (var i = iidNodeHead; i != null; i = i.next){
        var str = "node " + i.seq;
        for (var j = i.edgelist; j != null; j = j.next){
            var e = j.val;
            var from = e.fromState ? e.fromState.number : "?";
            var to = e.toState ? e.toState.number : "init";
            str += " " + from + "/" + e.fromItem + "->" +
               // e.name + "->" +
               to + "/" + e.toItem + "(" + e.to.seq + ")";
        }
        twriteln(str);
    }
}

// deliver all the paths
function getPaths(pnode){
    trace('t',"getPaths",pnode);
    if ('t' in trc){
        for (var i = pnode; i != null; i = i.next){
            twriteln("getPaths pnode",i);
        }
    }

    // scan the last pnode and for each item that ends in eof create a node and store it in
    // an array associated to the pnode. Then scan the pnode again and for each item that has a
    // node, go to the previous pnode ad create a node for all the iids of the item (if that
    // node does not exist), and create an edge for each iid; repeat for all the pnodes.

    iidNodeHead = null;
    iidNodeSeq = 0;
    // var cnt = 0;
    // create nodes for the items that end in eof
    for (var i = 0; i < pnode.from.items.length; i++){
        var item = pnode.from.items[i];
        var ast = itemAst(item);
        if (ast.sym != EOF) continue;
        if (pnode.from.items[i].left.size() == 0) continue;  // no iids
        pnode.iidNodes[i] = new IidNodeClass();
        trace('t',"getPaths eof state",pnode.from.number,i,"node",pnode.iidNodes[i]);
    }
    var initial = new IidNodeClass();              // fake node for the end of paths
    trace('t',"getPaths initial node",initial);
    initial.to = null;
    for (var p = pnode; p != null; p = p.next){
        trace('t',"getPaths pnode",p);
        for (var i = 0; i < p.from.items.length; i++){
            trace('t',"getPaths pnode item",i);
            var node = p.iidNodes[i];
            if (node != null){
                var list = new LinkedList();
                var iids = p.from.items[i].left.toArray();
                for (var j = 0; j < iids.length; j++){
                    var iid = iids[j];
                    if (p.next != null){
                        if (p.next.iidNodes[iid] == null){
                            p.next.iidNodes[iid] = new IidNodeClass();
                        }
                        trace('t',"getPaths node in next",p.next.iidNodes[iid],
                            "next",p.next,"iid",iid);
                    }
                    var edge = new IidEdgeClass();
                    // edge.name = "e" + cnt++;
                    edge.from = node;
                    if (p.next == null){
                        edge.to = initial;
                    } else {
                        edge.to = p.next.iidNodes[iid];
                    }
                    edge.fromState = p.from;
                    edge.fromItem = i;
                    if (p.next != null){
                        edge.toState = p.next.from;
                        edge.toItem = iid;
                    }
                    edge.item = p.from.items[i];
                    list.add(edge);
                }
                node.edgelist = list.head;
                trace('t',"getPaths new node",node.toString());
            }
        }
    }
    if ('t' in trc){
        tracegraph();
    }

    var paths = new LinkedList();

    // take all items in pnode.from that end with eof and from each build all paths

    var cnt = 0;
    trace('t',"getPaths traversal",pnode);
    for (var i = 0; i < pnode.from.items.length; i++){
        var node = pnode.iidNodes[i];
        if (node == null) continue;

        var lev = 0;                                // level: it serves only for tracing
        var path = new LinkedList();
        var pd = node.edgelist;                // start with the first edge
        trace('t',"getPaths start traversal from",i,node,pd);
        var first = true;
        allph: for (;;){                            // visit all paths
            up: if (first){
                trace('t',"getPaths first");
                if (pd == null) break allph;
                path.add(pd);                       // start with the first edge
                lev++;
                first = false;
            } else {
                trace('t',"getPaths next path",lev);
                // build next path
                // go up until it is possible to go sideways
                while (lev > 0){
                    pd = path.pollLast();
                    lev--;
                    trace('t',"getPaths -path up- lev",lev,"edg",pd.val,"sideways",
                        pd.next == null ? "" : pd.next.val);
                    pd = pd.next;
                    if (pd != null){
                        path.add(pd);
                        lev++;
                        break up;
                    }
                }
                break allph;               // no more paths
            }
            // go down to bottom
            for (;;){
                var down = pd.val.to.edgelist;
                trace('t',"getPaths -path down- lev",lev,"edg",pd.val,"down",
                    down == null ? "" : down.val);
                if (down == null) break;
                path.add(down);
                lev++;
                pd = down;
            }

            var p = new LinkedList();
            for (var j = path.tail; j != null; j = j.prev){   // clone the reversed path
                p.add(j.val);
            }
            paths.add(p);

            if ('t' in trc){
                var str = "path lev " + lev;
                var p = path.head;
                for (var l = 0; l < lev; l++){
                    str += " " + p.val;
                    p = p.next;
                }
                twriteln(str);
            }
        }
    }
    if ('t' in trc){
        twriteln("getPaths paths:");
        for (var i = paths.head; i != null; i = i.next){
            twriteln("    ",iidPathToString(i.val));
        }
    }
    return paths;
}

// deliver an array of the BSsymbols of the steps in the specified path
function pathToArray(path){
    var arr = [];
    for (var p = path.head; p != null; p = p.next){
        var ele = p.val.val;
        var tag = ele.item.sym;
        arr.push(tag);
    }
    return arr;
}

// deliver an array of the states/item numbers of the steps in the specified path
function pathToIndexes(path){
    var arr = [];
    for (var p = path.head; p != null; p = p.next){
        var ele = p.val.val;
        var str = ele.fromState.number + "#" + ele.fromItem;
        arr.push(str);
    }
    return arr;
}

// ---------- Comparing trees ---------

// paths head ->ListElem    -----path--------
//                val ----> head --> ListElem    --------step in path---------
//                next: next path     val ----> ListElem
//                                                  val ---> edge: IidEdgeClass
//                                    next: next step

// compare the trees using all methods, and check that they produce the same result
function compareTrees(test,head,text){
    trace('o',"compareTrees");
    var paths = getPaths(head);
    var winner = compareBasic(test,paths);
    var patWinner = null;
    if (document.getElementById("posixprio").checked){
        patWinner = comparePat(head,test,text);
        if (!patWinner.equals(winner)){
            if (!test){
                // alert(patWinner.toNoHtmlString() + " pat winner wrong, winner: " + winner.toNoHtmlString());
            }
            error = true;
            errorMessage = "pat winner wrong";
            trace('o',"compareTrees pat wrong");
        }
        var llongWinner = compareLlong(head);
        if (!llongWinner.equals(winner)){
            error = true;
            errorMessage = "leftmost longest winner wrong";
            trace('o',"compareTrees llong wrong");
        }
    } else {
        patWinner = compareGreedy(head,test,text);
    }

    // display now all the paths, with a non-purged dfa
    doit: if (!test){
        var dfa = buildBS(astRoot,"none");    // no purge
        if (error) break doit;
        var list = match(false,text,dfa);
        var paths = getPaths(list);

        var el = document.getElementById("parenthtrees");
        var str = "<table>";
        var seq = 0;
        for (var i = paths.head; i != null; i = i.next){
            str += "<tr><td>" + seq++ + ":</td><td>";
            for (var j = i.val.head; j != null; j = j.next){
                var ele = j.val.val;
                if (j.next == null){    // last one
                    str += itemTag(ele.item);
                } else {
                    str += ele.item.sym;
                }
            }
            str += "</td></tr>";
        }
        str += "</table>";
        el.innerHTML = str;

        if (document.getElementById("showAllTrees").checked){
            // show all trees
            document.getElementById("alltrees").style.display = "block";
            var trees = document.getElementById("trees");
            trees.innerHTML = "";
            for (var i = paths.head; i != null; i = i.next){
                var linearTree = newBSsymbol();
                for (var j = i.val.head; j != null; j = j.next){
                    var ele = j.val.val;
                    var s = null;
                    if (j.next == null){    // last one
                        linearTree = newBSsymbol(linearTree,itemTag(ele.item));
                    } else {
                        linearTree = newBSsymbol(linearTree,ele.item.sym);
                    }
                }
                // transform the linear tree into a tree
                trace('t',"compareTrees linear tree",linearTree.toNoHtmlString());
                var root = buildTree1(linearTree);
                trees.innerHTML += "&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style=\"display:inline-block;vertical-align:top;\">" +
                    drawTree(root,trees) + "</span>";    // appends a new svg
            }
        }
    }
    return winner;
}

// compare the trees using the basic methods, i.e. tr() and ||t||
function compareBasic(test,paths){
    var el = document.getElementById("compareparenth");
    var str = "<table class=rho border=\"1\">";
    var arr1 = pathToArray(paths.head.val);
    if ('o' in trc){
        twriteln("arr1");
        for (var i = 0; i < arr1.length; i++){
            twriteln(i,arr1[i].toNoHtmlString());
        }
    }
    var steps1 = pathToIndexes(paths.head.val);
    var first = 0;
    var second = 0;
    var buckets = 0;
    var tree = null;
    for (var p = paths.head.next; p != null; p = p.next){
        second++;
        var arr2 = pathToArray(p.val);
        var steps2 = pathToIndexes(p.val);
        if ('o' in trc){
            twriteln("arr2");
            for (var i = 0; i < arr2.length; i++){
                twriteln(i,arr2[i].toNoHtmlString());
            }
        }
        var cmpres = new compareTreesRes();
        var rho1 = [];
        var fork = tr(arr1,arr2,rho1,cmpres,1);
        var rho2 = [];
        tr(arr2,arr1,rho2,cmpres,2);
        var cmp = compareFrames(rho1,rho2,arr1,arr2,fork,cmpres);
        trace('o',"compareTrees fork",cmpres);

        var prefix = 0;
        var a1fork = arr1[fork];
        var a2fork = arr2[fork];
        var len = Math.min(a1fork.length(),a2fork.length());
        for (var i = 0; i < len; i++){
            if (a1fork.eleAt(i) != a2fork.eleAt(i)){           // found end of common prefix
                if (i > 0) prefix = i;
                break;
            }
        }
        var join = arr1.length;
        for (var i = join-1; i >= 0; i--){
            var t1 = arr1[i].getTag();
            var t2 = arr2[i].getTag();
            if (!t1.equals(t2)){
                join = i + 1;
                break;
            }
        }
        trace('o',"compareTrees prefix",a1fork.toNoHtmlString(),
            a2fork.toNoHtmlString(),prefix,join);
        trace('o',"compareTrees draw",cmpres);

        str += toTableRow(arr1,fork,prefix,1,cmpres,cmp<0?"prior":"â ",first,join,steps1);
        str += toTableRow1(rho1,1,cmpres,first,second);
        str += toTableRow(arr2,fork,prefix,2,cmpres,cmp>0?"prior":"â ",second,join,steps2);
        str += toTableRow1(rho2,2,cmpres,first,second);
        buckets++;

        // now compare the trees comparing the yields

        trace('o',"compareTrees yields");
        var cmpstr = "";
        var tree1 = new BSsymbol();
        for (var i = 0; i < arr1.length; i++){
            tree1.concat(arr1[i]);
        }
        var tree2 = new BSsymbol();
        for (var i = 0; i < arr2.length; i++){
            tree2.concat(arr2[i]);
        }

        var tree1i = 0;
        var tree2i = 0;
        var cmptrees = 0;
        for (;;){
            if (tree1i >= tree1.length()) break;
            if (tree2i >= tree2.length()) break;
            var e1 = tree1.eleAt(tree1i);
            var e2 = tree2.eleAt(tree2i);
            if (BSeleKind(e1) != ELEOPEN){
                tree1i++;
                continue;
            }
            if (BSeleKind(e2) != ELEOPEN){
                tree2i++;
                continue;
            }
            var pos1 = BSeleToAst(e1).pos;
            var pos2 = BSeleToAst(e2).pos;
            var comp = compareToBSelemPos(e1,e2);
            if (comp == 0){
                // compare yields
                var y1 = getNorm(tree1,tree1i);
                var y2 = getNorm(tree2,tree2i);
                trace('o',"compareTrees = pos","||"+BSeleToString(e1,true)+"|| = ",y1,
                    ", ||"+BSeleToString(e2,true)+"|| = ",y2);
                if (y1 > y2){
                    cmptrees = -1;
                    cmpstr = "||t<sup>" + first + "</sup>||" + posToSub(pos1) + " = " + y1 +
                        " &gt; ||t<sup>" + second + "</sup>||" + posToSub(pos2) + " = " + y2;
                    break;
                } else if (y2 > y1){
                    cmptrees = 1;
                    cmpstr = "||t<sup>" + second + "</sup>||" + posToSub(pos2) + " = " + y2 +
                        " &gt; ||t<sup>" + first + "</sup>||" + posToSub(pos1) + " = " + y1;
                    break;
                }
            } else {
                trace('o',"compareTrees <> pos",BSeleToString(e1,true),BSeleToString(e2,true),comp);
                if (comp < 0){
                    cmpstr = "t<sup>" + first + "</sup>" + posToSub(pos1) +
                        " \u22d6 t<sup>" + second + "</sup>" + posToSub(pos2);
                } else if (comp > 0){
                    cmpstr = "t<sup>" + second + "</sup>" + posToSub(pos2) +
                        " \u22d6 t<sup>" + first + "</sup>" + posToSub(pos1);
                }
                cmptrees = comp;
                break;
            }
            tree1i++;
            tree2i++;
        }
        if (cmptrees == 0){
            if (tree1i >= tree1.length() && tree2i >= tree2.length()){
                // identical
                if (!test){
                    alert("identical trees");
                }
            } else if (tree1i >= tree1.length()){
                trace('o',"compareTrees tree1 shorter");
                cmpstr = "t<sup>" + first + "</sup> shorter";
                cmptrees = 1;
            } else {
                trace('o',"compareTrees tree2 shorter");
                cmpstr = "t<sup>" + second + "</sup> shorter";
                cmptrees = -1;
            }
        }
        if (cmp != cmptrees){
            if (!test){
                alert("different prior");
            }
        }
        if (cmp < 0){
            tree = tree1;
        } else {
            tree = tree2;
        }
        if (cmp > 0){
            arr1 = arr2;
            steps1 = steps2;
            first = second;
        } else if (cmp == 0){
            twriteln("uncomparable");
        }
        str += "<tr><td colspan=" + (arr1.length*2+2) + " bgcolor=Aquamarine>" + cmpstr + "</td></tr>";
    }
    str += "</table>";
    if (buckets > 0){
        // legenda
        str += "<p style=\"font-size:9pt;\">Legenda: <span style=\"background-color:Lavender;\">common prefix and suffix</span>, " +
            "<span style=\"background-color:Aqua;\">node that sets/updates &rho; or \u228f</span>, " +
            "<span style=\"background-color:LightCoral;\">winner &rho;/\u228f</span>, items: state#item-nr";
    }
    if (!test){
        if (document.getElementById("basicCompare").checked){
            el.innerHTML = str;
        } else {
            el.innerHTML = "";
        }
    }
    if (paths.head.next == null){     // only one
        tree = new BSsymbol();
        for (var i = 0; i < arr1.length; i++){
            var ele = arr1[i]
            tree.concat(ele);
        }
    }
    trace('o',"compareTrees res",tree.toNoHtmlString());
    return tree;
}

// deliver the norm of the specified tree (number of terminals in its frontier)
function getNorm(tree,i){
    var res = 0;
    var begin = i;
    var lev = 0;
    for (; i < tree.length(); i++){
        var ele = tree.eleAt(i);
        var kind = BSeleKind(ele);
        if (kind == ELEOPEN){
            lev++;
        } else if (kind == ELECLOSE){
            lev--;
            if (lev == 0){
                i++;
                break;
            }
        } else if (isBSeleTerminal(ele)){
            res++;
        }
        if (lev == 0) break;
    }
    trace('o',"getNorm",tree.substring(begin,i).toNoHtmlString(),"res",res);
    return res;
}


// there is a column in which the prio is decided, and a reason, which could also
// be that in a previous one rho has changed and then continued to be min;
// If the reason is rho, then show the parenthesis that sets it, in the frame in which that
// happens, otherwise show the one or the two that make it <. tell it briefly in the rho row,
// and at length in a tip.

// deliver a string representing a tag, with the appropriate colors, in a table cell form
function toParen(tag,i,from,to,which,cmpres){
    var str = "";
    if (to < 0) to += tag.arr.length;
    for (var k = from; k < to; k++){
        var span = false;
        if (cmpres.isRho){
            // evidence the parethesis that defines the rho at fence and the ones that
            // makes the rho go down
            if (which == 1 && (i == cmpres.rhodown1 && cmpres.minsp1 == k || i == cmpres.fork && cmpres.bp01 == k) ||
                which == 2 && (i == cmpres.rhodown2 && cmpres.minsp2 == k || i == cmpres.fork && cmpres.bp02 == k)){
                span = true;
            }
        } else {
            if (which == 1 && i == cmpres.fork){
                if (cmpres.winner == 1){
                    if (cmpres.subs1 == k){
                        span = true;
                    }
                } else {
                    if (cmpres.kind != 2 && cmpres.subs2 == k){
                        span = true;
                    }
                }
            } else if (which == 2 && i == cmpres.fork){
                if (cmpres.winner == 2){
                    if (cmpres.subs2 == k){
                        span = true;
                    }
                } else {
                    if (cmpres.kind != 2 && cmpres.subs1 == k){
                        span = true;
                    }
                }
            }
        }
        if (span) str += "<span style=\"background-color:Aqua;\">";
        str += BSeleToString(tag.arr[k]);
        if (span) str += "</span>";
    }
    return str;
}

// deliver a string representing the specified parenthetized tree in a table row
function toTableRow(arr,fork,prefix,which,cmpres,msg,idx,join,steps){
    var str = "<tr>";
    str += "<td>" + idx + "</td><td>" + msg + "</td>";
    for (var i = 0; i < arr.length; i++){
        var a = arr[i];
        // before fork: background dimmed
        var color = (i < fork || i >= join) ? " bgcolor=Lavender" : "";
        if (i == fork && prefix > 0){
            // at fork and with a prefix of common parentheses: background dimmed
            str += "<td><span style=\"background-color:Lavender;\">";
            str += toParen(a,i,0,prefix,which,cmpres);
            str += "</span>";
            str += toParen(a,i,prefix,-1,which,cmpres);
            str += "</td>";
        } else {
            // at fork with no prefix, or after fork
            str += "<td" + color + ">" + toParen(a,i,0,-1,which,cmpres) + "</td>";
        }
        // then the terminal
        str += "<td>&nbsp;" + BSeleToAst(a.eleAt(-1)).sym + "&nbsp;</td>";
    }
    str += "</tr>";
    str += "<tr><td></td><td>items</td>";
    for (var i = 0; i < steps.length; i++){
        str += "<td>" + steps[i] + "</td><td></td>";
    }
    str += "</tr>";
    return str;
}

// deliver a string representing the comparison of the specified parenthetized tree in a table row
function toTableRow1(arr,which,cmpres,first,second){
    var str = "<tr>";
    str += "<td></td><td>&rho;"+ (which==2?"\'":"") + "</td>";
    for (var i = 0; i < arr.length; i++){
        if (which == cmpres.winner &&
            cmpres.isRho && cmpres.frame == i){
            str += "<td style=\"border:2px solid LightCoral\"" +
                " title=\"\u03c1 \u003e \u03c1\'\"" +
                "><span style=\"background-color:LightCoral;\">" + arr[i] + "</span> &gt; " +
                + (which==1?cmpres.rho2:cmpres.rho1) + "</td>";
        } else if (which == cmpres.winner &&
            cmpres.isSub && cmpres.fork == i){
            str += "<td style=\"border:2px solid LightCoral\"" +
                " title=\"t" + (which==1?first:second) + " \u228f t" + (which==1?second:first) +
                " because the highlited " +
                BSeleToString(which==1?cmpres.ele1:cmpres.ele2,true);
                switch (cmpres.subskind){
                case 1: str += " is a ( and the other is absent"; break;
                case 2: str += " is a (p and the other highlited is a (q, p \u22d6 q"; break;
                case 3: str += " is a ( and the other highlited is a )"; break;
                }
                str += "\">" +
                "<span style=\"background-color:LightCoral;\">" + arr[i] + "</span> " +
                "<span style=\"background-color:LightCoral;\">t<sup>" +
                (which==1?first:second) + "</sup></span> \u228f t<sup>" +
                (which==1?second:first) + "</sup>";
        } else {
            str += "<td>" + arr[i] + "</td>";
        }
        str += "<td></td>";
    }
    str += "</tr>";
    return str;
}

// deliver a list of the pnodes in forward ordering
function pnodesForwardList(head){
    // build a fake to state, that has only one item with left pointing to all items in
    // the previous one that end in eof
    head.to = new GBState();
    head.to.number = bsDFA.stateNr++;
    var lastitem = new BSItem();
    lastitem.sym = newBSsymbol();
    lastitem.left = new SetClass();
    head.to.items = [];
    head.to.items.push(lastitem);
    for (var i = 0; i < head.from.items.length; i++){
        var ast = itemAst(head.from.items[i]);
        if (ast.sym == EOF){
            lastitem.left.add(i);
        }
    }

    // build a list of states in forward ordering
    trace('m',"making forward list");
    var list = new LinkedList();
    for (var i = head; i != null; i = i.next){
        if ('m' in trc){
            i.trace();
        }
        list.prepend(i);
        if (list.head.next != null) i.suc = list.head.next.val;        // set the forward pointers
    }
    return list;
}

// choose the tree using the Okui method
var dashBoard;                   // the matrix to draw the table of the matches
function comparePat(head,test,text){
    trace('m',"comparePat");
    IidEdgeSeq = 0;
    var data = new priorDataClass();
    var headData = data;
    dashBoard = [];
    var list = pnodesForwardList(head);   // build forware pnodes list

    // scan then the list of states and choose the prior tree
    var n = 0;
    for (var i = list.head; i != null; i = i.next){
        var pnode = i.val;
        var dash = [];
        dashBoard[n] = dash;
        effectiveTrans(data,pnode,dash,test,n);
        if (i.next != null){      // not the last one
            data = proceedOneStep(data,n,pnode);
            data.prev = headData;
            headData = data;
        }
        n++;
    }
    if ('m' in trc){
        twriteln("comparePat resulting list of states");
        for (var i = list.head; i != null; i = i.next){
            var pnode = i.val;
            pnode.trace();
        }
    }
    var tree = pnodeToTreeString(head);
    trace("m","comparePat resulting tree",tree.toNoHtmlString());

    if (test) return tree;

    if (document.getElementById("algoProgress").checked){
        // draw a table containing the transitions done, the winners at convergence and
        // the reason for wictory

        // mark the winning path, display the ones that converge, winner first, and then each other,
        // with the reason for the loss
        for (var i = dashBoard[dashBoard.length-1][0]; i != null; i = i.prev){
            i.isFinal = true;
        }
        var str = "Prior tree finding steps:<p><table class=rho border=\"1\" data-dash=dashBoard>";
        str += "<tr>";
        var h = 0;
        for (var i = 0; i < dashBoard.length; i++){
            h = Math.max(h,dashBoard[i].length);
            str += "<td colspan=2>" + i + "</td><td></td>";
        }
        str += "</tr>";
        for (var i = 0; i < h; i++){
            str += "<tr>";
            for (var j = 0; j < dashBoard.length; j++){
                var empty = true;
                var cell = "";
                var handler = "";
                if (typeof(dashBoard[j]) != "undefined" &&
                    typeof(dashBoard[j][i]) != "undefined"){
                    var t = dashBoard[j][i];
                    if (t instanceof IidEdgeClass){
                        var tip = "";
                        if (t.prev.toState != null){
                            tip += "state " + t.prev.toState.number + ", item " + t.prev.toItem + "&rarr;";
                        }
                        tip += "state " + t.toState.number + ", item " + t.toItem;
                        var st = "";
                        if (t.prev.toState != null){
                            st += t.prev.seq + "&larr;";
                        }
                        st += t.serial() + ":";
                        var color = "Lavender";
                        if (t.seq >= 0){
                            if (t.isFinal) color = "Aqua";
                        } else {
                            color = "AntiqueWhite";
                        }
                        str += "<td style=\"background-color:" + color + ";\" title=\"" + tip + "\">" + st + "</td>";
                        str += "<td style=\"background-color:" + color + ";\">" + t.tag  + "</td>";
                    } else {
                        str += "<td></td><td onmouseenter=showPostit(this) onmouseleave=hidePostit(this)>" + t[0] +
                            "<div class=post style=\"display:none; border:1px solid black; background-color: LemonChiffon; padding: 5px; position:absolute\">" +
                            t[1] + "</div></td>";
                        handler = " onclick=showWinnerLoser(this) data-r= " + i + " data-c=" + j;
                    }
                    empty = false;
                } else {
                    str += "<td colspan=2></td>";
                }
                if (handler == ""){
                    var sym = EOF;
                    if (j < text.length) sym = text[j];
                    if (empty) sym = "";
                    str += "<td>&nbsp;" + sym + "&nbsp;</td>";
                } else {
                    str += "<td" + handler + " style=\"cursor:pointer;\">&nbsp;&#x25b6;&nbsp;</td>";
                }
            }
            str += "</tr>";
        }
        str += "</table>";
        // legenda
        str += "<p style=\"font-size:9pt;\">Legenda: <span style=\"background-color:Aqua;\">prior tree steps</span>, " +
            "<span style=\"background-color:Lavender;\">prior steps</span>, " +
            "<span style=\"background-color:AntiqueWhite;\">less prior of steps above, hover below for details</span>, " +
            "<span style=\"background-color:Aquamarine;\">common prefix</span>, "+
            "<span style=\"background-color:LemonChiffon;\">history</span>, "+
            "&#x25b6; show history, â¼ hide history, "+
            "<span style=\"background-color:Aqua;\">height</span>, "+
            "<span style=\"background-color:LightSalmon;\">subset</span>, "+
            "n<sub>m</sub>: step n at frame m, i &larr; j: step i generates step j (hover to see the items)";
        document.getElementById("matchdash").innerHTML = str;
    }
    return tree;
}

// deliver a string representing the tree of the active items in the pnodes list
function pnodeToTreeString(head,iid){
    var tree = new BSsymbol();
    if (arguments.length == 1){
        iid = head.activeIids[0];
    }
    for (var i = head; i != null; i = i.next){
        if (i == head){
            tree = newBSsymbol(i.from.items[iid].sym);
        } else {
            tree = newBSsymbol(i.from.items[iid].sym,tree);
        }
        if (i.next != null) iid = i.next.activeIids[iid];
    }
    return tree;
}

// choose the tree comparing convergences with the leftmost longest method
function compareLlong(head){
    trace("m","compareLlong",head);
    var list = pnodesForwardList(head);   // build forware pnodes list
    for (var i = list.head; i != null; i = i.next){
        var pnode = i.val;
        pnode.activeIids = [];            // clear the activeIids
        chooseLlong(pnode);
    }
    if ('m' in trc){
        twriteln("compareLlong resulting list of states");
        for (var i = list.head; i != null; i = i.next){
            var pnode = i.val;
            pnode.trace();
        }
    }
    var tree = pnodeToTreeString(head);
    trace("m","compareLlong resulting tree",tree.toNoHtmlString());
    return tree;
}

// chooses the prior path at a convergence using the leftmost longest criterion
function chooseLlong(pnode){
    trace('m',"chooseLlong",pnode);
    var to = pnode.to;
    if ('m' in trc){
        pnode.trace();
    }

    for (var i = 0; i < to.items.length; i++){
        // trace('m',"chooseLlong item",i);
        if (pnode.suc != null && pnode.suc.iidNodes[i] == null) continue;   // item not belonging to any path
        var arr = to.items[i].left.toArray();
        if (arr.length <= 1){                        // no convergence
            pnode.activeIids[i] = arr[0];            // active iid
            continue;
        }
        var winner = arr[0];
        var treewinner = pnodeToTreeString(pnode,winner);
        trace('m',"chooseLlong start winner",treewinner.toNoHtmlString());
        for (var j = 1; j < arr.length; j++){
            // compare the winner and the current one
            var current = pnodeToTreeString(pnode,arr[j]);
            var cmp = compLlong(treewinner,current);
            if (cmp > 0){
                winner = arr[j];
                treewinner = current;
            }
            trace('m',"chooseLlong winner",winner);
        }
        pnode.activeIids[i] = winner;         // active iid
        trace('m',"chooseLlong item",i,"activeIids",pnode.activeIids[i]);
    }
    trace('m',"chooseLlong res",pnode);
    if ('m' in trc){
        pnode.trace();
    }
}

// compares two trees with the leftmost longest criterion
function compLlong(tree1,tree2){
    trace('m',"compLlong",tree1.toNoHtmlString(),tree2.toNoHtmlString());
    var tree1i = 0;
    var tree2i = 0;
    var cmptrees = 0;
    for (;;){
        if (tree1i >= tree1.length()) break;
        if (tree2i >= tree2.length()) break;
        var e1 = tree1.eleAt(tree1i);
        var e2 = tree2.eleAt(tree2i);
        if (BSeleKind(e1) != ELEOPEN){
            tree1i++;
            continue;
        }
        if (BSeleKind(e2) != ELEOPEN){
            tree2i++;
            continue;
        }
        var pos1 = BSeleToAst(e1).pos;
        var pos2 = BSeleToAst(e2).pos;
        var comp = compareToBSelemPos(e1,e2);
        if (comp == 0){
            // compare yields
            var y1 = getNorm(tree1,tree1i);
            var y2 = getNorm(tree2,tree2i);
            trace('o',"compLlong = pos","||"+BSeleToString(e1,true)+"|| = ",y1,
                ", ||"+BSeleToString(e2,true)+"|| = ",y2);
            if (y1 > y2){
                cmptrees = -1;
                break;
            } else if (y2 > y1){
                cmptrees = 1;
                break;
            }
        } else {
            trace('o',"compLlong <> pos",BSeleToString(e1,true),BSeleToString(e2,true),comp);
            cmptrees = comp;
            break;
        }
        tree1i++;
        tree2i++;
    }
    if (cmptrees == 0){
        if (tree1i >= tree1.length() && tree2i >= tree2.length()){
            // identical
            error = true;
            errorMessage = "compLlong identical trees";
            trace('o',"compLlong identical");
        } else if (tree1i >= tree1.length()){
            trace('o',"compLlong tree1 shorter");
            cmptrees = 1;
        } else {
            trace('o',"compLlong tree2 shorter");
            cmptrees = -1;
        }
    }
    trace('o',"compLlong res",cmptrees);
    return cmptrees;
}

</script>
<script>
//.. dfa purge is different: have a closer look to it for greedy: it is in dfa computeNgrams;
//   I should reverse the test on bp0, which is the rho
//.. perhaps there is a need to adapt also the audit, the explanation strings


// choose the tree using the greedy method
function compareGreedy(head,test,text){
    trace('G',"compareGreedy");
    IidEdgeSeq = 0;
    var data = new priorDataClass();
    var headData = data;
    dashBoard = [];
    var list = pnodesForwardList(head);   // build forware pnodes list

    // scan then the list of states and choose the prior tree
    var n = 0;
    for (var i = list.head; i != null; i = i.next){
        var pnode = i.val;
        var dash = [];
        dashBoard[n] = dash;
        effectiveGreedy(data,pnode,dash,test,n);
        if (i.next != null){      // not the last one
            data = proceedGreedy(data,n,pnode);
            data.prev = headData;
            headData = data;
        }
        n++;
    }
    if ('G' in trc){
        twriteln("compareGreedy resulting list of states");
        for (var i = list.head; i != null; i = i.next){
            var pnode = i.val;
            pnode.trace();
        }
    }
    var tree = pnodeToTreeString(head);
    trace("G","compareGreedy resulting tree",tree.toNoHtmlString());

    if (test) return tree;

    if (document.getElementById("algoProgress").checked){
        // draw a table containing the transitions done, the winners at convergence and
        // the reason for wictory

        // mark the winning path, display the ones that converge, winner first, and then each other,
        // with the reason for the loss
        for (var i = dashBoard[dashBoard.length-1][0]; i != null; i = i.prev){
            i.isFinal = true;
        }
        var str = "Prior tree finding steps:<p><table class=rho border=\"1\" data-dash=dashBoard>";
        str += "<tr>";
        var h = 0;
        for (var i = 0; i < dashBoard.length; i++){
            h = Math.max(h,dashBoard[i].length);
            str += "<td colspan=2>" + i + "</td><td></td>";
        }
        str += "</tr>";
        for (var i = 0; i < h; i++){
            str += "<tr>";
            for (var j = 0; j < dashBoard.length; j++){
                var empty = true;
                var cell = "";
                var handler = "";
                if (typeof(dashBoard[j]) != "undefined" &&
                    typeof(dashBoard[j][i]) != "undefined"){
                    var t = dashBoard[j][i];
                    if (t instanceof IidEdgeClass){
                        var tip = "";
                        if (t.prev.toState != null){
                            tip += "state " + t.prev.toState.number + ", item " + t.prev.toItem + "&rarr;";
                        }
                        tip += "state " + t.toState.number + ", item " + t.toItem;
                        var st = "";
                        if (t.prev.toState != null){
                            st += t.prev.seq + "&larr;";
                        }
                        st += t.serial() + ":";
                        var color = "Lavender";
                        if (t.seq >= 0){
                            if (t.isFinal) color = "Aqua";
                        } else {
                            color = "AntiqueWhite";
                        }
                        str += "<td style=\"background-color:" + color + ";\" title=\"" + tip + "\">" + st + "</td>";
                        str += "<td style=\"background-color:" + color + ";\">" + t.tag  + "</td>";
                    } else {
                        str += "<td></td><td onmouseenter=showPostit(this) onmouseleave=hidePostit(this)>" + t[0] +
                            "<div class=post style=\"display:none; border:1px solid black; background-color: LemonChiffon; padding: 5px; position:absolute\">" +
                            t[1] + "</div></td>";
                        handler = " onclick=showWinnerLoser(this) data-r= " + i + " data-c=" + j;
                    }
                    empty = false;
                } else {
                    str += "<td colspan=2></td>";
                }
                if (handler == ""){
                    var sym = EOF;
                    if (j < text.length) sym = text[j];
                    if (empty) sym = "";
                    str += "<td>&nbsp;" + sym + "&nbsp;</td>";
                } else {
                    str += "<td" + handler + " style=\"cursor:pointer;\">&nbsp;&#x25b6;&nbsp;</td>";
                }
            }
            str += "</tr>";
        }
        str += "</table>";
        // legenda
        str += "<p style=\"font-size:9pt;\">Legenda: <span style=\"background-color:Aqua;\">prior tree steps</span>, " +
            "<span style=\"background-color:Lavender;\">prior steps</span>, " +
            "<span style=\"background-color:AntiqueWhite;\">less prior of steps above, hover below for details</span>, " +
            "<span style=\"background-color:Aquamarine;\">common prefix</span>, "+
            "<span style=\"background-color:LemonChiffon;\">history</span>, "+
            "&#x25b6; show history, â¼ hide history, "+
            "<span style=\"background-color:Aqua;\">height</span>, "+
            "<span style=\"background-color:LightSalmon;\">subset</span>, "+
            "n<sub>m</sub>: step n at frame m, i &larr; j: step i generates step j (hover to see the items)";
        document.getElementById("matchdash").innerHTML = str;
    }
    return tree;
}

// mark the steps done in the specified pnode on the active paths, choosing the most prior
// one when there are several converging on a same node in the path
function effectiveGreedy(data,pnode,dashb,test,n){
    trace('G',"effectiveGreedy",pnode);
    var from = pnode.from;
    var to = pnode.to;
    var prev = pnode.next;
    if ('G' in trc){
        pnode.trace();
    }

    for (var i = 0; i < to.items.length; i++){
        // trace('G',"effectiveGreedy item",i);
        choose: {
            if (pnode.suc != null && pnode.suc.iidNodes[i] == null) continue;   // item not belonging to any path
            var arr = to.items[i].left.toArray();
            var winner = arr[0];
            if (arr.length <= 1){                        // no convergence
                break choose;
            }
            var rho = -1;
            var rhop = -1;
            for (var j = 1; j < arr.length; j++){
                // compare the winner and the current one
                var p = arr[j];
                var pp = winner;
                var B = data.B[p][pp];
                rho = B[0];
                rhop = B[1];

                trace('G',"effectiveGreedy p",p,"pp",pp,"B",rho,rhop);
                rho = Math.min(rho,pat_minsp(from.items[p].sym));
                rhop = Math.min(rhop,pat_minsp(from.items[pp].sym));
                var D = data.D[pp][p];
                trace('G',"effectiveGreedy competing trans",
                    "<"+p+","+i+","+itemTag(from.items[p]).toNoHtmlString()+">",
                    "<"+pp+","+i+","+itemTag(from.items[pp]).toNoHtmlString()+">",
                    "rho",rho,"rhop",rhop,"D["+pp+"]["+p+"]",D);
                if ('G' in trc){
                    tracePaths(pnode,p,pp);
                }
                if (rho < rhop){
//twriteln("diff rhos");
                    winner = p;
                } else if (rho > rhop){
//twriteln("diff rhos");
                    winner = pp;
                } else if (D == 1){
//twriteln("diff D");
                    winner = pp;
                } else {
//twriteln("diff D?",D);
                    winner = p;
                }
                trace('G',"effectiveGreedy winner",winner);
            }
        } // choose
        pnode.activeIids[i] = winner;         // active iid
        trace('G',"effectiveGreedy item",i,"activeIids",pnode.activeIids[i]);

        if (!test){
            // the winner: item winner, transition from winner (from state) to i (to state)
            // get trans, and set its serial
            var newt;
            if (pnode.suc == null){          // last one
                newt = new IidEdgeClass();
                newt.fromState = pnode.from;
                newt.fromItem = winner;
                newt.toState = pnode.to;
                newt.toItem = 0;
            } else {
                newt = pnode.suc.iidNodes[i].getEdge(pnode.iidNodes[winner]);
            }
            newt.seq = IidEdgeSeq++;
            newt.tag = from.items[winner].sym.tag();
            // take the one that is not dead
            for (var j = pnode.iidNodes[winner].edgelist; j != null; j = j.next){
                var edg = j.val;
                if (edg.seq >= 0){
                    newt.prev = edg;
                    break;
                }
            }
            dashb.push(newt);
            trace('G',"effectiveGreedy winner",newt,newt.tag.toNoHtmlString());
            // all the others, each with the pair of rho, or if equal the D
            var p = winner;
            for (var j = 0; j < arr.length; j++){
                var pp = arr[j];
                if (pp == winner) continue;
                var B = data.B[p][pp];
                rho = B[0];
                rhop = B[1];
                rho = Math.min(rho,pat_minsp(from.items[p].sym));
                rhop = Math.min(rhop,pat_minsp(from.items[pp].sym));
                var nt;
                if (pnode.suc == null){          // last one
                    nt = new IidEdgeClass();
                    nt.fromState = pnode.from;
                    nt.fromItem = pp;
                    nt.toState = pnode.to;
                    nt.toItem = 0;
                } else {
                    nt = pnode.suc.iidNodes[i].getEdge(pnode.iidNodes[pp]);
                }
                nt.seq = -1;
                nt.tag = from.items[pp].sym.tag();
                // take the one that is not dead
                for (var j = pnode.iidNodes[pp].edgelist; j != null; j = j.next){
                    var edg = j.val;
                    if (edg.seq >= 0){
                        nt.prev = edg;
                        break;
                    }
                }
                trace('G',"effectiveGreedy loser",nt,nt.tag.toNoHtmlString());
                dashb.push(nt);
                var strl = "";
                strl += " because: ";

                var strs = "";
                // determine the origin of rho and D
                var pa = data.B[p][pp];
                var prevrho = pa[0];
                var prevrhop = pa[1];                   // <rho, rho'> = B[p][p']
                var updrho = pat_minsp(from.items[p].sym);
                var updrhop = pat_minsp(from.items[pp].sym);
                var rho = Math.min(prevrho,updrho);
                var rhop = Math.min(prevrhop,updrhop);
                var hooks = {"t":newt,"tp":nt,"n":n};   // to show the history
                trace('G',"effectiveGreedy loser",rho,rhop,p,pp,data.D[p][pp]);
                if (rho < rhop){
                    // looses because of rho
                    var gb = null;
                    if (prevrho > updrho){
                        // rho here
                        hooks.w = newAudit(9,n,rho,data.BA[p][pp][1],newt,nt);
                        gb = getB(hooks.w);
                    } else {
                        // rho from prev
                        hooks.w = data.BA[p][pp][0];
                        gb = getB(hooks.w);
                    }
                    strs += gb[0];                     // short reason
                    strs += " \u22d6 ";
                    strl += "<br>Ï<sub>" + newt.serial() + "</sub> = " + rho + ": " + gb[1];
                    if (prevrhop > updrhop){
                        // rhop here
                        hooks.wp = newAudit(9,n,rhop,data.BA[p][pp][1],nt,newt);
                        gb = getB(hooks.wp);
                    } else {
                        // rhop from prev
                        hooks.wp = data.BA[p][pp][1];
                        gb = getB(hooks.wp);
                    }
                    strs += gb[0];                      // short reason
                    strl += "<br>Ï<sub>" + nt.serial() + "</sub> = " + rhop + ": " + gb[1];
                } else if (data.D[p][pp] == 1){
                    // looses because of D
                    trace('o',"effectiveGreedy D",p,pp);
                    var da = data.DA[p][pp];
                    hooks.w = da;
                    hooks.wp = da;
                    gb = getD(da);
                    strs += gb[0];             // short reason
                    strl += "Ï<sub>" + newt.serial() + "</sub>, Ï<sub>" + nt.serial() + "</sub> = " + rho;
                    strl += " but once"
                    strl += "<br>" + gb[1];             // long reason
                }
                dashb.push([strs,strl,hooks]);
                trace('o',"effectiveGreedy reason",strs,"long",strl);
            }
        }
    }
    trace('G',"effectiveGreedy res",pnode);
    if ('G' in trc){
        pnode.trace();
    }
}

// update the values that represent the previous comparisons
function proceedGreedy(data,n,pnode){
    trace('G',"proceedGreedy step pnode");
    if ('G' in trc){
        pnode.trace();
    }
    var prev = data;
    data = new priorDataClass();
    // take all the path steps from the from state to the next one, considering only
    // the ones with the iid's computed by effectiveTrans
    var from = pnode.from;
    // the check on q <. q' in the paper serves only to make sure to compare two transitions
    // only once instead of twice (the second time swapping them)

    var to = pnode.to;
    for (var i = 1; i < to.items.length; i++){
        if (pnode.suc != null && pnode.suc.iidNodes[i] == null) continue;         // item not belonging to any path
        var q = i;
        var p = pnode.activeIids[q];
        var ptrans = pnode.suc.iidNodes[q].getEdge(pnode.iidNodes[p]);
        var porig;
        if (pnode.next != null){
            porig = pnode.next.activeIids[p];      // origin, to check that pp below is the same step
        }
        var alpha = itemTag(pnode.from.items[p]);
        for (var j = 0; j < i; j++){
            if (pnode.suc != null && pnode.suc.iidNodes[j] == null) continue;         // item not belonging to any path
            var qp = j;
            var pp = pnode.activeIids[qp];
            var pptrans = pnode.suc.iidNodes[qp].getEdge(pnode.iidNodes[pp]);
            var alphap = itemTag(pnode.from.items[pp]);
            trace('G',"proceedGreedy","<"+p+","+q+","+alpha.toNoHtmlString()+">",
                "<"+pp+","+qp+","+alphap.toNoHtmlString()+">");
            var rho = 0;
            var rhop = 0;
            // check that the items have the same origin in the previous pnode
            var pporig;
            if (pnode.next != null){
                pporig = pnode.next.activeIids[pp];
            }

            if (porig == pporig || pnode.next == null){              // p = p'
                // here we have two transitions from the same item leading to different items
                // probably I could compare instead their active iid's
                if (alpha.equals(alphap)){
                    continue;
                }
                var cmp = pat_subset_tags(alpha,alphap,null);
                trace('G',"proceedGreedy",
                    alpha.toNoHtmlString(),alphap.toNoHtmlString(),
                    ":",cmp < 0 ? "prior" : "not prior");
                // to compare two tags, take away the common prefix, then the first
                // is prior if it starts with (p and the second: starts with )q or
                // with (q with p <. q

                rho = pat_bp0(alpha,alphap);    // rho = bp0(alpha,alpha');
                rhop = pat_bp0(alphap,alpha);   // rho' = bp0(alpha',alpha)
                if (data.D[q] == null) data.D[q] = [];
                if (rho < rhop){
                    data.D[q][qp] = 1;               // D[q][q'] = 1 if rho > rho';
                    mSet(data.DA,q,qp,newAudit(3,n,rho,rhop,ptrans,pptrans));
                } else if (rho > rhop){
                    data.D[q][qp] = -1;              // D[q][q'] = -1 if rho < rho';
                    mSet(data.DA,qp,q,newAudit(3,n,rhop,rho,pptrans,ptrans));
                } else if (cmp < 0){
                    data.D[q][qp] = 1;               // D[q][q'] = 1 if alpha â alpha';
                    mSet(data.DA,q,qp,newAudit(1,n,rho,rhop,ptrans,pptrans));
                } else if (cmp > 0){
                    data.D[q][qp] = -1;              // D[q][q'] = 1 if alpha â alpha';
                    mSet(data.DA,qp,q,newAudit(1,n,rhop,rho,pptrans,ptrans));
                }
                var wrho = newAudit(8,n,rho,rhop,ptrans,pptrans);
                var wrhop = newAudit(8,n,rhop,rho,pptrans,ptrans);
                mSet(data.BA,q,qp,[wrho,wrhop]);
                mSet(data.BA,qp,q,[wrhop,wrho]);
            } else {
                var Bp = prev.B[p][pp];                   // assign rho and rho': <rho, rho'> = B'[p][p']
                rho = Bp[0];
                rhop = Bp[1];
                trace('G',"proceedGreedy distinct start rho",rho,rhop);
                var mrho = pat_minsp(alpha);
                rho = Math.min(rho,mrho);                 // rho = min{rho, minsp(alpha)};
                var mrhop = pat_minsp(alphap);
                rhop = Math.min(rhop,mrhop);              // rho' = min{rho', minsp(alpha')};
                var wrho = prev.BA[p][pp][0];
                if (mrho < Bp[0]){                        // new rho
                    wrho = newAudit(9,n,rho,prev.BA[p][pp][0],ptrans,pptrans);
                }
                var wrhop = prev.BA[p][pp][1];
                if (mrhop < Bp[1]){        // new rhop
                    wrhop = newAudit(9,n,rhop,prev.BA[p][pp][1],pptrans,ptrans);
                }
                mSet(data.BA,q,qp,[wrho,wrhop]);
                mSet(data.BA,qp,q,[wrhop,wrho]);

                if (data.D[q] == null) data.D[q] = [];
                if (rho < rhop){
                    data.D[q][qp] = 1;               // D[q][q'] = 1 if rho > rho';
                    mSet(data.DA,q,qp,newAudit(6,n,rho,rhop,ptrans,pptrans,wrho,wrhop));
                } else if (rho > rhop){
                    data.D[q][qp] = -1;              // D[q][q'] = -1 if rho < rho';
                    mSet(data.DA,qp,q,newAudit(6,n,rhop,rho,pptrans,ptrans,wrhop,wrho));
                } else {
                    data.D[q][qp] = prev.D[p][pp];   // D[q][q'] = D'[p][p']
                    if (prev.DA[p] != null){
                        mSet(data.DA,q,qp,prev.DA[p][pp]);
                    }
                    if (prev.DA[pp] != null){
                        mSet(data.DA,qp,q,prev.DA[pp][p]);
                    }
                }
            }
            mSet(data.D,qp,q,-data.D[q][qp]);   // D[q'][q] = -D[q][q']
            mSet(data.B,q,qp,[rho,rhop]);       // B[q][q'] = <rho, rho'>;
            mSet(data.B,qp,q,[rhop,rho]);       // B[q'][q] = <rho', rho>

            trace('G',"proceedGreedy res",
                priorDataToString("B",data.B,q,qp,data.B[q][qp]),
                priorDataToString("D",data.D,q,qp,data.D[q][qp]));
        }
    }
    trace('G',"proceedGreedy end");
    return data;
}
</script>
<script>
// ---------- Building the tree -----------------

// build the tree rooted in the specified head of pnodes
function buildTree(head){
    trace('p',"buildTree",head);
    if (head == null) return;              // ... perhaps handle null strings
    treeNodeSeq = 0;
    treeNodeHead = null;
    for (var i = head; i != null; i = i.next){
        trace('p',"buildTree pnode",i);
    }
    // build the forward list of nodes;
    var firstNode = null;
    for (var i = head; i != null; i = i.next){
        i.suc = firstNode;
        firstNode = i;
    }
    var iid = head.activeIids[0];
    trace('p',"buildTree set iid path",iid);
    for (var t = head; t != null; t = t.next){    // take the first path of iid's
        t.iid = iid;
        if (t.next != null) iid = t.next.activeIids[iid];
        trace('p',"buildTree iid prior path",t);
    }

    trace('p',"buildTree iid path");
    var linearTree = newBSsymbol();
    for (var i = firstNode; i != null; i = i.suc){
        trace('p',"buildTree iid node",i);
        linearTree = newBSsymbol(linearTree,i.from.items[i.iid].sym);
    }
    trace('p',"buildTree linearTree",linearTree.toNoHtmlString());

    var root = buildTree1(linearTree);
    if ('p' in trc){
        traceTree();
    }
    var ele = document.getElementById("tree");
    ele.innerHTML = drawTree(root);
    return linearTree;
}

// an element in the stack of buildtree
function StackElem(){
    this.ele = null;        // the number of the ast of thr value
    this.kind = 0;          // 0: already built tree, others: see AstNode
    this.tag = null;        // the BSelement of the value
}

// construct an element in the stack of buildtree
function newStackElem(ele,kind,tag){
    var s = new StackElem();
    s.ele = ele;
    s.kind = kind;
    s.tag = tag;
    return s;
}

// deliver a string representing the specified stack element
function stackToString(stack, sp){
    var str = new StringBuilder();
    for (var i = 0; i <= sp; i++){
        var elestr = "";
        var ele = stack[i].ele;
        if (stack[i].kind == 0){      // already built tree or terminal
            if (ele instanceof TreeNodeClass){
                elestr += "<" + ele.seq + ">";
            } else {
                var ast = BSeleToAst(ele);
                elestr += ast.sym;
            }
        } else {
            elestr += BSeleToString(stack[i].tag,true);
            elestr += aKindToString(stack[i].kind);
        }
        if (i > 0) str.append(", ");
        str.append(i + ":");
        str.append(elestr);
    }
    return str.toString();
}

// a node in the parse tree of the string
function TreeNodeClass(){
    this.seq = 0;            // serial number of this node
    this.son = null;         // reference to the son
    this.bro = null;         // reference to the brother
    this.ele = null;         // reference to the value: either a subtree or an ast denoting a leaf
    this.kind = 0;           // same as that of the ast
    this.groupKind = 0;
    this.next = null;        // reference to the next node in the list of nodes
    this.altnr = 0;          // > 0: alternative number, when the node is an element in an alternative

    // deliver a string representing this node
    this.toString = function(){
        var str = "";
        str += this.seq + ": ";
        str += "kind: " + this.kind + " ";
        if (this.altnr != 0) str += "|" + this.altnr + " ";
        if (this.kind == 0){
            if (this.ele instanceof TreeNodeClass){
                str += this.ele.seq;
            } else {
                var ast = BSeleToAst(this.ele);
                if (ast.kind == 3){   // group with no sons: empty
                    str += "&epsilon;"
                } else {
                    str += ast.sym;
                }
            }
        } else {
            str += "subtree kind: " + this.kind + " groupKind: " + this.groupKind;
            if (this.ele instanceof TreeNodeClass){
                str += " subtree: " + this.ele.seq;
            } else {
                str += " ast: " + this.ele;
            }
        }
        if (this.son != null) str += " son: " + this.son.seq;
        if (this.bro != null) str += " bro: " + this.bro.seq;
        str += " w: " + this.width + " h: " + this.height;
        return str;
    }
    this.width = 0;
    this.height = 0;
    this.iconWidth = 0;
    this.iconHeight = 0;
    this.getIcon = function(){
        var str = "";
        var ast = BSeleToAst(this.ele);
        if (this.son == null){    // leaf
            if (ast.kind == 3){   // group with no sons: empty
                str += "&epsilon;"
            } else {
                str += ast.sym;
            }
        } else {
//            str += "&bullet;";
            switch (ast.kind){
            case 0: break;
            case 1: str += "|"; break;
            case 2: str += "\u2219"; break;
            case 3: str += groupNodeIcon[ast.groupKind]; break;
            case 4: break;
            }
        }
        if (ast.altnr != 0) str += "<sup>|" + ast.altnr + "</sup>";
        return str;
    }
}

var groupNodeIcon = [
    GR_OPEN+GR_CLOSE,"[]","*","+","\u00ab\u00bb"];

var treeNodeSeq;       // the serial number of nodes
var treeNodeHead;      // the head of the list of nodes

// construct a new tree node object
function newTreeNodeClass(kind){
    var node = new TreeNodeClass();
    node.seq = treeNodeSeq++;
    node.next = treeNodeHead;
    treeNodeHead = node;
    node.kind = kind;
    trace('p',"newTreeNodeClass",node);
    return node;
}

// trace the tree
function traceTree(){
    for (var i = treeNodeHead; i != null; i = i.next){
        twriteln(i);
    }
}

var ALTERN = true;            // whether alternatives are displayed in tree nodes

// build the tree
function buildTree1(linear){
    trace('p',"buildTree1",linear);
    if ('p' in trc){
        traceAst(astRoot);
    }
    var root = null;
    var stack = [];          // the stack
    var sp = -1;
    var bsym = linear;
    for (var i = 0; i < bsym.length(); i++){
        var elem = bsym.eleAt(i);
        var ast = BSeleToAst(elem);
        var eleKind = BSeleKind(elem);
        trace('p',"buildTree loop:",i,"ele:",BSeleToString(elem,true),
            BSeleKindToString(eleKind),astKindToString(ast));
        var ele = BSeleToAstNum(elem);
        if (eleKind == ELEOPEN){               // node entry
            if (ast.kind != 0){               // container
                stack[++sp] = newStackElem(ele,ast.kind,elem);
                trace('p',"buildTree: open, stack:",stackToString(stack,sp));
            }
        } else if (eleKind == ELECLOSE){               // node exit
            trace('q',"buildTree: -1-",ast,ast.kind);
            if (ast.kind != 0){               // container
                // the derivation at the current level of stack is ended, reduce it
                var start = sp;
                var node = newTreeNodeClass(ast.kind);
                node.groupKind = ast.groupKind;
                node.ele = ele;
                var cur = null;
                while (stack[start].kind != ast.kind){        // find start of derivation
                    start--;
                }
                var startder = start+1;
                trace('q',"buildTree: -2-",start,sp);
                for (var s = startder; s <= sp; s++){
                    var n = null;
                    if (stack[s].ele instanceof TreeNodeClass){
                        n = stack[s].ele;
                    } else {
                        n = newTreeNodeClass(0);
                        n.ele = stack[s].ele;
                        root = node;
                        trace('p',"buildTree new node:",n);
                    }
                    if (node.son == null){
                        node.son = n;
                    } else {
                        cur.bro = n;
                    }
                    cur = n;
                }
                trace('p',"buildTree new container:",node);
                // replace parenthesis with derivation
                sp = start;
                trace('q',"buildTree: -3-",ast);
                stack[sp] = newStackElem(node,0,elem);
                root = node;
                trace('p',"buildTree: reduction done stack:",stackToString(stack,sp));
            }
        } else {                      // terminal
            if (ast.sym == EOF) break;                    
            // put current element in current level           
            trace('q',"buildTree: -4-",ast,ast.sym);
            stack[++sp] = newStackElem(ele,0,elem);
            trace('p',"buildTree: terminal stack:",stackToString(stack,sp));
        }
    }
    top: if (sp >= 0){
        trace('p',"buildTree: top stack:",stackToString(stack,sp));
        if (stack[0].ele instanceof TreeNodeClass) break top;
        var node = newTreeNodeClass(0);
        node.ele = stack[0].ele;
        trace('p',"buildTree new node:",n);
        root = node;
    }
    trace('p',"buildTree1 root",root);
    return root;
}


</script>
<script>
// ---------- Drawing trees -----------------

// draws the tree of the ast rooted at the specified node
function drawAst(root){
    trace('s',"drawAst",root);
    computeDim(root);
    if ('s' in trc){
        traceAst(ast);
    }
    var ele = document.getElementById("astTree");
    var svg = "<svg xmlns=\"http://www.w3.org/2000/svg\"" +
        " xmlns:xlink=\"http://www.w3.org/1999/xlink\"" +
        " height=\"" + root.height + "\" width=\"" + root.width + "\">\n";
    svg += gentree(root);
    svg += "</svg>\n";
    trace('s',svg);
    ele.innerHTML = svg;
    trace('s',"drawAst done");
}

// draws the tree of the string rooted at the specified node
function drawTree(root){
    trace('s',"drawTree",root);
    computeDim(root);
    if ('s' in trc){
        traceTree();
    }
    var svg = "<svg xmlns=\"http://www.w3.org/2000/svg\"" +
        " xmlns:xlink=\"http://www.w3.org/1999/xlink\"" +
        " height=\"" + root.height + "\" width=\"" + root.width + "\">\n";
    svg += gentree(root);
    svg += "</svg>\n";
    trace('s',svg);
    trace('s',"drawTree done");
    return svg;
}

var HSPACE = 10;  // horizontal space between sons
var VSPACE = 20;  // vertical space between node and sons

// determines the dimensions of the specified text
function computeTextDim(text,node){
    var ele = document.getElementById("textBox");
    ele.innerHTML = text;
    var width = ele.clientWidth + 1;
    var height = ele.clientHeight + 1;
    node.iconWidth = width;
    node.iconHeight = height;
    trace('s',"computeTextDim",text);
}

// determines the dimensions of the tree rooted in the specified node
function computeDim(node){
    trace('s',"computeDim",node);
    if (node.son == null){
        computeTextDim(node.getIcon(),node);
        node.width = node.iconWidth;
        node.height = node.iconHeight;
        return;
    }
    var width = 0;
    var height = 0;
    for (var i = node.son; i != null; i = i.bro){
        trace('s',"computeDim loop",i);
        computeDim(i);
        if (i != node.son) width += HSPACE;
        width += i.width;
        if (i.height > height) height = i.height;
    }
    computeTextDim(node.getIcon(),node);
    height += VSPACE;
    height += node.iconHeight;
    if (node.iconWidth > width) width = node.iconWidth;
    node.width = width;
    node.height = height;
}

// draws the tree rooted in the specified node
function gentree(node){
    trace('s',"gentree",node);
    var svg = "";
    if (node.son == null){
        var sym = node.getIcon();
        svg += "<foreignObject x=\"0\" y=\"" + 0 +
            "\" width=\"" + node.iconWidth + "\" height=\"" + node.iconHeight +
            "\">" + sym + "</foreignObject>\n";
    } else {
        // place the sons
        var x = 0;
        var y = node.iconHeight + VSPACE;
        var x1 = node.width/2;       // start of the lines
        var y1 = node.iconHeight - 2;
        var y2 = node.iconHeight + VSPACE;
        var wson = 0;
        var n = 0;
        for (var i = node.son; i != null; i = i.bro){
            wson += i.width;
            n++;
        }
        // if there is only one son, and it is narrower than the node, it must be centered
        if (n == 1 && node.son.iconWidth < node.width){
            x = (node.width - node.son.width) / 2;
        }
        var hspace = (node.width - wson)/(n-1);    // space between sons
        for (var i = node.son; i != null; i = i.bro){
            svg += "<svg x=\"" + x + "\" y=\"" + y + "\">\n";
            svg += gentree(i);
            svg += "</svg>\n";
            // place the lines
            var x2 = x + i.width/2;
            svg += "<line x1=\"" + x1 + "\" y1=\"" + y1 +
                "\" x2=\"" + x2 + "\" y2=\"" + y2 + "\" style=\"stroke:black;stroke-width:1\" />\n";
            x += hspace;
            x += i.width;
        }

        // place the node
        svg += "<rect x=\""+ (x1-node.iconWidth/2-2) + "\" y=\"0\" width=\"" + (node.iconWidth+4) +
            "\" height=\"" + (node.iconHeight+4) + "\"" +
            " style=\"fill:white;\" />\n";
        var nodex = node.width/2 - node.iconWidth/2;
        var icon = node.getIcon();
        svg += "<foreignObject x=\"" + nodex + "\" y=\"" + 0 +
            "\" width=\"" + node.iconWidth + "\" height=\"" + node.iconHeight +
            "\" >" + icon + "</foreignObject>\n";
    }
    // svg += "<rect x=\"0\" y=\"0\" width=\"" + node.width +
    //    "\" height=\"" + node.height + "\"" +
    //    " style=\"stroke:gray;stroke-width:1;fill-opacity:0\" />\n";
    trace('s',"gentree",node,svg);
    return svg;
}

</script>
<script>


// deliver a new audit object
function newAudit(why,n,rho,rhop,tr,trp,wrho,wrhop){
    return {"why":why,"n":n,
       "rho":rho,"rhop":rhop,"tr":tr,"trp":trp,"wrho":wrho,"wrhop":wrhop};
}

// deliver a transition represented with its number and its tag, colored
function trId(frame,trans,prefix,other,othercolor){
    var str = "";
    if (trans.seq < 0){
        str += "â ";
    } else {
        str += trans.seq;
    }
    str += "<sub>" + frame + "</sub>:";
    if (arguments.length == 2){
        str += trans.tag;
    } else {
        str += colorTag(trans.tag,prefix,other,othercolor);
    }
    return str;
}

// deliver a string describing briefly the reason for the specified value, and another
// describing the computation in greater detail
function getD(DA){
    trace('j',"getDA",objToString(DA));
    var strs = "";
    var strl = "";
    switch (DA.why){            // reason
    case 1:                     // p=p', bp0(t)=bp0(t'), tât' D:1
        var cmpres = new compareTreesRes();
        pat_subset_tags(DA.tr.tag,DA.trp.tag,cmpres);
        strs += trId(DA.n,DA.tr,0,cmpres.subs1,"LightSalmon") + " â " +
            trId(DA.n,DA.trp,0,cmpres.subs2,"LightSalmon");
        strl += strs + " since " + BSeleToString(DA.tr.tag.eleAt(cmpres.subs1)) + " \u22d6 ";
        switch (cmpres.subskind){
        case 1: strl += " Îµ"; break;
        case 2: case 3: strl += BSeleToString(DA.trp.tag.eleAt(cmpres.subs2)); break;
        }
        break;
    case 2:
        // this should never occur
        break;
    case 3:                     // bp0(t)>bp0(t') D:1 
        pat_bp0(DA.tr.tag,DA.trp.tag);
        strs += trId(DA.n,DA.tr,pat_bp0_prefix,pat_bp0_idx) + " \u22d6 ";
        strl += trId(DA.n,DA.tr,pat_bp0_prefix,pat_bp0_idx);
        pat_bp0(DA.trp.tag,DA.tr.tag);
        strs += trId(DA.n,DA.trp,pat_bp0_prefix,pat_bp0_idx);
        strl += " \u22d6 " + trId(DA.n,DA.trp,pat_bp0_prefix,-1);
        break;
    case 4:
        // this should never occur
    case 5:
        // this should never occur
        break;
    case 6:                     // min
        strs += getB(DA.wrho)[0];
        strs += " \u22d6 ";
        strs += getB(DA.wrhop)[0];
        strl += "Ï<sub>" + DA.wrho.tr.serial() + "</sub> = " + DA.wrho.rho + ": ";
        strl += getB(DA.wrho)[1];
        strl += "<br> Ï<sub>" + DA.wrhop.tr.serial() + "</sub> = " + DA.wrhop.rho + ": ";
        strl += getB(DA.wrhop)[1];
        break;
    case 7:
        // this should never occur
        break;
    }
    trace('j',"getD return [0]:",strs,"[1]:",strl);
    return [strs,strl];
}

// tell what transition set the specified value
function getAtr(at,which){
    trace('j',"getAtr",at.tr,"which",which);
    var tr = null;
    switch (at.why){            // reason
    case 1:
    case 3:
        if (which == 0){
            tr = at.tr;
        } else {
            tr = at.trp;
        }
        break;
    case 6:
        if (which == 0){
            tr = at.wrho.tr;
        } else {
            tr = at.wrhop.tr;
        }
        break;
    case 8:
    case 9:
        tr = at.tr;
        break;
    }
    trace('j',"getAtr ret",tr);
    return tr;
}

// deliver a string representing the transition that set the specified value
function getAtag(at,which){
    trace('j',"getAtag",at.tr,"which",which);
    var str = "";
    switch (at.why){            // reason
    case 1:                     // p=p', bp0(t)=bp0(t'), tât' D:1
        var cmpres = new compareTreesRes();
        pat_subset_tags(at.tr.tag,at.trp.tag,cmpres);
        if (which == 0){
            str += colorTag(at.tr.tag,0,cmpres.subs1,"LightSalmon");
        } else {
            str += colorTag(at.trp.tag,0,cmpres.subs2,"LightSalmon");
        }
        break;
    case 3:                     // bp0(t)>bp0(t') D:1 
        pat_bp0(at.tr.tag,at.trp.tag);
        if (which == 0){
            str += colorTag(at.tr.tag,pat_bp0_prefix,pat_bp0_idx);
        } else {
            str += colorTag(at.trp.tag,pat_bp0_prefix,pat_bp0_idx);
        }
        break;
    case 6:                     // min
        if (which == 0){
            str += getAtag(at.wrho);
        } else {
            str += getAtag(at.wrhop);
        }
        break;
    case 8:                     // B:bp0(t),bp0(t')
        pat_bp0(at.tr.tag,at.trp.tag);
        str += colorTag(at.tr.tag,0,pat_bp0_idx);       // prefix 0 because it could be shown along with one of another frame
        break;
    case 9:                     // B:min,min
        pat_minsp(at.tr.tag);
        str += colorTag(at.tr.tag,0,pat_minsp_idx);
        break;
    }
    trace('j',"getAtag ret",str);
    return str;
}

// deliver a string coloring the tag argument up to the prefix and also the other element after it
function colorTag(tag,prefix,other,othercolor){
    trace('j',"colorTag",tag.toNoHtmlString(),prefix,other);
    var str = "";
    if (other >= 0 && other < prefix) prefix = other;    // bp0 could be decided on an element that is the last of the prefix
    var idx = 0;
    // the prefix, colored
    if (prefix > 0){
        str += "<span style=\"background-color:Aquamarine;\">";
        for (var i = 0; i < prefix; i++){
            str += BSeleToString(tag.eleAt(i));
        }        
        str += "</span>";
        idx = prefix;
    }
    // what follows the prefix, up to the other
    for (var i = idx; i < other; i++){
        str += BSeleToString(tag.eleAt(i));
    }
    // the other
    if (other >= 0){
        if (othercolor == null){
            othercolor = "Aqua";
        }
        str += "<span style=\"background-color:" + othercolor + ";\">";
        str += BSeleToString(tag.eleAt(other));
        str += "</span>";
        idx = other+1;
    }
    // the rest
    for (var i = idx; i < tag.length(); i++){
        str += BSeleToString(tag.eleAt(i));
    }
    trace('j',"colorTag res",str);
    return str;
}

// deliver the short and long reasons of the computation of the specified value
function getB(BA){
    trace('j',"getB",objToString(BA));
    var strs = "";
    var strl = "";
    switch (BA.why){            // reason
    case 8:                     // B:bp0(t),bp0(t')
        pat_bp0(BA.tr.tag,BA.trp.tag);
        strs += trId(BA.n,BA.tr,0,pat_bp0_idx);       // prefix 0 because it could be shown along with one of another frame
        strl += trId(BA.n,BA.tr,pat_bp0_prefix,pat_bp0_idx);
        pat_bp0(BA.trp.tag,BA.tr.tag);
        strl += " w.r.t.: " + trId(BA.n,BA.trp,pat_bp0_prefix,-1);
        break;
    case 9:                     // B:min,min
        pat_minsp(BA.tr.tag);
        strs += trId(BA.n,BA.tr,0,pat_minsp_idx);
        strl += strs + " < " + BA.rhop.rho + ": " + getB(BA.rhop)[0];
        break;
    }
    trace('j',"getB return [0]:",strs,"[1]:",strl);
    return [strs,strl];
}

// add two rows after the one of a loosing step with the winner path and another row with the
// looser path
function showWinnerLoser(el){
    trace('j',"showWinnerLoser",el);
    // when one is shown, and there is another one shown, first close the other

    var table = null;
    for (var e = el; e != null; e = e.parentNode){
        if (e.nodeName == "TABLE"){
            table = e;
            break;
        }
    }
    if (typeof(table.myShow) != undefined && table.myShow != null){   // hide
        hideWinnerLoser(table.myShow);
    }

    el.onclick = new Function("hideWinnerLoser(this)");
    var rownr = 0;
    for (var e = el; e != null; e = e.parentNode){
        if (e.nodeName == "TR"){
            rownr = e.rowIndex;
        }
    }
    var di = parseInt(el.getAttribute("data-r"));
    var dj = parseInt(el.getAttribute("data-c"));
    var dash = eval(table.getAttribute("data-dash"));

    table.myShow = el;
    el.innerHTML = "&nbsp;â¼&nbsp";

    // determine now the tags of the winner
    var hook = dash[dj][di][2];
    var row = table.insertRow(rownr+1);
    row.style.backgroundColor = "LemonChiffon";
    var trans = hook.t;
    var col = (hook.n+1) * 3;
    trace('j',"showWinnerLoser",trans,col,objToString(hook));
    for (var i = 0; i < col; i++){
        row.insertCell(0);
    }
    var cells = row.cells;
    for (var i = trans; i.toState != null; i = i.prev){
        cells[--col].innerHTML = "";
        var st = "";
        if (i == getAtr(hook.w,0)){
            st += getAtag(hook.w,0);
        } else {
            st += i.tag;
        }
        cells[--col].innerHTML = st;
        st = "";
        if (i.prev != null){
            st += i.prev.seq + "&larr;";
        }
        st += i.serial() + ":";
        cells[--col].innerHTML = st;
    }

    // determine now the tags of the looser
    row = table.insertRow(rownr+2);
    row.style.backgroundColor = "LemonChiffon";
    trans = hook.tp;
    col = (hook.n+1) * 3;
    trace('j',"showWinnerLoser",trans,col);
    for (var i = 0; i < col; i++){
        row.insertCell(0);
    }
    var cells = row.cells;
    for (var i = trans; i.toState != null; i = i.prev){
        cells[--col].innerHTML = "";
        var st = "";
        if (i == getAtr(hook.wp,1)){
            st += getAtag(hook.wp,1);
        } else {
            st += i.tag;
        }
        cells[--col].innerHTML = st;
        var st = "";
        if (i.prev != null){
            st += i.prev.seq + "&larr;";
        }
        st += i.serial() + ":";
        cells[--col].innerHTML = st;
    }
}

// hide the history rows
function hideWinnerLoser(el){
    el.innerHTML = "&nbsp;&#x25b6;&nbsp;";
    el.onclick = new Function("showWinnerLoser(this)");

    var rownr = 0;
    var table = null;
    for (var e = el; e != null; e = e.parentNode){
        if (e.nodeName == "TR"){
            rownr = e.rowIndex;
        }
        if (e.nodeName == "TABLE"){
            table = e;
            break;
        }
    }
    table.myShow = null;
    table.deleteRow(rownr+1);
    table.deleteRow(rownr+1);
}

</script>
<script>
// ---------- Okui algoritm -----------------

var patNary = true;    // whether n-ary concatenation and alternation supported

var patNFA;            // the NFA

// the state table
function PatStateTable(){
    this.head = null;       // the head of the list of states
    this.last = null;       // the tail of the list
    this.lastAdded = null;  // the last state added
    this.stateNr = 0;       // the number of states
    this.table = [];        // the table of states

    // add a new state
    this.add = function(msg,pos){
        var h = new PatState();
        h.number = this.stateNr++;
        h.name = pos;
        if (this.last == null) this.head = h;     // append to list
        else this.last.suc = h;
        this.last = h;
        this.lastAdded = h;
        trace('v',msg,"new PatState",h.number,h.stateName());
        return h;
    }
    // trace this table of states
    this.trace = function(){
        for (var s = this.head; s != null; s = s.suc){
            s.trace();
        }
    }

    // trace this table of states in Html form
    this.traceHtml = function(ele){
        for (var s = this.head; s != null; s = s.suc){
            if (!s.isReacheable) continue;
            s.traceHtml(ele);
        }
    }

    // trace the states reacheable from the specified one
    this.strace = function(is,showstate){
        if (arguments.length == 1) showstate = false;
        var dp = 0;
        var qp = 0;
        var queue = [];
        queue[qp++] = is;   // start from it
        while (dp != qp){                           // while queue not empty
            var s = queue[dp++];
            if (showstate) twriteln("state",s.toId());
            loop: for (t = s.transList; t != null; t = t.next){  // find edge or last
                twriteln("  ",s.toId(),t);
                for (var j = 0; j < qp; j++){
                    if (queue[j] == t.nextState) continue loop;    // already visited
                }
                queue[qp++] = t.nextState;          // enqueue it
            }
        }
    }
}

// display the pat on the html page
function showpat(){
    var el = document.getElementById("thepat");
    if (el.style.display == "block"){
        el.style.display = "none";
    } else {
        if (patNFA != null){
            el.style.display = "block";
            var ele = document.getElementById("pat");
            ele.innerHTML = "";
            patNFA.traceHtml(ele);
            var gr = new Graph();
            gr.name = "PAT";
            gr.extras = new GraphExtras();
            for (var s = patNFA.head; s != null; s = s.suc){
                if (!s.isReacheable) continue;
                s.node = newNode(gr,s.stateName(),
                    s.isFinal ? "yellow" : "white",s.toString());
                s.node.extras.state = s;
            }
            var cnt = 0;
            var tags = {};
            var tagarr = [];
            for (var s = patNFA.head; s != null; s = s.suc){
                if (!s.isReacheable) continue;
                for (var t = s.transList; t != null; t = t.next){
                    var n = 0;
                    if (t.tag in tags){
                        n = tags[t.tag];
                    } else {
                        n = cnt++;
                        tags[t.tag] = n;
                        tagarr[tagarr.length] = t.tag;
                    }
//                    t.edge = newEdge(gr,"",t.sym + "," + t.tag,s.node,t.nextState.node);
                    t.edge = newEdge(gr,"",t.sym + ",A" + n,s.node,t.nextState.node);
                }
            }
            drawGraph(gr);
            var strtags = "";
            for (var i = 0; i < tagarr.length; i++){
                strtags += "A"+i + ": " + tagarr[i] + "<br>";
            }
            document.getElementById("pattags").innerHTML = strtags;
        }
    }
}


// a PAT transition
function PatTrans(){
    this.next = null;       // reference to the next transition
    this.nextState = null;  // the next state (endpoint of this transition)
    this.sym = 0;           // the terminal
    this.tag;               // the tag

    // deliver a string representing this transition
    this.toString = function(){
        var t = "Îµ";
        if (this.tag != null) t = this.tag.toNoHtmlString();
        return "--" + this.sym + "," + t + "-->" + this.nextState.toId();
    }
}
var ANYSYMB = "\u25a1";     // any symbols

// construct a new transition
function newPatTrans(from,to,sym,tag){
    var t;
    sea: {
        var pr = null;
        for (t = from.transList; t != null; t = t.next){      // find last
            pr = t;
        }
        t = new PatTrans();
        t.nextState = to;
        t.sym = sym;
        t.tag = tag;
        if (pr == null){          // append
            from.transList = t;
        } else {
            pr.next = t;
        }
    }
    trace('v',"newPatTrans",from.toId(),t);
    return t;
}

// a state in the PAT
function PatState(){
    this.suc = null;           // the reference to the next state in the list of states
    this.number = 0;           // state number
    this.transList = null;     // the head of the list of transitions
    this.isFinal = false;      // whether this state is final
    this.name = null;          // the name, i.e. the position
    this.isReacheable = false; // whether it is reacheable from the initial state

    // tell if this state is equal to the specified other one
    this.equals = function(other){
        return this.number == other.number;
    }

    // compare the position of this state with that of the other one
    this.compareTo = function(other){
        var res = 0;
        if (this.isFinal && other.isFinal) return res;
        if (this.isFinal) return 1;
        if (other.isFinal) return -1;
        return compareToPos(this.name,other.name);
    }

    // deliver a string representing the name of this state
    this.stateName = function(){
        var name = "";
        if (this.isFinal){
            name = "$";
        } else {
            name = posToString(this.name);
        }
        return name;
    }

    // deliver a string representation of this state
    this.toString = function(){
        var st = new StringBuilder();
        st.append(this.number);
        st.append(": ");
        st.append(this.stateName());
        if (this.isFinal) st.append(" final");
        st.append(":");
        for (var t = this.transList; t != null; t = t.next){
            st.append(" ");
            st.append(t);
        }
        return st.toString();
    }

    // deliver a string with the number and name of this state
    this.toId = function(){
        var str = this.number;
        if (this.name != null){
            str += ":" + this.stateName();
        }
        return str;
    }

    // trace this state
    this.trace = function(){
        twriteln("state:",this.toId(),this.isFinal ? "final" : "");
        for (var t = this.transList; t != null; t = t.next){
            twriteln("  ",t);
        }
    }

    // trace this state in Html format
    this.traceHtml = function(ele){
        ele.innerHTML += "<dd>state: " + this.stateName() + (this.isFinal ? " final" : "") + "</dd>";
        if (this.transList == null) return;
        ele.innerHTML += "<dd style=\"text-indent: 2em;\">edges:</dd>";
        for (var t = this.transList; t != null; t = t.next){
            ele.innerHTML += "<dd style=\"text-indent: 4em;\">" + t.sym + "," + t.tag + "&rarr;" +
                t.nextState.stateName() + "</dd>";
        }
    }

    // trace this state in Html form
    this.traceHtml1 = function(ele){
        var str = "";
        str += "<div class=llabel> state: " + this.stateName() + (this.isFinal ? " final" : "");
        str += "<dd class=llabel1>edges:</dd>";
        for (var t = this.transList; t != null; t = t.next){
            str += "<dd class=llabel2>" + t.sym + "," + t.tag  + "&rarr;" +
                t.nextState.number + "</dd>";
        }
        str += "</div>";
        ele.innerHTML = str;
    }
}

// build the PAT
function buildPAT(ast){
    trace('u',"buildPAT",ast.shortly());
    patNFA = new PatStateTable();
    var si = patNFA.add("build_pat",ast.pos);     // allocate its initial state
    var sf = patNFA.add("build_pat",ast.pos);     // allocate its final state
    sf.isFinal = true;
    patBuild(ast,si,sf);                           // visit the ast recursively to build PAT 
    pat_purge(si);
    if ('u' in trc){
        trace('u',"buildPAT pat:");
        patNFA.strace(si,true);
    }
}

// visit the ast recursively to build PAT 
function patBuild(ast,is,fs){
    trace('v',"patBuild start",ast.shortly(),"endpoints",is.number,fs.number);
    if (ast.kind == 0){                              // leaf
        var cx = patNFA.add("leaf",ast.pos);         // allocate intermediate state
        newPatTrans(is,cx,ast.sym,newBSsymbol(astToBSele(ast,ELEOPEN)));
        newPatTrans(cx,fs,ANYSYMB,newBSsymbol(astToBSele(ast,ELECLOSE)));
    } else if (ast.kind == 1){                       // alt
        for (var i = ast.son; i != null; i = i.bro){
            var ci = patNFA.add("alt start");        // allocate temporary initial state
            var cf = patNFA.add("alt end");          // allocate temporary final state
            patBuild(i,ci,cf);
            pat_tags(ci,cf,ast);                     // parenthetize the tags
            pat_join(is,fs,ci,cf);                   // join
       }
    } else if (ast.kind == 2){                       // conc
        var ts = patNFA.add("conc start");           // allocate temporary initial state for first
        var cf = patNFA.add("conc end");             // allocate final state for first
        var curs = ts;
        var curf = cf;
        for (var i = ast.son; i != null; i = i.bro){
            if (i != ast.son){
                curs = patNFA.add("conc cur start"); // allocate initial state for second
                curf = patNFA.add("conc cur end");   // allocate temporary final state for second
            }
            patBuild(i,curs,curf);
            if (i != ast.son){
                pat_concatenate(ts,cf,curs);         // handle concatenation
                cf = curf;
            }
            trace('v',"patBuild: tags pos",ast.shortly(),"conc states",ts.number,"..",cf.number);
        }
        pat_tags(ts,cf,ast);                         // parenthetize the tags
        pat_join(is,fs,ts,cf);                       // join
    } else if (ast.kind == 4){                       // empty
        newPatTrans(is,fs,ANYSYMB,newBSsymbol(astToBSele(ast,ELEOPEN),astToBSele(ast,ELECLOSE)));
    } else {                                         // group
        var ci = patNFA.add("group start");          // allocate temporary initial state
        var cf = patNFA.add("group end");            // allocate temporary final state
        var s1;
        var s2;
        switch (ast.groupKind){
        case G_GRO:
            patBuild(ast.son,ci,cf);                 // expand its graph
            trace('v',"patBuild: gro tags pos",ast.shortly());
            pat_tags(ci,cf,ast);                     // parenthetize the tags
            pat_join(is,fs,ci,cf);                   // join
            break;
        case G_OPT:                                  // optional group
            patBuild(ast.son,ci,cf);                 // expand its graph
            newPatTrans(ci,cf,ANYSYMB,newBSsymbol(astToBSele(ast,ELEOPEN),astToBSele(ast,ELECLOSE))); // bypass
            trace('v',"patBuild: opt tags pos",ast.shortly());
            pat_tags(ci,cf,ast);                     // parenthetize the tags
            pat_join(is,fs,ci,cf);                   // join
            break;
        case G_RE0:                                  // kleene group
            patBuild(ast.son,ci,cf);                 // expand its graph
            pat_plus(ci,cf);
            newPatTrans(ci,cf,ANYSYMB,newBSsymbol());   // bypass
            trace('v',"patBuild: g_re0 tags pos",ast.shortly());
            pat_tags(ci,cf,ast);                     // parenthetize the tags
            pat_join(is,fs,ci,cf);                   // join
            break;
        case G_RE1:                                  // +
            patBuild(ast.son,ci,cf);                 // expand its graph
            pat_plus(ci,cf);
            newPatTrans(ci,cf,ANYSYMB,newBSsymbol());   // bypass
            trace('v',"patBuild: g_re1 tags pos",ast.shortly());
            pat_tags(ci,cf,ast);                     // parenthetize the tags
            pat_join(is,fs,ci,cf);                   // join
            break;
        }
    }
    if ('u' in trc){
        trace('u',"patBuild done:",ast.toRE(true),ast.shortly());
        patNFA.strace(is);
    }
}

// join two PATs
function pat_join(is1,fs1,is2,fs2){
    var pr = null;
    for (t = is1.transList; t != null; t = t.next){  // find last transition
        pr = t;
    }
    for (t = is2.transList; t != null; t = t.next){  // add start transitions of second to first
        if (pr == null){
            is1.transList = t;
        } else {
            pr.next = t;
        }
        pr = t;
    }
            
    var dp = 0;
    var qp = 0;
    var queue = [];
    queue[qp++] = is1;   // start from it
    while (dp != qp){                           // while queue not empty
        var s = queue[dp++];
        loop: for (t = s.transList; t != null; t = t.next){  // find edge or last
            var newtags = null;
            var ts = t.nextState;
            if (ts == fs2){                     // end state of second
                t.nextState = fs1;
            } else if (ts == is2){
                t.nextState = is1;
            }
            for (var j = 0; j < qp; j++){
                if (queue[j] == t.nextState) continue loop;    // already visited
            }
            queue[qp++] = t.nextState;        // enqueue it
        }
    }
    trace('v',"pat_joined:",is1.number,"<-",is2.number,fs1.number,"<-",fs2.number);
}

// parenthetize the tags of arcs that start/end from/to the initial/final states
function pat_tags(is,fs,ast){
    if ('v' in trc){ 
        trace('v',"pat_tags states",is.number,fs.number,"pos",ast.shortly());
        patNFA.strace(is);
    }
    var dp = 0;
    var qp = 0;
    var queue = [];
    queue[qp++] = is;   // start from it
    while (dp != qp){                           // while queue not empty
        var s = queue[dp++];
        loop: for (t = s.transList; t != null; t = t.next){  // find edge or last
            var newtags = null;
            var ts = t.nextState;
            if (s == is){                       // start state
                if (ts == fs){                  // end state
                    newtags = newBSsymbol(astToBSele(ast,ELEOPEN),t.tag,astToBSele(ast,ELECLOSE));
                } else {
                    newtags = newBSsymbol(astToBSele(ast,ELEOPEN),t.tag);
                }
                t.tag = newtags;
            } else if (ts == fs){
                newtags = newBSsymbol(t.tag,astToBSele(ast,ELECLOSE));
                t.tag = newtags;
            }
            for (var j = 0; j < qp; j++){
                if (queue[j] == t.nextState) continue loop;    // already visited
            }
            queue[qp++] = t.nextState;        // enqueue it
        }
    }
    if ('v' in trc){ 
        trace('v',"pat_tags done",is.number,fs.number,"pos",ast.shortly());
        patNFA.strace(is);
    }
}

// concatenate the sub-dfas, the first starting at is and ending at fs, and the second starting
// at is2 and ending at its final state
function pat_concatenate(is,fs,is2){
    trace('v',"pat_concatenate",is.number,"..",fs.number,"+",is2.number,"..");
    var dp = 0;
    var qp = 0;
    var queue = [];
    queue[qp++] = is;   // start from it
    while (dp != qp){                              // while queue not empty
        var s = queue[dp++];
        loop: for (t = s.transList; t != null; t = t.next){  // find edge or last
            var ts = t.nextState;
            if (s == is2) continue;                // start state of second
            if (ts == fs){                         // end state
                var ttag = t.tag;
                for (u = is2.transList;
                    u != null; u = u.next){        // transitions of second from initial state
                    trace('v',"pat_concatenate",t,"+",u);
                    // is2 there can be many: reuse trans t, and create new ones for the others
                    var tr = t;
                    if (u != is2.transList){       // not first: create a new one
                        tr = new PatTrans();
                    }
                    tr.nextState = u.nextState;
                    tr.tag = newBSsymbol(ttag,u.tag);
                    tr.sym = u.sym;
                    if (u != is2.transList){       // not first: create a new one
                        tr.next = t.next;
                        t.next = tr;
                    }
                    trace('v',"pat_concatenate joined",tr);
                }
            }
            for (var j = 0; j < qp; j++){
                if (queue[j] == t.nextState) continue loop;    // already visited
            }
            queue[qp++] = t.nextState;        // enqueue it
        }
    }
}

// build the pat for a repetition group
function pat_plus(is,fs){
    trace('v',"pat_plus",is.number,"..",fs.number);
    var dp = 0;
    var qp = 0;
    var queue = [];
    queue[qp++] = is;   // start from it
    while (dp != qp){                              // while queue not empty
        var s = queue[dp++];
        loop: for (t = s.transList; t != null; t = t.next){  // find edge or last
            var ts = t.nextState;
            if (s != is && ts == fs){                          // end state
                for (u = is.transList;
                    u != null; u = u.next){                    // edges from initial state
                    if (u.nextState == fs) continue;
                    trace('v',"pat_plus",t,"+",u);
                    newPatTrans(s,u.nextState,u.sym,newBSsymbol(t.tag,u.tag));  // loopback
                    trace('v',"pat_plus done\n",t);
                }
            }
            for (var j = 0; j < qp; j++){
                if (queue[j] == t.nextState) continue loop;    // already visited
            }
            queue[qp++] = t.nextState;        // enqueue it
        }
    }
    if ('v' in trc){
        trace('v',"pat_plus: end");
        patNFA.strace(is);
    }
}

// purge the transitions of the specified state
function pat_purge_trans(s){
    trace('v',"pat_purge_trans state",s.toId());
    var pr = null;
    for (t = s.transList; t != null; t = t.next){      // visit transitions
        for (u = t.next; u != null; u = u.next){       // visit all others
            if (t.nextState != u.nextState ||                 // take only the ones that ..
                t.sym != u.sym) continue;                     // .. have same states and symbols
            var cmp = pat_comp_tags(t.tag,u.tag);
            trace('v',"pat_purge_trans state",t.tag.toNoHtmlString(),u.tag.toNoHtmlString(),cmp);
            if (cmp > 0){                                     // tag of first less prior or equal
                if (pr == null){                              // remove it
                    s.transList = t.next;
                } else {
                    pr.next = t.next;
                }
                trace('v',"pat_purge_trans remove",t);
            } else if (cmp < 0){                              // remove the other
                var p = t;
                for (v = t.next; v != u; v = v.next){
                    p = v;
                }
                if (p == t){
                    t.next = u.next;
                } else {
                    p.next = u.next;
                }
                trace('v',"pat_purge_trans remove",u);
            }
        }
        pr = t;
    }
}

// purge the transitions of the reacheable states
function pat_purge(is){
    var dp = 0;
    var qp = 0;
    var queue = [];
    queue[qp++] = is;   // start from it
    while (dp != qp){                           // while queue not empty
        var s = queue[dp++];
        s.isReacheable = true;
        pat_purge_trans(s);
        loop: for (t = s.transList; t != null; t = t.next){  // find edge or last
            for (var j = 0; j < qp; j++){
                if (queue[j] == t.nextState) continue loop;    // already visited
            }
            queue[qp++] = t.nextState;        // enqueue it
        }
    }
}

// the data representing the comparison of all the tags of the last transition in matching
function PATDataClass(){
    this.prev = null;
    this.K = new SetClass();
    this.B = [];    // rho
    this.D = [];    // â
    this.P = [];
    this.BA = [];    // audit trail of B
    this.DA = [];    // audit trail of D
}

// deliver the value at the specified indexes in the matrix, or the default value if undefined
function val(matrix,i,j,def){
    var res = def;
    if (typeof(matrix[i]) != "undefined" &&
        typeof(matrix[i][j]) != "undefined"){
        res = matrix[i][j];
    }
    return res;
}

var PATdashBoard;                   // the matrix to draw the table of the matches
// match the string using the pat
function matchPAT(test,text,pat){
    error = false;
    trace('k',"matchPat start RE:",astRoot.toRE(true),"text",text);
    var head = null;
    cursor = 0;
    patTransSeq = 0;                         // serial nr of transitions
    var data = new PATDataClass();
    var headData = data;
    data.K.add(patNFA.head);                 // k = {q^}
    trace('k',"matchPat init",kToString(data.K));

    PATdashBoard = [];
    var trans = null;
    for (var i = 0; i <= text.length; i++){
        var sym = EOF;
        if (i < text.length) sym = text[i];
        if ('k' in trc){
            trace('k',"matchPat at:",i,"sym",sym);
        }
        var dash = [];
        PATdashBoard[i] = dash;
        trans = PATeffectiveTransitions(data,sym,ele,trans,dash,test,i);  // choose transitions available for this step
        data = PATproceedOneStep(data,i,trans);                    // update D, P, K and B accordingly
        data.prev = headData;
        headData = data;

        if (data.K.contains(patNFA.head.suc)){         // K contains the final state q$
            // discard all non-leftmost matches: the ones that start later in the string
            // than the one that has already been found (i.e. the one that ends in the final
            // state just reached
            // P[q][(Î] holds the cursor at which the path ending in q started.
            // (P[q][(Î] = -1 iff the path does not have started yet; i.e.,the path remains
            // in the initial state.)
            // N.B. this is not really needed in this implementation because PATs do not
            // have an autoedge in the initial state to make them match strings that start
            // at a cursor > 0

            var close = "("+ posToString(patNFA.head.name); // q^
            var pfinal = val(data.P,patNFA.head.suc.number,
                close,-1);
            var arr = data.K.toArray();
            for (var j = 0; j < arr.length; j++){
                var q = arr[j];
                if (val(data.P,q.number,close,-1) > pfinal || val(data.P,q.number,close,-1) == -1){
                    data.K.remove(arr[j]);       // from K drop all q such that P[q][(^] > P[q$][(^] or P[q][(^] = -1
                    trace('j',"matchPAT, state removed",arr[j],q.number,close,val(data.P,q.number,close,-1),pfinal);
                }
            }
            if (data.K.size() == 1) break;            // K contains only q$
        }
    }

    if (!data.K.contains(patNFA.head.suc)){   // K does not contain the final state q$
        error = true;
        errorMessage = "not matched";
        return;
    }
    if (!test){
        if (error){                  // error or whole re not consumed
            var ele = document.getElementById("text");
            ele.selectionStart = cursor; // show the error
            ele.selectionEnd = text.length;
            ele.focus();
            document.getElementById("error").textContent = "not matched";
        } else {
            document.getElementById("result").textContent = "matched";
        }
    }
    trace('k',"matchPAT end RE:",ast.toRE(true),"text",text,error ? "failure" : "success");
    if ('k' in trc){
        for (var i = trans; i != null; i = i.prev){
            twriteln(i);
        }
    }
    trace('k',"matchPAT end");

    var linearTree = newBSsymbol();
    for (var i = trans; i != null; i = i.prev){
        // the symbol is actually the ast node with the same pos as the last element
        // of the tag, except when the symbol is eof, which is matched only in ANYSMB
        // edges, in which case it is the eof ast
        var s = BSeleToAstNum(i.tag.eleAt(-1));
        if (i.sym == EOF) s = astToBSele(eofAst,0);
        linearTree = newBSsymbol(i.tag,s,linearTree);
    }
    trace('k',"matchPAT check",linearTree.toNoHtmlString());

    if (test) return linearTree;

    if (document.getElementById("patProgress").checked){
        // draw a table containing the transitions done, the winners at convergence and
        // the reason for wictory

        // mark the winning path, display the ones that converge, winner first, and then each other,
        // with the reason for the loss
        for (var i = trans; i != null; i = i.prev){
            i.isFinal = true;
        }
        var str = "PAT match and prio tree finding steps:<p><table class=rho border=\"1\" data-dash=PATdashBoard>";
        str += "<tr>";
        var h = 0;
        for (var i = 0; i < PATdashBoard.length; i++){
            h = Math.max(h,PATdashBoard[i].length);
            str += "<td colspan=2>" + i + "</td><td></td>";
        }
        str += "</tr>";
        for (var i = 0; i < h; i++){
            str += "<tr>";
            for (var j = 0; j < PATdashBoard.length; j++){
                var empty = true;
                var cell = "";
                var handler = "";
                if (typeof(PATdashBoard[j]) != "undefined" &&
                    typeof(PATdashBoard[j][i]) != "undefined"){
                    var t = PATdashBoard[j][i];
                    if (t instanceof PATTrans){
                        var st = "";
                        if (t.prev != null){
                            st += t.prev.seq + "&larr;";
                        }
                        st += t.serial() + ":";
                        var color = "Lavender";
                        if (t.seq >= 0){
                            if (t.isFinal) color = "Aqua";
                        } else {
                            color = "AntiqueWhite";
                        }
                        str += "<td style=\"background-color:" + color + ";\">" + st + "</td>";
                        str += "<td style=\"background-color:" + color + ";\">" + t.tag  + "</td>";
                    } else {
                        str += "<td></td><td onmouseenter=showPostit(this) onmouseleave=hidePostit(this)>" + t[0] +
                            "<div class=post style=\"display:none; border:1px solid black; background-color: LemonChiffon; padding: 5px; position:absolute\">" +
                            t[1] + "</div></td>";
                        handler = " onclick=showWinnerLoser(this) data-r= " + i + " data-c=" + j;
                    }
                    empty = false;
                } else {
                    str += "<td colspan=2></td>";
                }
                if (handler == ""){
                    var sym = EOF;
                    if (j < text.length) sym = text[j];
                    if (empty) sym = "";
                    str += "<td>&nbsp;" + sym + "&nbsp;</td>";
                } else {
                    str += "<td" + handler + " style=\"cursor:pointer;\">&nbsp;&#x25b6;&nbsp;</td>";
                }
            }
            str += "</tr>";
        }
        str += "</table>";
        // legenda
        str += "<p style=\"font-size:9pt;\">Legenda: <span style=\"background-color:Aqua;\">prior tree steps</span>, " +
            "<span style=\"background-color:Lavender;\">prior steps</span>, " +
            "<span style=\"background-color:AntiqueWhite;\">less prior of steps above, hover below for details</span>, " +
            "<span style=\"background-color:Aquamarine;\">common prefix</span>, "+
            "<br><span style=\"background-color:LemonChiffon;\">history</span>, "+
            "&#x25b6; show history, â¼ hide history, "+
            "<span style=\"background-color:Aqua;\">height</span>, "+
            "<span style=\"background-color:LightSalmon;\">subset</span>, "+
            "n<sub>m</sub>: step n at frame m";
        document.getElementById("patdash").innerHTML = str;
    }
    return linearTree;
}

// compute the X of the specified element with respect to the document
function getX(element){
    var x = 0;
    for (var e = element; e; e = e.offsetParent){
        x += e.offsetLeft;
    }
    for (var e = element.parentNode; e && e != document.body; e = e.parentNode){
        if (e.scrollLeft) x -= e.scrollLeft;  // subtract scrollbar values
    }
    return x;
}

// compute the Y of the specified element with respect to the document
function getY(element){
    var y = 0;
    for (var e = element; e; e = e.offsetParent){
        y += e.offsetTop;
    }
    for (var e = element.parentNode; e && e != document.body; e = e.parentNode){
        if (e.scrollTop) y -= e.scrollTop;  // subtract scrollbar values
    }
    return y;
}

// display the postit for the reason of the choice of transitions
// N.B. the postit is generated as a son of the table cell so as to use the mouseenter
// and mouseleave handlers, that detect the entering and leaving of the mouse pointer
// in an element, but not on one it its children, including then the postit
function showPostit(ele){
    var children = ele.childNodes;
    for (var i = 0; i < children.length; i++){
        var chi = children[i];
        if (chi.className == "post"){
            chi.style.display = "block";
            chi.style.left = "0px";
            chi.style.top = "0px";
            var width = chi.offsetWidth;
            var height = chi.offsetHeight;
            if (getX(ele) + width > document.body.scrollWidth){   // overflows right
                chi.style.left = (getX(ele) - width) + "px";
            } else {
                chi.style.left = getX(ele) + "px";
            }
            if (getY(ele) + 20 + height > document.body.scrollHeight){   // overflows bottom
                chi.style.top = (getY(ele) - height) + "px";
            } else {
                chi.style.top = (getY(ele) + 20) + "px";
            }
            chi.style.width = width + "px";
            break;
        }
    }
}

// hide the postit for the reason of the choice of transitions
function hidePostit(ele){
    var children = ele.childNodes;
    for (var i = 0; i < children.length; i++){
        var chi = children[i];
        if (chi.className == "post"){
            chi.style.display = "none";
            break;
        }
    }
}

// deliver a string representing the set K
function kToString(set){
    var str = "";
    var arr = set.toArray();
    for (var i = 0; i < arr.length; i++){
        if (i > 0) str += " ";
        str += arr[i].stateName();
    }
    return str;
}

// a transition in the pat matching
function PATTrans(){
    this.seq = 0;              // serial number, only for tracing
    this.next = null;          // reference to next transition
    this.prev = null;          // reference to previous transition
    this.from = null;          // from state
    this.to = null;            // to state
    this.tag = newBSsymbol();  // tag
    this.sym = 0;              // symbol
    this.isFinal = false;      // whether this transition belong to the path of the prior tree

    // deliver a string representing this transition
    this.toString = function(){
        return this.seq + ": " + this.from.stateName() + "--" +
            (this.tag == null ? "null" : this.tag.toNoHtmlString()) + "," +
            this.sym + "-->" + this.to.stateName();
    }

    // deliver a string representing the serial nr of this transition
    this.serial = function(){
        var str = "";
        if (this.seq < 0){
            str += "â ";
        } else {
            str += this.seq;
        }
        return str;
    }
}

var patTransSeq;    // serial numbers of PATTrans

// Determines the transitions to the next states, choosing when there are some that
// converge to a same state
function PATeffectiveTransitions(data,sym,ele,trans,dashb,test,n){
    trace('k',"PATeffectiveTransitions",sym,kToString(data.K));
    var prevtrans = trans;
    trans = null;
    var tail = null;
    var karr = data.K.toArray();
    for (var i = 0; i < karr.length; i++){
        var s = karr[i];
        var p = s.number;
        trace('j',"PATeffectiveTransitions state",s.toId());
        for (t = s.transList; t != null; t = t.next){  // visit edges
            if (t.sym != ANYSYMB && t.sym != sym) continue;
            // this is superfluous
            if (t.tag == null) continue;
            var sq = t.nextState;
            var q = sq.number;
            trace('j',"PATeffectiveTransitions edge",s.toId(),t);

            // for all state q in Qa such that tag(p, q) != _|_ for some p in K
            // i.e. take a state p in K, then all states q reached transiting from p with sym
            // such that there is at least an edge with tag defined

            // take the set of states reached from the states in K with edges with tags defined
            // take one state in K, and for all other states in K (the test on tag(p',q) at line 4, algo 2 is superfluous

            // for all states p' in K' such that tag(p',q) != _|_
            var news = s;
            var newp = p;
            for (var j = 0; j < karr.length; j++){
                var sp = karr[j];
                var pp = sp.number;
                if (pp == p) continue;          // K' = K\{p}: do not consider p
                var tagppq = tag(sp,sq);
                if (tagppq == null) continue;
                // if (tagppq == null || tagppq.length == 0) continue;
                // this is never the case on the first step because if there are two edges
                // from the start state that converge, they were removed when the NFA was purged
                var pa = data.B[newp][pp];
                var rho = pa[0];
                var rhop = pa[1];             // <rho, rho'> = B[p][p']
                rho = Math.min(rho,pat_minsp(tag(news,sq)));
                rhop = Math.min(rhop,pat_minsp(tagppq));
                trace('k',"PATeffectiveTransitions competing trans",
                    "<"+s.stateName()+","+sq.stateName()+","+PATgetTrans(s,sq).tag.toNoHtmlString()+">",
                    "<"+sp.stateName()+","+sq.stateName()+","+PATgetTrans(sp,sq).tag.toNoHtmlString()+">",
                    "rho",rho,"rho'",rhop,"D",data.D[pp][p]);
                var cmp = PATtracePaths(prevtrans,s,sp,sq,sym);
                // p = p' if rho < rho' or rho = rho' and D[p'][p] = 1
                var cmp1 = -1;
                if (rho < rhop || rho == rhop && data.D[pp][p] == 1){
                    newp = pp;
                    news = sp;
                    trace('j',"PATeffectiveTransitions new wins");
                    cmp1 = 1;
                }
                if (cmp != cmp1){
                    error = true;
                    errorMessage = "tr error";
                }
            }
            // add <p, q, tag(p, q)> to trans
            var newt = null;
            add: {
                var tagpq = tag(news,sq);
                for (var i = trans; i != null; i = i.next){
                    if (i.from == news && i.to == sq && i.tag.equals(tagpq)) break add;  // duplicate
                }
                newt = new PATTrans();
                newt.seq = patTransSeq++;
                newt.from = news;
                newt.to = sq;
                newt.tag = tagpq;
                newt.sym = sym;
                for (var i = prevtrans; i != null; i = i.next){
                    if (i.to == news){
                        newt.prev = i;
                        break;
                    }
                }
                if (tail == null){
                    trans = newt;
                } else {
                    tail.next = newt;
                }
                tail = newt;
            }
            if (!test){
                // the winner: news
                dashb.push(newt);
                // all the others, each with the pair of rho, or if equal the D
                for (var j = 0; j < karr.length; j++){
                    var sp = karr[j];
                    var pp = sp.number;
                    if (pp == newp) continue;          // K' = K\{p}: do not consider p
                    var tagppq = tag(sp,sq);
                    if (tagppq == null) continue;
                    var pa = data.B[newp][pp];
                    var rho = pa[0];
                    var rhop = pa[1];             // <rho, rho'> = B[p][p']
                    rho = Math.min(rho,pat_minsp(tag(news,sq)));
                    rhop = Math.min(rhop,pat_minsp(tagppq));
                    PATtracePaths(prevtrans,news,sp,sq,sym);
                    // p = p' if rho < rho' or rho = rho' and D[p'][p] = 1
                    var nt = new PATTrans();
                    nt.seq = -1;
                    nt.from = sp;
                    nt.to = sq;
                    nt.tag = tagppq;
                    nt.sym = sym;
                    for (var i = prevtrans; i != null; i = i.next){
                        if (i.to == sp){
                            nt.prev = i;
                            break;
                        }
                    }
                    dashb.push(nt);
                    var strl = "";
                    strl += " because: ";

                    var strs = "";
                    // determine the origin of rho and D
                    var pa = data.B[newp][pp];
                    var prevrho = pa[0];
                    var prevrhop = pa[1];                   // <rho, rho'> = B[p][p']
                    var updrho = pat_minsp(tag(news,sq));
                    var updrhop = pat_minsp(tag(sp,sq));
                    var rho = Math.min(prevrho,updrho);
                    var rhop = Math.min(prevrhop,updrhop);
                    var hooks = {"t":newt,"tp":nt,"n":n};   // to show the history
                    if (rho > rhop){
                        // looses because of rho
                        var gb = null;
                        if (prevrho > updrho){
                            // rho here
                            hooks.w = newAudit(9,n,rho,data.BA[newp][pp][1],newt,nt);
                            gb = getB(hooks.w);
                        } else {
                            // rho from prev
                            hooks.w = data.BA[newp][pp][0];
                            gb = getB(hooks.w);
                        }
                        strs += gb[0];                     // short reason
                        strs += " \u22d6 ";
                        strl += "<br>Ï<sub>" + newt.serial() + "</sub> = " + rho + ": " + gb[1];
                        if (prevrhop > updrhop){
                            // rhop here
                            hooks.wp = newAudit(9,n,rhop,data.BA[newp][pp][1],nt,newt);
                            gb = getB(hooks.wp);
                        } else {
                            // rhop from prev
                            hooks.wp = data.BA[newp][pp][1];
                            gb = getB(hooks.wp);
                        }
                        strs += gb[0];                      // short reason
                        strl += "<br>Ï<sub>" + nt.serial() + "</sub> = " + rhop + ": " + gb[1];
                    } else if (data.D[newp][pp] == 1){
                        // looses because of D
                        trace('j',"PATeffectiveTransitions D",newp,pp);
                        var da = data.DA[newp][pp];
                        hooks.w = da;
                        hooks.wp = da;
                        gb = getD(da);
                        strs += gb[0];             // short reason
                        strl += "Ï<sub>" + newt.serial() + "</sub>, Ï<sub>" + nt.serial() + "</sub> = " + rho;
                        strl += " but once"
                        strl += "<br>" + gb[1];             // long reason
                    }
                    dashb.push([strs,strl,hooks]);
                    trace('j',"PATeffectiveTransitions reason",strs,"long",strl);
                }
            }
        }
    }
    if ('k' in trc){
        trace('k',"PATeffectiveTransitions res:");
        for (var t = trans; t != null; t = t.next){
            twriteln(t);
        }
    }
    return trans;
}

// deliver an array containing the specified transition and the ones preceding it
function PATtransPath(prevtrans,p,q,sym){
    // trace('j',"PATtransPath p",p.number,q.number);
    // build a temporary one
    var newt = new PATTrans();
    newt.from = p;
    newt.to = q;
    newt.tag = tag(p,q);
    newt.sym = sym;
    for (var i = prevtrans; i != null; i = i.next){
        if (i.to == p){
            newt.prev = i;
            break;
        }
    }
    var n = 0;
    for (var i = newt; i != null; i = i.prev){
        n++;
    }
    var arr = [n];
    for (var i = newt; i != null; i = i.prev){
        arr[--n] = i;
    }
    return arr;
}

// trace the paths that have as last steps p->q and pp->q going backwards, and determine
// if one represents a tree that is prior to that of the other one
var trReason;
function PATtracePaths(prevtrans,p,pp,q,sym){
    var arr1 = PATtransPath(prevtrans,p,q,sym);
    var arr2 = PATtransPath(prevtrans,pp,q,sym);

    trace('j',"first");
    var rho1 = [];
    var fork = PATtr(arr1,arr2,rho1);

    trace('j',"second");
    var rho2 = [];
    PATtr(arr2,arr1,rho2);
    // n.b. the paths have the same length because they recognized the same string
    var reason = "";
    var prior1 = false;
    var prior2 = false;
    for (var i = rho1.length-1; i >= 0 ; i--){
        if (rho1[i] > rho2[i]){
            prior1 = true;
            trReason = "Ï " + rho1[i] + " > " + rho2[i] + ":" + i;
            break;
        } else if (rho2[i] > rho1[i]){
            trReason = "Ï " + rho1[i] + " < " + rho2[i] + ":" + i;
            prior2 = true;
            break;
        }
    }
    if (!prior1 && !prior2){
        var cmp = pat_subset_tags(arr1[fork].tag,arr2[fork].tag);
        if (cmp < 0){
            prior1 = true;
            trReason = " â " + fork;
        } else if (cmp > 0){
            prior2 = true;
            trReason = " â " + fork;
        } else {
            twriteln("!!! uncomparable paths\n");
        }
    }
    trace('j',prior1 ? "first": "second","prior");
    if (prior1) return -1;
    if (prior2) return 1;
    return 0;
}

// compute the tr function on the specified sequences of tags
function PATtr(arr1,arr2,rho1){
    var fork = 0;
    var rho = -1;
    for (var i = 0; i < arr1.length; i++){
        var t1 = arr1[i];
        var t2 = arr2[i];
        if (!t1.tag.equals(t2.tag) && (rho < 0)){
            rho = pat_bp0(t1.tag,t2.tag);
            fork = i;
        } else if (rho >= 0){
            rho = Math.min(rho,pat_minsp(t1.tag));
        }
        rho1[i] = rho;
        trace('j',"tr",arr1[i],"rho",rho);
    }
    return fork;
}

// deliver the tag from the state p to state q
// N.B. There is only one arc beteen p and q because all incoming transitions of q have 
// the same symbol, that is a, as q is in Q_a. So, tag(p,q) denotes a unique 
// sequence of parentheses.
// N.B. if there is an arc from p to q, the tag is always defined (possibly empty)
function tag(p,q){
    var res = null;
    for (var t = p.transList; t != null; t = t.next){  // visit edges
        if (t.nextState == q){
            res = t.tag;
            if (res == null) res = [];   // in case it is null
            break;
        }
    }
    //trace('j',"tag",p.toId(),"->",q.toId(),":",res.toNoHtmlString());
    return res;
}

// deliver the edge from the state p to state q
function PATgetTrans(p,q){
    for (var t = p.transList; t != null; t = t.next){  // visit edges
        if (t.nextState == q){
            return t;
        }
    }
    return null;
}

// update the pat matching variables
function PATproceedOneStep(data,n,t){
    trace('k',"PATproceedOneStep step",n,"trans",t);
    var prev = data;
    data = new PATDataClass();

    data.K.clear();
    // K = {q such that <any,q,any> in trans}
    for (var i = t; i != null; i = i.next){
        data.K.add(i.to);
    }
    trace('k',"PATproceedOneStep new K",kToString(data.K));

    // It is also possible to treat the case q_$ separately.
    // Note that minsp(alpha), and hence the rho-value, is always zero for any
    // incoming transition alpha of q_$ (e.g., A11, A12, A4 ...).
    // Hence, the calculation at line 3 to 14 is significantly simplified in case
    // either q or q'  is q_$.  

    //for all <p, q, alpha>, <p', q', alpha'> in trans such that q <. q' {
    loop: for (var i = t; i != null; i = i.next){
        var q = i.to.number;
        var p = i.from.number;
        for (var j = t; j != null; j = j.next){
            if (j == i) continue;
            var qp = j.to.number;
            var pp = j.from.number;
            // trace('j',"PATproceedOneStep cmp",i.to,j.to,
            //     i.to.compareTo(j.to));
            if (i.to.compareTo(j.to) >= 0) continue;

            trace('j',"PATproceedOneStep","<"+i.from.stateName()+","+i.to.stateName()+
                ","+i.tag.toNoHtmlString()+">",
                "<"+j.from.stateName()+","+j.to.stateName()+","+j.tag.toNoHtmlString()+">");
            var rho = 0;
            var rhop = 0;
            if (i.from == j.from){              // p = p'
                // here we have two transitions from the same state leading to different
                // states: in a NFA from a state there can be several arcs with the same
                // symbol
                var cmp = pat_subset_tags(i.tag,j.tag);
                trace('j',"PATproceedOneStep cmp",
                    i.tag.toNoHtmlString(),
                    j.tag.toNoHtmlString(),":",
                    cmp < 0 ? "prior" : "not prior");
                // to compare two tags, take away the common prefix, then the first
                // is prior if it starts with (p and the second: starts with )q or
                // with (q with p <. q
                // bp0(a,b): take away the common prefix from "a" except for the last element,
                // bp0 is the minimum height in it
                rho = pat_bp0(i.tag,j.tag);               // rho = bp0(alpha,alpha');
                rhop = pat_bp0(j.tag,i.tag);              // rho' = bp0(alpha',alpha)

                if (data.D[q] == null) data.D[q] = [];
                if (rho > rhop){
                    data.D[q][qp] = 1;               // D[q][q'] = 1 if rho > rho';
                    mSet(data.DA,q,qp,newAudit(3,n,rho,rhop,i,j));
                } else if (rho < rhop){
                    data.D[q][qp] = -1;              // D[q][q'] = -1 if rho < rho';
                    mSet(data.DA,qp,q,newAudit(3,n,rhop,rho,j,i));
                } else if (cmp < 0){
                    data.D[q][qp] = 1;               // D[q][q'] = 1 if alpha â alpha';
                    mSet(data.DA,q,qp,newAudit(1,n,rho,rhop,i,j));
                } else if (cmp > 0){
                    data.D[q][qp] = -1;              // D[q][q'] = 1 if alpha â alpha';
                    mSet(data.DA,qp,q,newAudit(1,n,rhop,rho,j,i));
                }
                var wrho = newAudit(8,n,rho,rhop,i,j);
                var wrhop = newAudit(8,n,rhop,rho,j,i);
                mSet(data.BA,q,qp,[wrho,wrhop]);
                mSet(data.BA,qp,q,[wrhop,wrho]);
            } else {
                var Bp = prev.B[p][pp];                   // assign rho and rho'
                rho = Bp[0];
                rhop = Bp[1];                             // <rho, rho'> = B'[p][p']
                var mrho = pat_minsp(i.tag);
                rho = Math.min(rho,mrho);                 // rho = min{rho, minsp(alpha)};
                var mrhop = pat_minsp(j.tag);
                rhop = Math.min(rhop,mrhop);              // rho' = min{rho', minsp(alpha')};
                var wrho = prev.BA[p][pp][0];
                if (mrho < Bp[0]){                   // new rho
                    wrho = newAudit(9,n,rho,prev.BA[p][pp][0],i,j);
                }
                var wrhop = prev.BA[p][pp][1];
                if (mrhop < Bp[1]){        // new rhop
                    wrhop = newAudit(9,n,rhop,prev.BA[p][pp][1],j,i);
                }
                mSet(data.BA,q,qp,[wrho,wrhop]);
                mSet(data.BA,qp,q,[wrhop,wrho]);

                if (data.D[q] == null) data.D[q] = [];
                if (rho > rhop){
                    data.D[q][qp] = 1;               // D[q][q'] = 1 if rho > rho';
                    mSet(data.DA,q,qp,newAudit(6,n,rho,rhop,i,j,wrho,wrhop));
                } else if (rho < rhop){
                    data.D[q][qp] = -1;              // D[q][q'] = -1 if rho < rho';
                    mSet(data.DA,qp,q,newAudit(6,n,rhop,rho,j,i,wrhop,wrho));
                } else {
                    data.DA[q][qp] = prev.DA[p][pp];
                    data.DA[qp][q] = prev.DA[pp][p];
                }
            }
            mSet(data.D,qp,q,-data.D[q][qp]);   // D[q'][q] = -D[q][q']
            mSet(data.B,q,qp,[rho,rhop]);       // B[q][q'] = <rho, rho'>;
            mSet(data.B,qp,q,[rhop,rho]);       // B[q'][q] = <rho', rho>

            trace('j',"PATproceedOneStep data B:",
                priorDataToString("B",data.B,q,qp,data.B[q][qp]),
                priorDataToString("D",data.D,q,qp,data.D[q][qp]));

        }
    }
    for (var i = t; i != null; i = i.next){       // for all <p,q,alpha> in trans
        var q = i.to.number;
        if (typeof(prev.P[p]) != "undefined"){
            data.P[q] = [];
            for (var j in prev.P[p]){
                data.P[q][j] = prev.P[p][j];            // P[q] = P'[p]
            }
        }
        for (var j = 0; j < i.tag.length(); j++){         // for all the tags in alpha
            var idx = BSeleToString(i.tag.eleAt(j),true);
            mSet(data.P,q,idx,n);   // P[q][x] = n;            
            trace('j',"PATproceedOneStep P",q+"("+i.to.stateName()+")",idx,n);
        }
    }
    trace('k',"PATproceedOneStep end");
    return data;
}

// deliver a string representing the specified value
function priorDataToString(name,arr,i,j,val){
    var str = name + "[" + i + "][" + j + "]: " + val;
    return str;
}
</script>
<script>
var featureName;         // the name of the feature under testing
var ckshow = false;      // whether the heading of the tests cases are traced
var testErrors = 0;      // number of tests failed

// defines the feature for the following test cases
function feature(s){
    featureName = s;
    if (ckshow) twriteln(featureName);
}

// traces the heading of the current test case, if enabled
function showTest(t){
    if (ckshow) twriteln("-- test " + featureName + " " + t + " ---");
}

// shows that the current test case failed
function trcfail(t){
    twriteln();
    twriteln("-- test " + featureName + " " + t + " failed ---");
    testErrors++;
}

// displays the reason of the failure of the current test case
function trcshow(s,e,a){
    twriteln(s + " expected: " + e + " actual: " + a);
}

// deliver the specified string with spaces removed
function removeSpaces(str){
    var s = "";
    for (var i = 0; i < str.length; i++){
        if (str[i] == " ") continue;
        s += str[i];
    }
    return s;
}

</script>
<script>
// ---------- Testing -----------------

// test that the ast generates the specified RE
function testAst(t,str,exp){
    showTest(t);
    re = str;
    buildAst(true);
    if (!error) bsDFA = buildBS(astRoot);
    var actual = "";
    if (error || getsym() != -1){    // error or whole re not consumed
        actual = "error";
    } else {
        actual = astRoot.toRE(true);
    }
    if (removeSpaces(actual) != removeSpaces(exp)){
        trcfail(t);
        trcshow("re",exp,actual);
    }
}

// test the parenthetised forms of trees
function testTree(t,str,text,exp){
    showTest(t);
    var actual = "error";
    doit: {
        re = str;
        buildAst(true);
        if (!error) bsDFA = buildBS(astRoot);
        if (error || getsym() != -1){    // error or whole re not consumed
            break doit;
        }
        var stateList = match(true,text,bsDFA);
        if (error) break doit;
        var tr = compareTrees(true,stateList);
        if (error) break doit;
        actual = tr.toNoHtmlString();
    }
    if (actual != exp){
        trcfail(t);
        trcshow("tree",exp,actual);
    }
}

function test(){
    BS_AUGM = true;
//ckshow = true;
    // ast
    feature("ast");
    testAst(1,"","Îµâ§");
    testAst(2,"a","aâ§");
    testAst(3,"a b","a1b2");
    testAst(4,"a b c","a1b2c3");
    testAst(5,"a|b","a1|b2");
    testAst(6,"a|b|c","a1|b2|c3");
    testAst(7,"(a)","(â§a1)â§");
    testAst(8,"(a)*","(â§a1)*â§");
    testAst(9,"(a)+","(â§a1)+â§");
    testAst(10,"(a b)","(â§a1.1 b1.2)â§");
    testAst(11,"(a|b)","(â§a1.1|b1.2)â§");
    testAst(12,"(a (b))","(â§a1.1(1.2 b1.2.1)1.2)â§");
    testAst(13,"[a]","[â§a1]â§");

    testAst(100,"()","(â§ Îµ1)â§");
    testAst(101,"|","Îµ1 | Îµ2");
    testAst(102,"a|","a1 | Îµ2");
    testAst(103,"()*","(â§ Îµ1)*â§");
    testAst(104,"[]","[â§ Îµ1]â§");

    testAst(200,"(","error");
    testAst(201,"(a","error");
    testAst(202,"[","error");

    // tree
    feature("tree");
    testTree(300,"a","a","(â§aâ§)â§â¢$");
    testTree(301,"aa","aa","(â§(1a1)1(2a2)2)â§â¢$");
    testTree(302,"a|b","a","(â§(1a1)1)â§â¢$");
    testTree(303,"a|b","b","(â§(2b2)2)â§â¢$");
    testTree(304,"(a)*","","(â§)â§â¢$");
    testTree(305,"(a)*","a","(â§(1a1)1)â§â¢$");
    testTree(306,"(a)*","aa","(â§(1a1)1(1a1)1)â§â¢$");
    testTree(307,"(a)+","a","(â§(1a1)1)â§â¢$");
    testTree(308,"(a)+","aa","(â§(1a1)1(1a1)1)â§â¢$");
    testTree(309,"(a)","a","(â§(1a1)1)â§â¢$");
    testTree(310,"[a]","","(â§)â§â¢$");
    testTree(311,"[a]","a","(â§(1a1)1)â§â¢$");
    testTree(312,"(a)*b","b","(â§(1)1(2b2)2)â§â¢$");
    testTree(313,"(a)*b","ab","(â§(1(1.1a1.1)1.1)1(2b2)2)â§â¢$");
    testTree(314,"aaab|aaac","aaac","(â§(2(2.1a2.1)2.1(2.2a2.2)2.2(2.3a2.3)2.3(2.4c2.4)2.4)2)â§â¢$");
    testTree(315,"(ab|(a)*)*","aba","(â§(1(1.1(1.1.1a1.1.1)1.1.1(1.1.2b1.1.2)1.1.2)1.1)1(1(1.2(1.2.1a1.2.1)1.2.1)1.2)1)â§â¢$");

    testTree(400,"","","(â§)â§â¢$");
    testTree(401,"()","","(â§(1)1)â§â¢$");
    testTree(402,"()*","","(â§(1)1)â§â¢$");
    testTree(403,"()+","","(â§(1)1)â§â¢$");
    testTree(404,"[]","","(â§(1)1)â§â¢$");

    // ambiguous
    testTree(500,"((a)*)*","aa","(â§(1(1.1a1.1)1.1(1.1a1.1)1.1)1)â§â¢$");
    testTree(501,"(a|b|ab)*","ab","(â§(1(1.3(1.3.1a1.3.1)1.3.1(1.3.2b1.3.2)1.3.2)1.3)1)â§â¢$");
    testTree(502,"(ab|a|b)*","abab","(â§(1(1.1(1.1.1a1.1.1)1.1.1(1.1.2b1.1.2)1.1.2)1.1)1(1(1.1(1.1.1a1.1.1)1.1.1(1.1.2b1.1.2)1.1.2)1.1)1)â§â¢$");
    testTree(503,"(a|ab)(bc|c)","abc","(â§(1(1.1(1.1.2(1.1.2.1a1.1.2.1)1.1.2.1(1.1.2.2b1.1.2.2)1.1.2.2)1.1.2)1.1)1(2(2.1(2.1.2c2.1.2)2.1.2)2.1)2)â§â¢$");
    testTree(504,"(a|a*)*","aa","(â§(1(1.2(1.2.1a1.2.1)1.2.1(1.2.1a1.2.1)1.2.1)1.2)1)â§â¢$");
    testTree(505,"a*|(a|b)*","aaa","(â§(1(1.1a1.1)1.1(1.1a1.1)1.1(1.1a1.1)1.1)1)â§â¢$");

settrc("mo");
settrc("");

// test empty bodies
}
</script>
<script>


// ---------- Main -----------------

var error;                // error flag
var errorMessage;         // error message
var STRUCTURED = false;

// clear the current web page of the data of a previous parse
function clearPage(){
    document.getElementById("error").textContent = "";
    document.getElementById("result").textContent = "";
    document.getElementById("annotated").innerHTML = "";
    document.getElementById("bsfirst").innerHTML = "";
    document.getElementById("bsfollow").innerHTML = "";
    document.getElementById("dfa").innerHTML = "";
    document.getElementById("astTree").innerHTML = "";
    document.getElementById("tree").innerHTML = "";
    document.getElementById("parenthtrees").innerHTML = "";
    document.getElementById("compareparenth").innerHTML = "";
    document.getElementById("patdash").innerHTML = "";
    document.getElementById("matchdash").innerHTML = "";
    document.getElementById("thepat").innerHTML = "";
    document.getElementById("dfasvg").innerHTML = "";
    document.getElementById("dfasvglabels").innerHTML = "";
    patNFA = null;
    bsDFA = null;
    stateList = null;

    document.getElementById("thedfa").style.display = "none";
}

// parse the re, the string against it, and display its results
function parse(){
//settrc("mp");
//tracecallback();
setTrace();
    trace('c',"parse start");
    doit: {
        if (error) break doit;
        clearPage();

        levelNumbering = true;
        if (document.getElementById("sequentialPos").checked){
            levelNumbering = false;
        }

//        STRUCTURED = document.getElementById("strGroups").checked;
        STRUCTURED = false;
//        BS_AUGM = document.getElementById("bsplus").checked;
        trace('c',"parse building ast");

        var ele = document.getElementById("re");
        re = ele.value;
        buildAst(false);
        if (error) break doit;
        trace('c',"parse building ast done");
        var prioKind = "posix";
        if (document.getElementById("greedyprio").checked){
            prioKind = "greedy";
        }
        if (document.getElementById("dfaOnly").checked){
            prioKind = "none";
        }
        bsDFA = buildBS(astRoot,prioKind);
        if (error) break doit;
        if (document.getElementById("thedfa").style.display == "block"){
            showbs();
        }

        trace('c',"parse matching");
        ele = document.getElementById("text");
        stateList = match(false,ele.value,bsDFA);
        trace('c',"parse matching done");
        if (error){
            stateList = null;
            break doit;
        }
        if (!BS_AUGM) break doit;

        if (document.getElementById("dfaOnly").checked){
            break doit;
        }
        trace('c',"parse choose");

        compareTrees(false,stateList,ele.value);
        if (error){
            document.getElementById("error").textContent = errorMessage;
            break doit;
        }

        trace('c',"parse building tree");
        var winner = buildTree(stateList);
        trace('c',"parse building tree done");

        trace('c',"parse building pat");
        var pat = buildPAT(astRoot);
        trace('c',"parse matching pat");
        var linearPatTree = matchPAT(false,ele.value,pat);
        if (winner != linearPatTree){
            error = true;
            errorMessage = "pat prior not correct";
        }

    } // doit
    error = false;
    trace('c',"parse end");
}
</script>
</head>
<body>
<h2>Regular Expressions Parse Trees <span style="font-size:9pt;font-weight:normal;">v1.9</span></h2>

<script>
// show the release notes
function shownews(){
    document.getElementById("news").style.display = "block";
}

// hide the release notes
function hidenews(){
    document.getElementById("news").style.display = "none";
}
</script>
<div id=news style="position:absolute; top:100px; left:100px; display:none; background:Beige; border:1px solid black; padding:10px; font-size:9pt;">
<div style="float:right;"><button onclick=hidenews()>X</button></div>
Release Notes:
<p>
v1.3:
<ol>
<li>Parse trees that mirror the AST
<li>Nodes in parse trees showing their kind
<li>Removed the Extended B&S checkbox, now the default
<li>Removed the Structured checkbox, now an issue of the ELR parser
</ol>
v1.4:
<ol>
<li>bug fix
<li>better drawing of tree comparison
</ol>
v1.5:
<ol>
<li>annotated REs have all parenteses indexed
<li>Îµ removed from AST digrams
<li>new method to avoid endless n-grams
</ol>
v1.6:
<ol>
<li>a* and a+ allowed
<li>matching done also with PAT to check that the result is the same
<li>DFA interactive graph
</ol>
v1.7:
<ol>
<li>animation
<li>display all the trees
</ol>
v1.8:
<ol>
<li>greedy matching
</ol>
v1.9:
<ol>
<li>optional sequential numbering
</ol>

</div>
<a href="javascript:shownews()">What's new</a>
<p>

<table>
<tr><td>RE:</td><td><input id=re></input></td>
<td>Syntax: r &rarr; &epsilon; | a | r r | r <code>|</code> r | (r) | [r] | (r)+ | (r)* | r* | r+, a &isin; &Sigma;</td></tr>
<tr><td>input:</td><td><input id=text></input></td></tr>
</table>

<p>
<!--
<input type="checkbox" id=bsplus checked=checked>extended B&S</input> 
<br>
<input type="checkbox" id=strGroups>structured *,+</input> 
-->

<input type="radio" id="posixprio" name="prio" checked=checked><label for="posixprio">Posix</label>
<input type="radio" id="greedyprio" name="prio"><label for="greedyprio">greedy</label>

<div id=treesCheckBoxes>
<br>
<input type="checkbox" id=basicCompare><label for=basicCompare>show trees comparison</label> 
<br>
<input type="checkbox" id=algoProgress><label for=algoProgress>show prior tree finding steps</label>
<br>
<input type="checkbox" id=showAllTrees><label for=showAllTrees>show all trees</label>
<br>
<input type="checkbox" id=sequentialPos><label for=sequentialPos>use sequential numbering</label>
<br>
<input type="checkbox" id=dfaOnly><label for=dfaOnly>produce DFA, no disambiguation</label>
</div>
<div id=patCheckBoxes>
<br>
<input type="checkbox" id=patProgress><label for=patProgress>show PAT progress</label> 
</div>
<br>
<button onclick="parse()">go</button> <span id=result></span> <mark><span id=error></span></mark>

<p>
Annotated RE: <span id=annotated></span>

<p>
AST:
<p>
<span id=astTree></span>

<p>
<button onclick="showdfa()">DFA</button>
<div id=thedfa style="display:none">
<p>
First: <span id=bsfirst></span>
<p>
Follow: <span id=bsfollow></span>
<p>
DFA:
<span id=dfa></span>
<p>
<span id=playerbuttons></span>
<span id=animatephase class=blin></span>
<div id=dfasvg style="border:1px solid lightgray; position:relative"></div>
<span style="font-size:9pt;">
To move states: use left mouse button; to move edges, hover them and move the knots,
to move borders, drag them.
</span>
<span id=dfasvglabels></span>
<div id=dfaprogress></div>
</div>

<p>
<button id=patButton onclick="showpat()">PAT</button>
<p>
<span id=thepat></span>

<div id=divtrees>
<p>
Parenthetized trees:
<p>
<span id=parenthtrees></span>
<p>
<span id=compareparenth></span>

<p>
<span id=matchdash></span>

<p>
<span id=patdash></span>

<p>
Prior Tree:
<p>
<span id=tree></span>
</div>

<div id=alltrees>
All trees:
<p>
<div id=trees></div>
</div>

<p>
<FORM id="tracefls" style="display:none">
<div id=traceflags>
trace<input id=trcflag></input>
</div>
<span class=trcButton onclick="clicktrc(this)" data-f="c" name="trcfl">main</span>
<span class=trcButton onclick="clicktrc(this)" data-f="a" name="trcfl">analysis</span>
<span class=trcButton onclick="clicktrc(this)" data-f="b" name="trcfl">analysis+</span>
<span class=trcButton onclick="clicktrc(this)" data-f="e" name="trcfl">ast</span>
<span class=trcButton onclick="clicktrc(this)" data-f="n" name="trcfl">ngrams</span>
<span class=trcButton onclick="clicktrc(this)" data-f="g" name="trcfl">ngrams+</span>
<span class=trcButton onclick="clicktrc(this)" data-f="d" name="trcfl">dfa</span>
<span class=trcButton onclick="clicktrc(this)" data-f="h" name="trcfl">purge</span>
<span class=trcButton onclick="clicktrc(this)" data-f="m" name="trcfl">match</span>
<span class=trcButton onclick="clicktrc(this)" data-f="o" name="trcfl">match+</span>
<span class=trcButton onclick="clicktrc(this)" data-f="p" name="trcfl">tree</span>
<span class=trcButton onclick="clicktrc(this)" data-f="t" name="trcfl">tree+</span>
<span class=trcButton onclick="clicktrc(this)" data-f="s" name="trcfl">draw</span>
<span class=trcButton onclick="clicktrc(this)" data-f="u" name="trcfl">pat</span>
<span class=trcButton onclick="clicktrc(this)" data-f="v" name="trcfl">pat+</span>
<span class=trcButton onclick="clicktrc(this)" data-f="k" name="trcfl">matchpat</span>
<span class=trcButton onclick="clicktrc(this)" data-f="j" name="trcfl">matchpat+</span>
<span class=trcButton onclick="clicktrc(this)" data-f="r" name="trcfl">graph</span>
<span class=trcButton onclick="clicktrc(this)" data-f="A" name="trcfl">animation</span>
<span class=trcButton onclick="clicktrc(this)" data-f="G" name="trcfl">greedy</span>
</FORM>

<span id="textBox" style="position:absolute;visibility:hidden;height:auto;width:auto;white-space:nowrap;">
</span>

<script>
var browser = navigator.userAgent;
var mozilla = browser.indexOf("Mozilla");
if (mozilla < 0){
    alert("Browser: " + browser.substring(browser) + " not supported"); 
    error = true;
} else {
    var debug = true;
    if (debug){
        document.getElementById("tracefls").style.display = "block";
    }
    var pat = false;
    if (!pat){
        document.getElementById("patButton").style.display = "none";
        document.getElementById("patCheckBoxes").style.display = "none";
    }
    if (document.getElementById("posixprio").checked){
        test();
        if (testErrors > 0) twriteln("end test",testErrors,"tests failed");
    }
    error = false;
    setTrace();
    clearPage();

    // to make this web page produce Berry-Sethi DFAs (the traditional ones)
    // set the following to false
    BS_AUGM = true;
    if (!BS_AUGM){
        document.getElementById("divtrees").style.display = "none";
        document.getElementById("treesCheckBoxes").style.display = "none";
        document.getElementById("alltrees").style.display = "none";
    }
}
</script>

</body>
</html>

